{"version":3,"file":"sqlitecloud-sdk.min.js","mappings":"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","sources":["webpack://SQLiteCloud/webpack/universalModuleDefinition","webpack://SQLiteCloud/./src/core/index.js","webpack://SQLiteCloud/./src/core/messages.js","webpack://SQLiteCloud/./src/core/sqlitecloud.js","webpack://SQLiteCloud/webpack/bootstrap","webpack://SQLiteCloud/webpack/runtime/define property getters","webpack://SQLiteCloud/webpack/runtime/hasOwnProperty shorthand","webpack://SQLiteCloud/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SQLiteCloud\"] = factory();\n\telse\n\t\troot[\"SQLiteCloud\"] = factory();\n})(this, () => {\nreturn ","module.exports = require('./sqlitecloud.js').default;\r\n","export const msg = {\r\n  wsConnectOk: \"main websocket connection is active.\",\r\n  wsAlreadyConnected: \"main websocket connection has already been created.\",\r\n  wsCantConnectedWsPubSubExist: \"main websocket connection cannot be created because a PubSub websocket connection is already active.\",\r\n  wsConnectError: \"main websocket connection not established. Check your internet connection, project ID and API key.\",\r\n  wsClosingWsPubSubClosingProcess: \"closing of the main websocket and PubSub websocket started.\",\r\n  wsClosingProcess: \"closing of the main websocket started.\",\r\n  wsPubSubClosingProcess: \"closing of the PubSub websocket started.\",\r\n  wsCloseComplete: \"main websocket connection has been closed.\",\r\n  wsPubSubClosingProcess: \"closing of the PubSub websocket started.\",\r\n  wsPubSubCloseComplete: \"PubSub websocket connection has been closed.\",\r\n  wsClosingError: \"there is no main websocket that can be closed.\",\r\n  wsCloseByClient: \"main main websocket connection closed by client.\",\r\n  wsPubSubCloseByClient: \"PubSub websocket main websocket connection closed by client.\",\r\n  wsNotExist: \"main websocket connection not exist.\",\r\n  wsOnError: \"main websocket connection error.\",\r\n  wsPubSubOnError: \"PubSub websocket connection error.\",\r\n  wsConnecting: \"CONNECTING\",\r\n  wsOpen: \"OPEN\",\r\n  wsClosing: \"CLOSING\",\r\n  wsClosed: \"CLOSED\",\r\n  wsPubSubNotExist: \"PubSub websocket connection not exist.\",\r\n  wsPubSubConnecting: \"CONNECTING\",\r\n  wsPubSubOpen: \"OPEN\",\r\n  wsPubSubClosing: \"CLOSING\",\r\n  wsPubSubClosed: \"CLOSED\",\r\n  wsExecErrorNoConnection: \"you need to create a main websocket connection. Use the connect method.\",\r\n  wsNotifyErrorNoConnection: \"you need to create a main websocket connection. Use the connect method.\",\r\n  wsListenError: {\r\n    alreadySubscribed: \"registration already made to the channel:\",\r\n    errorNoConnection: \"you need to create a main websocket connection. Use the connect method.\",\r\n  },\r\n  wsUnlistenError: {\r\n    missingSubscritption: \"it is not possible to unlisten unregistered channel:\",\r\n    errorNoConnection: \"you have closed the main websocket connection, it is no longer possible to unlisten channels.\",\r\n  },\r\n  wsTimeoutError: \"the request timed out. ID:\",\r\n  createChannelErr:{\r\n    mandatory: \"channelName is mandatory\",\r\n    string: \"channelName has to be a string\"\r\n  },\r\n  removeChannelErr:{\r\n    mandatory: \"channelName is mandatory\",\r\n    string: \"channelName has to be a string\"\r\n  } \r\n}","import { msg } from \"./messages\";\r\n\r\n\r\n\r\nexport default class SQLiteCloud {\r\n  /* PRIVATE PROPERTIES */\r\n\r\n  /*\r\n  #ws private property stores the websocket used:\r\n    - to send \"exec\" type request\r\n    - to send \"pubsub\" subscription request\r\n    - to receive response to \"exec\" type request\r\n  \r\n  User receives the responses to his requests reading the result of a Promise.\r\n  */\r\n  #ws = null;\r\n\r\n  /*\r\n  #wsPubSub private property stores the websocket used to receive pubSub messages.\r\n  #wsPubSubUrl private property stores the websocket url\r\n  #uuid private property stores the user identifier. This can be used to not received messages sent by the current user\r\n  When a new message is received, based on the channel, is selected the callbacks to be called cycling through subscriptionsStack property\r\n  */\r\n  #wsPubSub = null;\r\n  #wsPubSubUrl = null;\r\n  #uuid = null;\r\n\r\n  /*\r\n  #requestsStack private property stores the list of pending requests, in this way the user can send multiple parallel requests.\r\n  For each request an object that contains the following is stored:\r\n  {\r\n    id: //unique id associated with the request \r\n    onRequestTimeout: //function called when the request times out\r\n    resolve: resolve, //function called when the Promise resolve\r\n    reject: reject //function called when the Promise reject\r\n  }\r\n  */\r\n  #requestsStack = new Map();\r\n\r\n  /*\r\n  #subscriptionsStack private property stores the list of pubSub subscriptions.\r\n  For each subscription an object that contains the following is stored:\r\n  {\r\n    channel: //the name of the channel you are subscribed to \r\n    callback: //the function called when a new message arrives\r\n  }\r\n  */\r\n  #subscriptionsStack = new Map();\r\n\r\n  /* PUBLIC PROPERTIES */\r\n  /*\r\n  requestTimeout property stores the time available to receive a response before the request times out.\r\n  filterSentMessages the library not return messages sent by the user\r\n  */\r\n  requestTimeout = 3000;\r\n  filterSentMessages = false;\r\n\r\n\r\n  /* CONSTRUCTOR */\r\n  /*\r\n  SQLiteCloud class constructor receives:\r\n   - project ID (required)\r\n   - api key (required)\r\n   - webSocket callback event (optional)\r\n  */\r\n  constructor(projectID, apikey, onError = null, onClose = null) {\r\n    this.url = `wss://web1.sqlitecloud.io:8443/api/v1/${projectID}/ws?apikey=${apikey}`;\r\n    this.onError = onError;\r\n    this.onClose = onClose;\r\n  }\r\n\r\n  /* PUBLIC METHODS */\r\n  /*\r\n  setRequestTimeout method allows the user to change the request timeout value\r\n  */\r\n  setRequestTimeout(value) {\r\n    this.requestTimeout = value;\r\n  }\r\n\r\n  /*\r\n  setFilterSentMessages method allows the user to filter or not sent messagess\r\n  */\r\n  setFilterSentMessages(value) {\r\n    this.filterSentMessages = value;\r\n  }\r\n\r\n\r\n  /*\r\n  connect method opens websocket connection\r\n  */\r\n  async connect() {\r\n    if (this.#ws == null) {\r\n      if (this.#wsPubSub == null) {\r\n        try {\r\n          this.#ws = await this.#connectWs(this.url, msg.wsConnectError);\r\n          //register the error event on websocket\r\n          this.#ws.addEventListener('error', this.#onErrorWs);\r\n          //register the close event on websocket\r\n          this.#ws.addEventListener('close', this.#onCloseWs);\r\n          return {\r\n            status: \"success\",\r\n            data: {\r\n              message: msg.wsConnectOk\r\n            }\r\n          }\r\n        } catch (error) {\r\n          return {\r\n            status: \"error\",\r\n            data: {\r\n              message: error.toString(),\r\n              error: error\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        return {\r\n          status: \"error\",\r\n          data: {\r\n            message: msg.wsCantConnectedWsPubSubExist\r\n          }\r\n        };\r\n      }\r\n    } else {\r\n      return {\r\n        status: \"error\",\r\n        data: {\r\n          message: msg.wsAlreadyConnected\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n  close method closes websocket connection and if exist pubSub websocket connection\r\n  - closePubSub = true (default true), this method close both WebSocket\r\n  - closePubSub = false this method close only main WebSocket\r\n  */\r\n  close(closePubSub = true) {\r\n    if (closePubSub) {\r\n      if (this.#wsPubSub !== null && this.#ws !== null) {\r\n        this.#wsPubSub.close(1000, msg.wsPubSubCloseByClient);\r\n        this.#subscriptionsStack = new Map();\r\n        this.#ws.close(1000, msg.wsCloseByClient);\r\n        return (\r\n          {\r\n            status: \"success\",\r\n            data: {\r\n              message: msg.wsClosingWsPubSubClosingProcess\r\n            }\r\n          }\r\n        )\r\n      } else if (this.#wsPubSub == null && this.#ws !== null) {\r\n        this.#ws.close(1000, msg.wsCloseByClient);\r\n        return (\r\n          {\r\n            status: \"success\",\r\n            data: {\r\n              message: msg.wsClosingProcess\r\n            }\r\n          }\r\n        )\r\n      } else if (this.#wsPubSub != null && this.#ws == null) {\r\n        this.#subscriptionsStack = new Map();\r\n        this.#wsPubSub.close(1000, msg.wsCloseByClient);\r\n        return (\r\n          {\r\n            status: \"success\",\r\n            data: {\r\n              message: msg.wsPubSubClosingProcess\r\n            }\r\n          }\r\n        )\r\n      } else {\r\n        return (\r\n          {\r\n            status: \"error\",\r\n            data: {\r\n              message: msg.wsClosingError\r\n            }\r\n          }\r\n        )\r\n      }\r\n    }\r\n    if (!closePubSub) {\r\n      if (this.#ws !== null) {\r\n        this.#ws.close(1000, msg.wsCloseByClient);\r\n        return (\r\n          {\r\n            status: \"success\",\r\n            data: {\r\n              message: msg.wsClosingProcess\r\n            }\r\n          }\r\n        )\r\n      } else {\r\n        return (\r\n          {\r\n            status: \"error\",\r\n            data: {\r\n              message: msg.wsClosingError\r\n            }\r\n          }\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n  connectionState method returns the actual state of websocket connection\r\n  */\r\n  get connectionState() {\r\n    let connectionStateString = msg.wsNotExist;\r\n    let connectionState = -1;\r\n    if (this.#ws !== null) {\r\n      connectionState = this.#ws.readyState;\r\n      switch (connectionState) {\r\n        case 0:\r\n          connectionStateString = msg.wsConnecting;\r\n          break;\r\n        case 1:\r\n          connectionStateString = msg.wsOpen;\r\n          break;\r\n        case 2:\r\n          connectionStateString = msg.wsClosing;\r\n          break;\r\n        case 3:\r\n          connectionStateString = msg.wsClosed;\r\n          break;\r\n        default:\r\n          connectionStateString = msg.wsNotExist;\r\n      }\r\n    }\r\n    return {\r\n      state: connectionState,\r\n      description: connectionStateString\r\n    };\r\n  }\r\n\r\n  /*\r\n  pubSubState method returns the actual state of pubSubState websocket connection\r\n  */\r\n  get pubSubState() {\r\n    let connectionStateString = msg.wsPubSubNotExist;\r\n    let connectionState = -1;\r\n    if (this.#wsPubSub !== null) {\r\n      connectionState = this.#wsPubSub.readyState;\r\n      switch (connectionState) {\r\n        case 0:\r\n          connectionStateString = msg.wsPubSubConnecting;\r\n          break;\r\n        case 1:\r\n          connectionStateString = msg.wsPubSubOpen;\r\n          break;\r\n        case 2:\r\n          connectionStateString = msg.wsPubSubClosing;\r\n          break;\r\n        case 3:\r\n          connectionStateString = msg.wsPubSubClosed;\r\n          break;\r\n        default:\r\n          connectionStateString = msg.wsPubSubNotExist;\r\n      }\r\n    }\r\n    return {\r\n      state: connectionState,\r\n      description: connectionStateString\r\n    };\r\n  }\r\n\r\n  /*\r\n  requestsStackState method return the lits of pending requests\r\n  */\r\n  get requestsStackState() {\r\n    return this.#requestsStack;\r\n  }\r\n\r\n  /*\r\n  subscriptionsStackState method return the lits of active subscriptions\r\n  */\r\n  get subscriptionsStackState() {\r\n    return this.#subscriptionsStack;\r\n  }\r\n\r\n\r\n  /*\r\n  exec method calls the private method promiseSend building the object \r\n  */\r\n  async exec(command) {\r\n    if (this.#ws !== null) {\r\n      try {\r\n        const response = await this.#promiseSend(\r\n          {\r\n            id: this.#makeid(5),\r\n            type: \"exec\",\r\n            command: command\r\n          }\r\n        );\r\n        return response;\r\n      } catch (error) {\r\n        return {\r\n          status: \"error\",\r\n          data: {\r\n            message: error.toString(),\r\n            error: error\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      return {\r\n        status: \"error\",\r\n        data: {\r\n          message: msg.wsExecErrorNoConnection\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n  notify method calls the private method promiseSend building the object \r\n  */\r\n  async notify(channel, payload) {\r\n    if (this.#ws !== null) {\r\n      try {\r\n        const response = await this.#promiseSend(\r\n          {\r\n            id: this.#makeid(5),\r\n            type: \"notify\",\r\n            channel: channel,\r\n            payload: JSON.stringify(payload)\r\n          }\r\n        );\r\n        if (response.status == \"success\") {\r\n          return (\r\n            {\r\n              status: response.status,\r\n              data: {\r\n                message: \"OK\"\r\n              }\r\n            }\r\n          )\r\n        }\r\n        if (response.status == \"error\") {\r\n          return response\r\n        }\r\n      } catch (error) {\r\n        return {\r\n          status: \"error\",\r\n          data: {\r\n            message: error.toString(),\r\n            error: error\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      return (\r\n        {\r\n          status: \"error\",\r\n          data: {\r\n            message: msg.wsNotifyErrorNoConnection\r\n          }\r\n        }\r\n      );\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n  listenChannel method calls the private method #pubsub to register to a new channel \r\n  */\r\n  async listenChannel(channel, callback) {\r\n    if (this.#ws !== null) {\r\n      try {\r\n        const response = await this.#pubsub(\"listenChannel\", channel, callback);\r\n        return response;\r\n      } catch (error) {\r\n        return {\r\n          status: \"error\",\r\n          data: {\r\n            message: error.toString(),\r\n            error: error\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      return ({\r\n        status: \"error\",\r\n        data: {\r\n          message: msg.wsListenError.errorNoConnection\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n  listenTable method calls the private method #pubsub to register to a new table \r\n  */\r\n  async listenTable(table, callback) {\r\n    if (this.#ws !== null) {\r\n      try {\r\n        const response = await this.#pubsub(\"listenTable\", table, callback);\r\n        return response;\r\n      } catch (error) {\r\n        return {\r\n          status: \"error\",\r\n          data: {\r\n            message: error.toString(),\r\n            error: error\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      return ({\r\n        status: \"error\",\r\n        data: {\r\n          message: msg.wsListenError.errorNoConnection\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n  unlistenChannel method calls the private method #pubsub to unregister to a channel \r\n  */\r\n  async unlistenChannel(channel) {\r\n    if (this.#ws !== null) {\r\n      try {\r\n        if (!this.#subscriptionsStack.has(channel)) {\r\n          return (\r\n            {\r\n              status: \"error\",\r\n              data: {\r\n                message: msg.wsUnlistenError.missingSubscritption + \" \" + channel\r\n              }\r\n            }\r\n          )\r\n        }\r\n        const response = await this.#pubsub(\"unlistenChannel\", channel, null);\r\n        return response;\r\n      } catch (error) {\r\n        return {\r\n          status: \"error\",\r\n          data: {\r\n            message: error.toString(),\r\n            error: error\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      return (\r\n        {\r\n          status: \"error\",\r\n          data: {\r\n            message: msg.wsUnlistenError.errorNoConnection\r\n          }\r\n        }\r\n      )\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n  unlistenTable method calls the private method #pubsub to unregister to a table \r\n  */\r\n  async unlistenTable(table) {\r\n    if (this.#ws !== null) {\r\n      try {\r\n        if (!this.#subscriptionsStack.has(table)) {\r\n          return (\r\n            {\r\n              status: \"error\",\r\n              data: {\r\n                message: msg.wsUnlistenError.missingSubscritption + \" \" + table\r\n              }\r\n            }\r\n          )\r\n        }\r\n        const response = await this.#pubsub(\"unlistenTable\", table, null);\r\n        return response;\r\n      } catch (error) {\r\n        return {\r\n          status: \"error\",\r\n          data: {\r\n            message: error.toString(),\r\n            error: error\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      return (\r\n        {\r\n          status: \"error\",\r\n          data: {\r\n            message: msg.wsUnlistenError.errorNoConnection\r\n          }\r\n        }\r\n      )\r\n    }\r\n  }\r\n\r\n  /*\r\n  listChannels method calls exec method to receive the list of all the existing channels \r\n  */\r\n  async listChannels() {\r\n    try {\r\n      const response = await this.exec(\"LIST CHANNELS\");\r\n      return (response);\r\n    } catch (error) {\r\n      return {\r\n        status: \"error\",\r\n        data: error\r\n      };\r\n    }\r\n  }\r\n\r\n  /*\r\n  createChannel method calls exec method to create a new channel\r\n  channelName: mandatory, the name of the channel to be created\r\n  ifNotExist: optional, if true set in the command the string [IF NOT EXISTS]\r\n  */\r\n  async createChannel(channelName, ifNotExist = true) {\r\n    try {\r\n      //params validation\r\n      //check channelName has been provided\r\n      if (!channelName) {\r\n        return (\r\n          {\r\n            status: \"error\",\r\n            data: {\r\n              message: msg.createChannelErr.mandatory\r\n            }\r\n          }\r\n        )\r\n      }\r\n      if (typeof channelName !== \"string\") {\r\n        return (\r\n          {\r\n            status: \"error\",\r\n            data: {\r\n              message: msg.createChannelErr.string\r\n            }\r\n          }\r\n        )\r\n      }\r\n      //params are ok\r\n      let command = `CREATE CHANNEL '${channelName}'`;\r\n      command = ifNotExist ? command + \" IF NOT EXISTS\" : command;\r\n      const response = await this.exec(command);\r\n      if (response.status == \"success\") {\r\n        return (\r\n          {\r\n            status: response.status,\r\n            data: {\r\n              message: response.data\r\n            }\r\n          }\r\n        )\r\n      }\r\n      if (response.status == \"error\") {\r\n        return response\r\n      }\r\n    } catch (error) {\r\n      return {\r\n        status: \"error\",\r\n        data: {\r\n          message: error.toString(),\r\n          error: error\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n  removeChannel method calls exec method to remove an existing channel \r\n  */\r\n  async removeChannel(channelName) {\r\n    try {\r\n      //params validation\r\n      //check channelName has been provided\r\n      if (!channelName) {\r\n        return (\r\n          {\r\n            status: \"error\",\r\n            data: {\r\n              message: msg.removeChannelErr.mandatory\r\n            }\r\n          }\r\n        )\r\n      }\r\n      if (typeof channelName !== \"string\") {\r\n        return (\r\n          {\r\n            status: \"error\",\r\n            data: {\r\n              message: msg.removeChannelErr.string\r\n            }\r\n          }\r\n        )\r\n      }\r\n      //params are ok\r\n      let command = `REMOVE CHANNEL '${channelName}'`;\r\n      const response = await this.exec(command);\r\n      if (response.status == \"success\") {\r\n        return (\r\n          {\r\n            status: response.status,\r\n            data: {\r\n              message: response.data\r\n            }\r\n          }\r\n        )\r\n      }\r\n      if (response.status == \"error\") {\r\n        return response\r\n      }\r\n    } catch (error) {\r\n      return {\r\n        status: \"error\",\r\n        data: {\r\n          message: error.toString(),\r\n          error: error\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /* PRIVATE METHODS */\r\n\r\n  /*\r\n  makeid method generates unique IDs to use for requests\r\n  */\r\n  #makeid(length = 5) {\r\n    var result = '';\r\n    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n    var charactersLength = characters.length;\r\n    for (var i = 0; i < length; i++) {\r\n      result += characters.charAt(Math.floor(Math.random() *\r\n        charactersLength));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /*\r\n  connectWs private method is called to create the websocket conenction used to send command request, receive command request response, pubSub subscription request, \r\n  */\r\n  #connectWs(url, errorMessage) {\r\n    return new Promise((resolve, reject) => {\r\n      var ws = new WebSocket(url);\r\n      ws.onopen = function () {\r\n        resolve(ws);\r\n      };\r\n      ws.onerror = function (err) {\r\n        reject({\r\n          err: err,\r\n          message: errorMessage\r\n        });\r\n      };\r\n    });\r\n  }\r\n\r\n  /*\r\n  onCloseWs private method is called when close event is fired by websocket.\r\n  if user provided a callback, this is invoked\r\n  */\r\n  #onCloseWs = (event) => {\r\n    if (this.onClose !== null) {\r\n      this.onClose(msg.wsCloseComplete);\r\n      this.#ws.removeEventListener('close', this.#onCloseWs);\r\n      this.#ws.removeEventListener('error', this.#onErrorWs);\r\n      this.#ws = null;\r\n    }\r\n  }\r\n\r\n  /*\r\n  onErrorWs private method is called when error event is fired by websocket.\r\n  if user provided a callback, this is invoked\r\n  */\r\n  #onErrorWs = (event) => {\r\n    if (this.onError !== null) {\r\n      this.onError(event, msg.wsOnError);\r\n    }\r\n  }\r\n\r\n  /*\r\n  onCloseWsPubSub private method is called when close event is fired by websocket.\r\n  if user provided a callback, this is invoked\r\n  */\r\n  #onCloseWsPubSub = (event) => {\r\n    if (this.onClose !== null) {\r\n      this.onClose(msg.wsPubSubCloseComplete);\r\n      this.#wsPubSub.removeEventListener('close', this.#onCloseWsPubSub);\r\n      this.#wsPubSub.removeEventListener('error', this.#onErrorWsPubSub);\r\n      this.#uuid = null;\r\n      this.#wsPubSub = null;\r\n    }\r\n  }\r\n\r\n  /*\r\n  onError private method is called when error event is fired by websocket.\r\n  if user provided a callback, this is invoked\r\n  */\r\n  #onErrorWsPubSub = (event) => {\r\n    if (this.onError !== null) {\r\n      this.onError(event, msg.wsPubSubOnError);\r\n    }\r\n  }\r\n\r\n  /*\r\n  pubsub method calls \r\n  */\r\n  async #pubsub(type, channel, callback) {\r\n    // channel = channel.toLowerCase();\r\n    //based on the value of callback, create a new subscription or remove the subscription\r\n    if (callback !== null) {\r\n      //check if the channel subscription is already active\r\n      if (!this.#subscriptionsStack.has(channel)) {\r\n        //if the subscription does not exist \r\n        try {\r\n          let body;\r\n          //based on type value build the right body\r\n          //important in case of channel, the channel key is present in the body\r\n          //important in case of table, the table key is present in the body\r\n          if (type == \"listenChannel\") {\r\n            body = {\r\n              id: this.#makeid(5),\r\n              type: \"listen\",\r\n              channel: channel,\r\n            }\r\n          }\r\n\r\n          if (type == \"listenTable\") {\r\n            body = {\r\n              id: this.#makeid(5),\r\n              type: \"listen\",\r\n              table: channel,\r\n            }\r\n          }\r\n\r\n          const response = await this.#promiseSend(body);\r\n          //if this is the first subscription, create the websocket connection dedicated to receive pubSub messages\r\n          if (this.#subscriptionsStack.size == 0 && response.status == \"success\") {\r\n            //response here we have authentication information\r\n            const uuid = response.data.uuid;\r\n            const secret = response.data.secret;\r\n            try {\r\n              this.#wsPubSubUrl = `wss://web1.sqlitecloud.io:8443/api/v1/wspsub?uuid=${uuid}&secret=${secret}`;\r\n              this.#wsPubSub = await this.#connectWs(this.#wsPubSubUrl, \"PubSub connection not established\");\r\n              //when the PubSub WebSocket is created the channel is added to the stack\r\n              this.#subscriptionsStack.set(channel,\r\n                {\r\n                  channel: channel,\r\n                  callback: callback\r\n                }\r\n              );\r\n              this.#uuid = uuid;\r\n              //register the onmessage event on pubSub websocket\r\n              this.#wsPubSub.addEventListener('message', this.#wsPubSubonMessage);\r\n              //register the close event on websocket\r\n              this.#wsPubSub.addEventListener('error', this.#onErrorWsPubSub);\r\n              //register the close event on websocket\r\n              this.#wsPubSub.addEventListener('close', this.#onCloseWsPubSub);\r\n            } catch (error) {\r\n              return {\r\n                status: \"error\",\r\n                data: error\r\n              };\r\n            }\r\n          }\r\n          //if this isn't the first subscription, just add the supscription to the stack\r\n          if (this.#subscriptionsStack.size > 0 && response.status == \"success\") {\r\n            this.#subscriptionsStack.set(channel,\r\n              {\r\n                channel: channel,\r\n                callback: callback\r\n              }\r\n            );\r\n          }\r\n          //build the object returned to client\r\n          let userResponse = {};\r\n          userResponse.status = response.status;\r\n          if (response.status == \"success\") {\r\n            userResponse.data = {};\r\n            userResponse.data.channel = response.data.channel;\r\n          }\r\n          if (response.status == \"error\") {\r\n            userResponse.data = response.data;\r\n          }\r\n          return userResponse;\r\n        } catch (error) {\r\n          return {\r\n            status: \"error\",\r\n            data: error\r\n          };\r\n        }\r\n      } else {\r\n        //if the subscription exists\r\n        return (\r\n          {\r\n            status: \"error\",\r\n            data: {\r\n              message: msg.wsListenError.alreadySubscribed + \" \" + channel\r\n            }\r\n          }\r\n        )\r\n      }\r\n    } else {\r\n      try {\r\n        let body;\r\n        //based on type value build the right body\r\n        //important in case of channel, the channel key is present in the body\r\n        //important in case of table, the table key is present in the body\r\n        if (type == \"unlistenChannel\") {\r\n          body = {\r\n            id: this.#makeid(5),\r\n            type: \"unlisten\",\r\n            channel: channel,\r\n          }\r\n        }\r\n        if (type == \"unlistenTable\") {\r\n          body = {\r\n            id: this.#makeid(5),\r\n            type: \"unlisten\",\r\n            table: channel,\r\n          }\r\n        }\r\n        const response = await this.#promiseSend(body);\r\n        this.#subscriptionsStack.delete(channel)\r\n        //check the remaing active subscription. If zero the websocket connection used for pubSub can be closed\r\n        if (this.#subscriptionsStack.size == 0) {\r\n          this.#wsPubSub.removeEventListener('message', this.#wsPubSubonMessage);\r\n          this.#wsPubSub.close(1000, msg.wsPubSubCloseByClient);\r\n        }\r\n        return (response);\r\n      } catch (error) {\r\n        return {\r\n          status: \"error\",\r\n          data: error\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n  wsPubSubonMessage private method is called when ad onmessage event is fired on pubSub websocket.\r\n  based on the channel indicated in the message the right callback is called\r\n  */\r\n  #wsPubSubonMessage = (event) => {\r\n    //since payload can be both a string or JSON, this function based on check of it is or not a valid JSON return the correct parsed paylod\r\n    function payloadParser(str) {\r\n      try {\r\n        JSON.parse(str);\r\n      } catch (e) {\r\n        return str;\r\n      }\r\n      return JSON.parse(str);\r\n    }\r\n    const pubSubMessage = JSON.parse(event.data);\r\n    const channel = pubSubMessage.channel; //pubSubMessage.channel.toLowerCase();\r\n    const sender = pubSubMessage.sender;\r\n    const payload = payloadParser(pubSubMessage.payload);\r\n    const ownMessage = this.#uuid == sender;\r\n    //build the obj returned to the user removing fields not usefull\r\n\r\n    const userPubSubMessage = {\r\n      channel: channel,\r\n      sender: sender,\r\n      payload: payload,\r\n      ownMessage: ownMessage\r\n    }\r\n    //this is the case in which the user decide to filter the message sent by himself\r\n    if (this.filterSentMessages && ownMessage) {\r\n\r\n    } else {\r\n      this.#subscriptionsStack.get(channel).callback(userPubSubMessage);\r\n    }\r\n  }\r\n\r\n  /*\r\n  promiseSend private method send request to the server creating a Promise that resolve when a websocket onmessage event is fired.\r\n  */\r\n  #promiseSend(request) {\r\n    //request is sent to the server\r\n    this.#ws.send(JSON.stringify(request));\r\n    //extract request id\r\n    const requestId = request.id;\r\n    //define the Promise that wait for the server response \r\n    return new Promise((resolve, reject) => {\r\n      //define what to do if an answer does not arrive within the set time\r\n      const onRequestTimeout = setTimeout(() => { this.#handlePromiseRejectTimeout(requestId) }, this.requestTimeout);\r\n      //add the new request to the request stack \r\n      this.#requestsStack.set(\r\n        requestId,\r\n        {\r\n          id: requestId,\r\n          onRequestTimeout: onRequestTimeout,\r\n          resolve: resolve,\r\n          reject: reject\r\n        }\r\n      )\r\n      //if this is the only one request in the stack, register the function to be executed at the onmessage event\r\n      if (this.#requestsStack.size == 1) this.#ws.addEventListener('message', this.#handlePromiseResolve);\r\n    })\r\n  }\r\n\r\n  /*\r\n  private handlePromiseResolve method is called when onmessage event is fired.\r\n  */\r\n  #handlePromiseResolve = (event) => {\r\n    //parse the response sent by the server\r\n    const response = JSON.parse(event.data);\r\n    //search in the requests stack the request with the same id of the response received by the server.\r\n    //it is possible that the request no longer exists as it may have timed out and therefore deleted from the stack.\r\n    //if the request was found:\r\n    // - the Promise corresponding to the request is resolved returning the response received by the server\r\n    // - the timeout related to the request is cleared\r\n    // - the new requests stack is stored\r\n    // - if there are no pending requests remove the websocket onmessage event\r\n    if (this.#requestsStack.has(response.id)) {\r\n      //build the obj returned to the user removing based on type\r\n      let userResponse = {};\r\n      switch (response.type) {\r\n        case \"exec\":\r\n          userResponse = {\r\n            status: response.status,\r\n            data: response.data\r\n          };\r\n          break;\r\n        case \"notify\":\r\n          userResponse = {\r\n            status: response.status,\r\n            data: response.data\r\n          };\r\n          break;\r\n        case \"listen\":\r\n          //in this case the message is passed as is because the uuid and secret field, if present, will be used to create wsPubSub connection\r\n          //the messega will be cleaned from this fields in #pubsub method\r\n          userResponse = response;\r\n          break;\r\n        case \"unlisten\":\r\n          userResponse = {\r\n            status: response.status,\r\n            data: response.data\r\n          };\r\n          break;\r\n        default:\r\n          userResponse = response;\r\n      }\r\n\r\n      this.#requestsStack.get(response.id).resolve(userResponse);\r\n      clearTimeout(this.#requestsStack.get(response.id).onRequestTimeout);\r\n      this.#requestsStack.delete(response.id);\r\n      if (this.#requestsStack.size == 0) this.#ws.removeEventListener('message', this.#handlePromiseResolve);\r\n    }\r\n  }\r\n\r\n  /*\r\n  private handlePromiseRejectTimeout method is called when a request times out.\r\n  */\r\n  #handlePromiseRejectTimeout = (requestID) => {\r\n    //search in the requests stack the request with the same id of the request that times out.\r\n    //a new requests stack is created by removing the request that times out.\r\n    //once the request is found:\r\n    // - the Promise corresponding to the reject returning an error message\r\n    // - the timeout related to the request is cleared\r\n    // - the new requests stack is stored\r\n    // - if there are no pending requests remove the websocket onmessage event\r\n    if (this.#requestsStack.has(requestID)) {\r\n      clearTimeout(this.#requestsStack.get(requestID).onRequestTimeout);\r\n      this.#requestsStack.get(requestID).reject({\r\n        message: msg.wsTimeoutError + \" \" + requestID\r\n      });\r\n      this.#requestsStack.delete(requestID);\r\n      if (this.#requestsStack.size == 0) this.#ws.removeEventListener('message', this.#handlePromiseResolve);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(763);\n"],"names":["root","factory","exports","module","define","amd","this","msg","alreadySubscribed","errorNoConnection","missingSubscritption","mandatory","string","SQLiteCloud","Map","requestTimeout","filterSentMessages","constructor","projectID","apikey","onError","onClose","url","setRequestTimeout","value","setFilterSentMessages","async","status","data","message","addEventListener","error","toString","close","closePubSub","connectionState","connectionStateString","readyState","state","description","pubSubState","requestsStackState","subscriptionsStackState","command","id","type","channel","payload","response","JSON","stringify","callback","table","has","exec","channelName","ifNotExist","length","result","characters","charactersLength","i","charAt","Math","floor","random","errorMessage","Promise","resolve","reject","ws","WebSocket","onopen","onerror","err","event","removeEventListener","body","size","uuid","secret","set","userResponse","delete","pubSubMessage","parse","sender","str","e","payloadParser","ownMessage","userPubSubMessage","get","request","send","requestId","onRequestTimeout","setTimeout","clearTimeout","requestID","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call"],"sourceRoot":""}