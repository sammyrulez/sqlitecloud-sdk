// The file was GENERATED by an amalgamation script.
// DO NOT EDIT BY HAND!!!



#define LZ4_STATIC_LINKING_ONLY
#include "sqlite3.h"

// ----------------------------------------------------------------------------
// BEGIN FILE: lz4.h
//


/*
 *  LZ4 - Fast LZ compression algorithm
 *  Header File
 *  Copyright (C) 2011-present, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
    - LZ4 homepage : http://www.lz4.org
    - LZ4 source repository : https://github.com/lz4/lz4
*/
#if defined (__cplusplus)
extern "C" {
#endif

#ifndef LZ4_H_2983827168210
#define LZ4_H_2983827168210

/* --- Dependency --- */
#include <stddef.h>   /* size_t */


/**
  Introduction

  LZ4 is lossless compression algorithm, providing compression speed >500 MB/s per core,
  scalable with multi-cores CPU. It features an extremely fast decoder, with speed in
  multiple GB/s per core, typically reaching RAM speed limits on multi-core systems.

  The LZ4 compression library provides in-memory compression and decompression functions.
  It gives full buffer control to user.
  Compression can be done in:
    - a single step (described as Simple Functions)
    - a single step, reusing a context (described in Advanced Functions)
    - unbounded multiple steps (described as Streaming compression)

  lz4.h generates and decodes LZ4-compressed blocks (doc/lz4_Block_format.md).
  Decompressing such a compressed block requires additional metadata.
  Exact metadata depends on exact decompression function.
  For the typical case of LZ4_decompress_safe(),
  metadata includes block's compressed size, and maximum bound of decompressed size.
  Each application is free to encode and pass such metadata in whichever way it wants.

  lz4.h only handle blocks, it can not generate Frames.

  Blocks are different from Frames (doc/lz4_Frame_format.md).
  Frames bundle both blocks and metadata in a specified manner.
  Embedding metadata is required for compressed data to be self-contained and portable.
  Frame format is delivered through a companion API, declared in lz4frame.h.
  The `lz4` CLI can only manage frames.
*/

/*^***************************************************************
*  Export parameters
*****************************************************************/
/*
*  LZ4_DLL_EXPORT :
*  Enable exporting of functions when building a Windows DLL
*  LZ4LIB_VISIBILITY :
*  Control library symbols visibility.
*/
#ifndef LZ4LIB_VISIBILITY
#  if defined(__GNUC__) && (__GNUC__ >= 4)
#    define LZ4LIB_VISIBILITY __attribute__ ((visibility ("default")))
#  else
#    define LZ4LIB_VISIBILITY
#  endif
#endif
#if defined(LZ4_DLL_EXPORT) && (LZ4_DLL_EXPORT==1)
#  define LZ4LIB_API __declspec(dllexport) LZ4LIB_VISIBILITY
#elif defined(LZ4_DLL_IMPORT) && (LZ4_DLL_IMPORT==1)
#  define LZ4LIB_API __declspec(dllimport) LZ4LIB_VISIBILITY /* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
#else
#  define LZ4LIB_API LZ4LIB_VISIBILITY
#endif

/*------   Version   ------*/
#define LZ4_VERSION_MAJOR    1    /* for breaking interface changes  */
#define LZ4_VERSION_MINOR    9    /* for new (non-breaking) interface capabilities */
#define LZ4_VERSION_RELEASE  3    /* for tweaks, bug-fixes, or development */

#define LZ4_VERSION_NUMBER (LZ4_VERSION_MAJOR *100*100 + LZ4_VERSION_MINOR *100 + LZ4_VERSION_RELEASE)

#define LZ4_LIB_VERSION LZ4_VERSION_MAJOR.LZ4_VERSION_MINOR.LZ4_VERSION_RELEASE
#define LZ4_QUOTE(str) #str
#define LZ4_EXPAND_AND_QUOTE(str) LZ4_QUOTE(str)
#define LZ4_VERSION_STRING LZ4_EXPAND_AND_QUOTE(LZ4_LIB_VERSION)

LZ4LIB_API int LZ4_versionNumber (void);  /**< library version number; useful to check dll version */
LZ4LIB_API const char* LZ4_versionString (void);   /**< library version string; useful to check dll version */


/*-************************************
*  Tuning parameter
**************************************/
/*!
 * LZ4_MEMORY_USAGE :
 * Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
 * Increasing memory usage improves compression ratio.
 * Reduced memory usage may improve speed, thanks to better cache locality.
 * Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache
 */
#ifndef LZ4_MEMORY_USAGE
# define LZ4_MEMORY_USAGE 14
#endif


/*-************************************
*  Simple Functions
**************************************/
/*! LZ4_compress_default() :
 *  Compresses 'srcSize' bytes from buffer 'src'
 *  into already allocated 'dst' buffer of size 'dstCapacity'.
 *  Compression is guaranteed to succeed if 'dstCapacity' >= LZ4_compressBound(srcSize).
 *  It also runs faster, so it's a recommended setting.
 *  If the function cannot compress 'src' into a more limited 'dst' budget,
 *  compression stops *immediately*, and the function result is zero.
 *  In which case, 'dst' content is undefined (invalid).
 *      srcSize : max supported value is LZ4_MAX_INPUT_SIZE.
 *      dstCapacity : size of buffer 'dst' (which must be already allocated)
 *     @return  : the number of bytes written into buffer 'dst' (necessarily <= dstCapacity)
 *                or 0 if compression fails
 * Note : This function is protected against buffer overflow scenarios (never writes outside 'dst' buffer, nor read outside 'source' buffer).
 */
LZ4LIB_API int LZ4_compress_default(const char* src, char* dst, int srcSize, int dstCapacity);

/*! LZ4_decompress_safe() :
 *  compressedSize : is the exact complete size of the compressed block.
 *  dstCapacity : is the size of destination buffer (which must be already allocated), presumed an upper bound of decompressed size.
 * @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity)
 *           If destination buffer is not large enough, decoding will stop and output an error code (negative value).
 *           If the source stream is detected malformed, the function will stop decoding and return a negative result.
 * Note 1 : This function is protected against malicious data packets :
 *          it will never writes outside 'dst' buffer, nor read outside 'source' buffer,
 *          even if the compressed block is maliciously modified to order the decoder to do these actions.
 *          In such case, the decoder stops immediately, and considers the compressed block malformed.
 * Note 2 : compressedSize and dstCapacity must be provided to the function, the compressed block does not contain them.
 *          The implementation is free to send / store / derive this information in whichever way is most beneficial.
 *          If there is a need for a different format which bundles together both compressed data and its metadata, consider looking at lz4frame.h instead.
 */
LZ4LIB_API int LZ4_decompress_safe (const char* src, char* dst, int compressedSize, int dstCapacity);


/*-************************************
*  Advanced Functions
**************************************/
#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */
#define LZ4_COMPRESSBOUND(isize)  ((unsigned)(isize) > (unsigned)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)

/*! LZ4_compressBound() :
    Provides the maximum size that LZ4 compression may output in a "worst case" scenario (input data not compressible)
    This function is primarily useful for memory allocation purposes (destination buffer size).
    Macro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).
    Note that LZ4_compress_default() compresses faster when dstCapacity is >= LZ4_compressBound(srcSize)
        inputSize  : max supported value is LZ4_MAX_INPUT_SIZE
        return : maximum output size in a "worst case" scenario
              or 0, if input size is incorrect (too large or negative)
*/
LZ4LIB_API int LZ4_compressBound(int inputSize);

/*! LZ4_compress_fast() :
    Same as LZ4_compress_default(), but allows selection of "acceleration" factor.
    The larger the acceleration value, the faster the algorithm, but also the lesser the compression.
    It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed.
    An acceleration value of "1" is the same as regular LZ4_compress_default()
    Values <= 0 will be replaced by LZ4_ACCELERATION_DEFAULT (currently == 1, see lz4.c).
    Values > LZ4_ACCELERATION_MAX will be replaced by LZ4_ACCELERATION_MAX (currently == 65537, see lz4.c).
*/
LZ4LIB_API int LZ4_compress_fast (const char* src, char* dst, int srcSize, int dstCapacity, int acceleration);


/*! LZ4_compress_fast_extState() :
 *  Same as LZ4_compress_fast(), using an externally allocated memory space for its state.
 *  Use LZ4_sizeofState() to know how much memory must be allocated,
 *  and allocate it on 8-bytes boundaries (using `malloc()` typically).
 *  Then, provide this buffer as `void* state` to compression function.
 */
LZ4LIB_API int LZ4_sizeofState(void);
LZ4LIB_API int LZ4_compress_fast_extState (void* state, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration);


/*! LZ4_compress_destSize() :
 *  Reverse the logic : compresses as much data as possible from 'src' buffer
 *  into already allocated buffer 'dst', of size >= 'targetDestSize'.
 *  This function either compresses the entire 'src' content into 'dst' if it's large enough,
 *  or fill 'dst' buffer completely with as much data as possible from 'src'.
 *  note: acceleration parameter is fixed to "default".
 *
 * *srcSizePtr : will be modified to indicate how many bytes where read from 'src' to fill 'dst'.
 *               New value is necessarily <= input value.
 * @return : Nb bytes written into 'dst' (necessarily <= targetDestSize)
 *           or 0 if compression fails.
 *
 * Note : from v1.8.2 to v1.9.1, this function had a bug (fixed un v1.9.2+):
 *        the produced compressed content could, in specific circumstances,
 *        require to be decompressed into a destination buffer larger
 *        by at least 1 byte than the content to decompress.
 *        If an application uses `LZ4_compress_destSize()`,
 *        it's highly recommended to update liblz4 to v1.9.2 or better.
 *        If this can't be done or ensured,
 *        the receiving decompression function should provide
 *        a dstCapacity which is > decompressedSize, by at least 1 byte.
 *        See https://github.com/lz4/lz4/issues/859 for details
 */
LZ4LIB_API int LZ4_compress_destSize (const char* src, char* dst, int* srcSizePtr, int targetDstSize);


/*! LZ4_decompress_safe_partial() :
 *  Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',
 *  into destination buffer 'dst' of size 'dstCapacity'.
 *  Up to 'targetOutputSize' bytes will be decoded.
 *  The function stops decoding on reaching this objective.
 *  This can be useful to boost performance
 *  whenever only the beginning of a block is required.
 *
 * @return : the number of bytes decoded in `dst` (necessarily <= targetOutputSize)
 *           If source stream is detected malformed, function returns a negative result.
 *
 *  Note 1 : @return can be < targetOutputSize, if compressed block contains less data.
 *
 *  Note 2 : targetOutputSize must be <= dstCapacity
 *
 *  Note 3 : this function effectively stops decoding on reaching targetOutputSize,
 *           so dstCapacity is kind of redundant.
 *           This is because in older versions of this function,
 *           decoding operation would still write complete sequences.
 *           Therefore, there was no guarantee that it would stop writing at exactly targetOutputSize,
 *           it could write more bytes, though only up to dstCapacity.
 *           Some "margin" used to be required for this operation to work properly.
 *           Thankfully, this is no longer necessary.
 *           The function nonetheless keeps the same signature, in an effort to preserve API compatibility.
 *
 *  Note 4 : If srcSize is the exact size of the block,
 *           then targetOutputSize can be any value,
 *           including larger than the block's decompressed size.
 *           The function will, at most, generate block's decompressed size.
 *
 *  Note 5 : If srcSize is _larger_ than block's compressed size,
 *           then targetOutputSize **MUST** be <= block's decompressed size.
 *           Otherwise, *silent corruption will occur*.
 */
LZ4LIB_API int LZ4_decompress_safe_partial (const char* src, char* dst, int srcSize, int targetOutputSize, int dstCapacity);


/*-*********************************************
*  Streaming Compression Functions
***********************************************/
typedef union LZ4_stream_u LZ4_stream_t;  /* incomplete type (defined later) */

LZ4LIB_API LZ4_stream_t* LZ4_createStream(void);
LZ4LIB_API int           LZ4_freeStream (LZ4_stream_t* streamPtr);

/*! LZ4_resetStream_fast() : v1.9.0+
 *  Use this to prepare an LZ4_stream_t for a new chain of dependent blocks
 *  (e.g., LZ4_compress_fast_continue()).
 *
 *  An LZ4_stream_t must be initialized once before usage.
 *  This is automatically done when created by LZ4_createStream().
 *  However, should the LZ4_stream_t be simply declared on stack (for example),
 *  it's necessary to initialize it first, using LZ4_initStream().
 *
 *  After init, start any new stream with LZ4_resetStream_fast().
 *  A same LZ4_stream_t can be re-used multiple times consecutively
 *  and compress multiple streams,
 *  provided that it starts each new stream with LZ4_resetStream_fast().
 *
 *  LZ4_resetStream_fast() is much faster than LZ4_initStream(),
 *  but is not compatible with memory regions containing garbage data.
 *
 *  Note: it's only useful to call LZ4_resetStream_fast()
 *        in the context of streaming compression.
 *        The *extState* functions perform their own resets.
 *        Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive.
 */
LZ4LIB_API void LZ4_resetStream_fast (LZ4_stream_t* streamPtr);

/*! LZ4_loadDict() :
 *  Use this function to reference a static dictionary into LZ4_stream_t.
 *  The dictionary must remain available during compression.
 *  LZ4_loadDict() triggers a reset, so any previous data will be forgotten.
 *  The same dictionary will have to be loaded on decompression side for successful decoding.
 *  Dictionary are useful for better compression of small data (KB range).
 *  While LZ4 accept any input as dictionary,
 *  results are generally better when using Zstandard's Dictionary Builder.
 *  Loading a size of 0 is allowed, and is the same as reset.
 * @return : loaded dictionary size, in bytes (necessarily <= 64 KB)
 */
LZ4LIB_API int LZ4_loadDict (LZ4_stream_t* streamPtr, const char* dictionary, int dictSize);

/*! LZ4_compress_fast_continue() :
 *  Compress 'src' content using data from previously compressed blocks, for better compression ratio.
 * 'dst' buffer must be already allocated.
 *  If dstCapacity >= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster.
 *
 * @return : size of compressed block
 *           or 0 if there is an error (typically, cannot fit into 'dst').
 *
 *  Note 1 : Each invocation to LZ4_compress_fast_continue() generates a new block.
 *           Each block has precise boundaries.
 *           Each block must be decompressed separately, calling LZ4_decompress_*() with relevant metadata.
 *           It's not possible to append blocks together and expect a single invocation of LZ4_decompress_*() to decompress them together.
 *
 *  Note 2 : The previous 64KB of source data is __assumed__ to remain present, unmodified, at same address in memory !
 *
 *  Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB.
 *           Make sure that buffers are separated, by at least one byte.
 *           This construction ensures that each block only depends on previous block.
 *
 *  Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB.
 *
 *  Note 5 : After an error, the stream status is undefined (invalid), it can only be reset or freed.
 */
LZ4LIB_API int LZ4_compress_fast_continue (LZ4_stream_t* streamPtr, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration);

/*! LZ4_saveDict() :
 *  If last 64KB data cannot be guaranteed to remain available at its current memory location,
 *  save it into a safer place (char* safeBuffer).
 *  This is schematically equivalent to a memcpy() followed by LZ4_loadDict(),
 *  but is much faster, because LZ4_saveDict() doesn't need to rebuild tables.
 * @return : saved dictionary size in bytes (necessarily <= maxDictSize), or 0 if error.
 */
LZ4LIB_API int LZ4_saveDict (LZ4_stream_t* streamPtr, char* safeBuffer, int maxDictSize);


/*-**********************************************
*  Streaming Decompression Functions
*  Bufferless synchronous API
************************************************/
typedef union LZ4_streamDecode_u LZ4_streamDecode_t;   /* tracking context */

/*! LZ4_createStreamDecode() and LZ4_freeStreamDecode() :
 *  creation / destruction of streaming decompression tracking context.
 *  A tracking context can be re-used multiple times.
 */
LZ4LIB_API LZ4_streamDecode_t* LZ4_createStreamDecode(void);
LZ4LIB_API int                 LZ4_freeStreamDecode (LZ4_streamDecode_t* LZ4_stream);

/*! LZ4_setStreamDecode() :
 *  An LZ4_streamDecode_t context can be allocated once and re-used multiple times.
 *  Use this function to start decompression of a new stream of blocks.
 *  A dictionary can optionally be set. Use NULL or size 0 for a reset order.
 *  Dictionary is presumed stable : it must remain accessible and unmodified during next decompression.
 * @return : 1 if OK, 0 if error
 */
LZ4LIB_API int LZ4_setStreamDecode (LZ4_streamDecode_t* LZ4_streamDecode, const char* dictionary, int dictSize);

/*! LZ4_decoderRingBufferSize() : v1.8.2+
 *  Note : in a ring buffer scenario (optional),
 *  blocks are presumed decompressed next to each other
 *  up to the moment there is not enough remaining space for next block (remainingSize < maxBlockSize),
 *  at which stage it resumes from beginning of ring buffer.
 *  When setting such a ring buffer for streaming decompression,
 *  provides the minimum size of this ring buffer
 *  to be compatible with any source respecting maxBlockSize condition.
 * @return : minimum ring buffer size,
 *           or 0 if there is an error (invalid maxBlockSize).
 */
LZ4LIB_API int LZ4_decoderRingBufferSize(int maxBlockSize);
#define LZ4_DECODER_RING_BUFFER_SIZE(maxBlockSize) (65536 + 14 + (maxBlockSize))  /* for static allocation; maxBlockSize presumed valid */

/*! LZ4_decompress_*_continue() :
 *  These decoding functions allow decompression of consecutive blocks in "streaming" mode.
 *  A block is an unsplittable entity, it must be presented entirely to a decompression function.
 *  Decompression functions only accepts one block at a time.
 *  The last 64KB of previously decoded data *must* remain available and unmodified at the memory position where they were decoded.
 *  If less than 64KB of data has been decoded, all the data must be present.
 *
 *  Special : if decompression side sets a ring buffer, it must respect one of the following conditions :
 *  - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize).
 *    maxBlockSize is the maximum size of any single block. It can have any value > 16 bytes.
 *    In which case, encoding and decoding buffers do not need to be synchronized.
 *    Actually, data can be produced by any source compliant with LZ4 format specification, and respecting maxBlockSize.
 *  - Synchronized mode :
 *    Decompression buffer size is _exactly_ the same as compression buffer size,
 *    and follows exactly same update rule (block boundaries at same positions),
 *    and decoding function is provided with exact decompressed size of each block (exception for last block of the stream),
 *    _then_ decoding & encoding ring buffer can have any size, including small ones ( < 64 KB).
 *  - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes.
 *    In which case, encoding and decoding buffers do not need to be synchronized,
 *    and encoding ring buffer can have any size, including small ones ( < 64 KB).
 *
 *  Whenever these conditions are not possible,
 *  save the last 64KB of decoded data into a safe buffer where it can't be modified during decompression,
 *  then indicate where this data is saved using LZ4_setStreamDecode(), before decompressing next block.
*/
LZ4LIB_API int LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* src, char* dst, int srcSize, int dstCapacity);


/*! LZ4_decompress_*_usingDict() :
 *  These decoding functions work the same as
 *  a combination of LZ4_setStreamDecode() followed by LZ4_decompress_*_continue()
 *  They are stand-alone, and don't need an LZ4_streamDecode_t structure.
 *  Dictionary is presumed stable : it must remain accessible and unmodified during decompression.
 *  Performance tip : Decompression speed can be substantially increased
 *                    when dst == dictStart + dictSize.
 */
LZ4LIB_API int LZ4_decompress_safe_usingDict (const char* src, char* dst, int srcSize, int dstCapcity, const char* dictStart, int dictSize);

#endif /* LZ4_H_2983827168210 */


/*^*************************************
 * !!!!!!   STATIC LINKING ONLY   !!!!!!
 ***************************************/

/*-****************************************************************************
 * Experimental section
 *
 * Symbols declared in this section must be considered unstable. Their
 * signatures or semantics may change, or they may be removed altogether in the
 * future. They are therefore only safe to depend on when the caller is
 * statically linked against the library.
 *
 * To protect against unsafe usage, not only are the declarations guarded,
 * the definitions are hidden by default
 * when building LZ4 as a shared/dynamic library.
 *
 * In order to access these declarations,
 * define LZ4_STATIC_LINKING_ONLY in your application
 * before including LZ4's headers.
 *
 * In order to make their implementations accessible dynamically, you must
 * define LZ4_PUBLISH_STATIC_FUNCTIONS when building the LZ4 library.
 ******************************************************************************/

#ifdef LZ4_STATIC_LINKING_ONLY

#ifndef LZ4_STATIC_3504398509
#define LZ4_STATIC_3504398509

#ifdef LZ4_PUBLISH_STATIC_FUNCTIONS
#define LZ4LIB_STATIC_API LZ4LIB_API
#else
#define LZ4LIB_STATIC_API
#endif


/*! LZ4_compress_fast_extState_fastReset() :
 *  A variant of LZ4_compress_fast_extState().
 *
 *  Using this variant avoids an expensive initialization step.
 *  It is only safe to call if the state buffer is known to be correctly initialized already
 *  (see above comment on LZ4_resetStream_fast() for a definition of "correctly initialized").
 *  From a high level, the difference is that
 *  this function initializes the provided state with a call to something like LZ4_resetStream_fast()
 *  while LZ4_compress_fast_extState() starts with a call to LZ4_resetStream().
 */
LZ4LIB_STATIC_API int LZ4_compress_fast_extState_fastReset (void* state, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration);

/*! LZ4_attach_dictionary() :
 *  This is an experimental API that allows
 *  efficient use of a static dictionary many times.
 *
 *  Rather than re-loading the dictionary buffer into a working context before
 *  each compression, or copying a pre-loaded dictionary's LZ4_stream_t into a
 *  working LZ4_stream_t, this function introduces a no-copy setup mechanism,
 *  in which the working stream references the dictionary stream in-place.
 *
 *  Several assumptions are made about the state of the dictionary stream.
 *  Currently, only streams which have been prepared by LZ4_loadDict() should
 *  be expected to work.
 *
 *  Alternatively, the provided dictionaryStream may be NULL,
 *  in which case any existing dictionary stream is unset.
 *
 *  If a dictionary is provided, it replaces any pre-existing stream history.
 *  The dictionary contents are the only history that can be referenced and
 *  logically immediately precede the data compressed in the first subsequent
 *  compression call.
 *
 *  The dictionary will only remain attached to the working stream through the
 *  first compression call, at the end of which it is cleared. The dictionary
 *  stream (and source buffer) must remain in-place / accessible / unchanged
 *  through the completion of the first compression call on the stream.
 */
LZ4LIB_STATIC_API void LZ4_attach_dictionary(LZ4_stream_t* workingStream, const LZ4_stream_t* dictionaryStream);


/*! In-place compression and decompression
 *
 * It's possible to have input and output sharing the same buffer,
 * for highly contrained memory environments.
 * In both cases, it requires input to lay at the end of the buffer,
 * and decompression to start at beginning of the buffer.
 * Buffer size must feature some margin, hence be larger than final size.
 *
 * |<------------------------buffer--------------------------------->|
 *                             |<-----------compressed data--------->|
 * |<-----------decompressed size------------------>|
 *                                                  |<----margin---->|
 *
 * This technique is more useful for decompression,
 * since decompressed size is typically larger,
 * and margin is short.
 *
 * In-place decompression will work inside any buffer
 * which size is >= LZ4_DECOMPRESS_INPLACE_BUFFER_SIZE(decompressedSize).
 * This presumes that decompressedSize > compressedSize.
 * Otherwise, it means compression actually expanded data,
 * and it would be more efficient to store such data with a flag indicating it's not compressed.
 * This can happen when data is not compressible (already compressed, or encrypted).
 *
 * For in-place compression, margin is larger, as it must be able to cope with both
 * history preservation, requiring input data to remain unmodified up to LZ4_DISTANCE_MAX,
 * and data expansion, which can happen when input is not compressible.
 * As a consequence, buffer size requirements are much higher,
 * and memory savings offered by in-place compression are more limited.
 *
 * There are ways to limit this cost for compression :
 * - Reduce history size, by modifying LZ4_DISTANCE_MAX.
 *   Note that it is a compile-time constant, so all compressions will apply this limit.
 *   Lower values will reduce compression ratio, except when input_size < LZ4_DISTANCE_MAX,
 *   so it's a reasonable trick when inputs are known to be small.
 * - Require the compressor to deliver a "maximum compressed size".
 *   This is the `dstCapacity` parameter in `LZ4_compress*()`.
 *   When this size is < LZ4_COMPRESSBOUND(inputSize), then compression can fail,
 *   in which case, the return code will be 0 (zero).
 *   The caller must be ready for these cases to happen,
 *   and typically design a backup scheme to send data uncompressed.
 * The combination of both techniques can significantly reduce
 * the amount of margin required for in-place compression.
 *
 * In-place compression can work in any buffer
 * which size is >= (maxCompressedSize)
 * with maxCompressedSize == LZ4_COMPRESSBOUND(srcSize) for guaranteed compression success.
 * LZ4_COMPRESS_INPLACE_BUFFER_SIZE() depends on both maxCompressedSize and LZ4_DISTANCE_MAX,
 * so it's possible to reduce memory requirements by playing with them.
 */

#define LZ4_DECOMPRESS_INPLACE_MARGIN(compressedSize)          (((compressedSize) >> 8) + 32)
#define LZ4_DECOMPRESS_INPLACE_BUFFER_SIZE(decompressedSize)   ((decompressedSize) + LZ4_DECOMPRESS_INPLACE_MARGIN(decompressedSize))  /**< note: presumes that compressedSize < decompressedSize. note2: margin is overestimated a bit, since it could use compressedSize instead */

#ifndef LZ4_DISTANCE_MAX   /* history window size; can be user-defined at compile time */
#  define LZ4_DISTANCE_MAX 65535   /* set to maximum value by default */
#endif

#define LZ4_COMPRESS_INPLACE_MARGIN                           (LZ4_DISTANCE_MAX + 32)   /* LZ4_DISTANCE_MAX can be safely replaced by srcSize when it's smaller */
#define LZ4_COMPRESS_INPLACE_BUFFER_SIZE(maxCompressedSize)   ((maxCompressedSize) + LZ4_COMPRESS_INPLACE_MARGIN)  /**< maxCompressedSize is generally LZ4_COMPRESSBOUND(inputSize), but can be set to any lower value, with the risk that compression can fail (return code 0(zero)) */

#endif   /* LZ4_STATIC_3504398509 */
#endif   /* LZ4_STATIC_LINKING_ONLY */



#ifndef LZ4_H_98237428734687
#define LZ4_H_98237428734687

/*-************************************************************
 *  Private Definitions
 **************************************************************
 * Do not use these definitions directly.
 * They are only exposed to allow static allocation of `LZ4_stream_t` and `LZ4_streamDecode_t`.
 * Accessing members will expose user code to API and/or ABI break in future versions of the library.
 **************************************************************/
#define LZ4_HASHLOG   (LZ4_MEMORY_USAGE-2)
#define LZ4_HASHTABLESIZE (1 << LZ4_MEMORY_USAGE)
#define LZ4_HASH_SIZE_U32 (1 << LZ4_HASHLOG)       /* required as macro for static allocation */

#if defined(__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
# include <stdint.h>
  typedef  int8_t  LZ4_i8;
  typedef uint8_t  LZ4_byte;
  typedef uint16_t LZ4_u16;
  typedef uint32_t LZ4_u32;
#else
  typedef   signed char  LZ4_i8;
  typedef unsigned char  LZ4_byte;
  typedef unsigned short LZ4_u16;
  typedef unsigned int   LZ4_u32;
#endif

typedef struct LZ4_stream_t_internal LZ4_stream_t_internal;
struct LZ4_stream_t_internal {
    LZ4_u32 hashTable[LZ4_HASH_SIZE_U32];
    LZ4_u32 currentOffset;
    LZ4_u32 tableType;
    const LZ4_byte* dictionary;
    const LZ4_stream_t_internal* dictCtx;
    LZ4_u32 dictSize;
};

typedef struct {
    const LZ4_byte* externalDict;
    size_t extDictSize;
    const LZ4_byte* prefixEnd;
    size_t prefixSize;
} LZ4_streamDecode_t_internal;


/*! LZ4_stream_t :
 *  Do not use below internal definitions directly !
 *  Declare or allocate an LZ4_stream_t instead.
 *  LZ4_stream_t can also be created using LZ4_createStream(), which is recommended.
 *  The structure definition can be convenient for static allocation
 *  (on stack, or as part of larger structure).
 *  Init this structure with LZ4_initStream() before first use.
 *  note : only use this definition in association with static linking !
 *  this definition is not API/ABI safe, and may change in future versions.
 */
#define LZ4_STREAMSIZE       16416  /* static size, for inter-version compatibility */
#define LZ4_STREAMSIZE_VOIDP (LZ4_STREAMSIZE / sizeof(void*))
union LZ4_stream_u {
    void* table[LZ4_STREAMSIZE_VOIDP];
    LZ4_stream_t_internal internal_donotuse;
}; /* previously typedef'd to LZ4_stream_t */


/*! LZ4_initStream() : v1.9.0+
 *  An LZ4_stream_t structure must be initialized at least once.
 *  This is automatically done when invoking LZ4_createStream(),
 *  but it's not when the structure is simply declared on stack (for example).
 *
 *  Use LZ4_initStream() to properly initialize a newly declared LZ4_stream_t.
 *  It can also initialize any arbitrary buffer of sufficient size,
 *  and will @return a pointer of proper type upon initialization.
 *
 *  Note : initialization fails if size and alignment conditions are not respected.
 *         In which case, the function will @return NULL.
 *  Note2: An LZ4_stream_t structure guarantees correct alignment and size.
 *  Note3: Before v1.9.0, use LZ4_resetStream() instead
 */
LZ4LIB_API LZ4_stream_t* LZ4_initStream (void* buffer, size_t size);


/*! LZ4_streamDecode_t :
 *  information structure to track an LZ4 stream during decompression.
 *  init this structure  using LZ4_setStreamDecode() before first use.
 *  note : only use in association with static linking !
 *         this definition is not API/ABI safe,
 *         and may change in a future version !
 */
#define LZ4_STREAMDECODESIZE_U64 (4 + ((sizeof(void*)==16) ? 2 : 0) /*AS-400*/ )
#define LZ4_STREAMDECODESIZE     (LZ4_STREAMDECODESIZE_U64 * sizeof(unsigned long long))
union LZ4_streamDecode_u {
    unsigned long long table[LZ4_STREAMDECODESIZE_U64];
    LZ4_streamDecode_t_internal internal_donotuse;
} ;   /* previously typedef'd to LZ4_streamDecode_t */



/*-************************************
*  Obsolete Functions
**************************************/

/*! Deprecation warnings
 *
 *  Deprecated functions make the compiler generate a warning when invoked.
 *  This is meant to invite users to update their source code.
 *  Should deprecation warnings be a problem, it is generally possible to disable them,
 *  typically with -Wno-deprecated-declarations for gcc
 *  or _CRT_SECURE_NO_WARNINGS in Visual.
 *
 *  Another method is to define LZ4_DISABLE_DEPRECATE_WARNINGS
 *  before including the header file.
 */
#ifdef LZ4_DISABLE_DEPRECATE_WARNINGS
#  define LZ4_DEPRECATED(message)   /* disable deprecation warnings */
#else
#  if defined (__cplusplus) && (__cplusplus >= 201402) /* C++14 or greater */
#    define LZ4_DEPRECATED(message) [[deprecated(message)]]
#  elif defined(_MSC_VER)
#    define LZ4_DEPRECATED(message) __declspec(deprecated(message))
#  elif defined(__clang__) || (defined(__GNUC__) && (__GNUC__ * 10 + __GNUC_MINOR__ >= 45))
#    define LZ4_DEPRECATED(message) __attribute__((deprecated(message)))
#  elif defined(__GNUC__) && (__GNUC__ * 10 + __GNUC_MINOR__ >= 31)
#    define LZ4_DEPRECATED(message) __attribute__((deprecated))
#  else
#    pragma message("WARNING: LZ4_DEPRECATED needs custom implementation for this compiler")
#    define LZ4_DEPRECATED(message)   /* disabled */
#  endif
#endif /* LZ4_DISABLE_DEPRECATE_WARNINGS */

/*! Obsolete compression functions (since v1.7.3) */
LZ4_DEPRECATED("use LZ4_compress_default() instead")       LZ4LIB_API int LZ4_compress               (const char* src, char* dest, int srcSize);
LZ4_DEPRECATED("use LZ4_compress_default() instead")       LZ4LIB_API int LZ4_compress_limitedOutput (const char* src, char* dest, int srcSize, int maxOutputSize);
LZ4_DEPRECATED("use LZ4_compress_fast_extState() instead") LZ4LIB_API int LZ4_compress_withState               (void* state, const char* source, char* dest, int inputSize);
LZ4_DEPRECATED("use LZ4_compress_fast_extState() instead") LZ4LIB_API int LZ4_compress_limitedOutput_withState (void* state, const char* source, char* dest, int inputSize, int maxOutputSize);
LZ4_DEPRECATED("use LZ4_compress_fast_continue() instead") LZ4LIB_API int LZ4_compress_continue                (LZ4_stream_t* LZ4_streamPtr, const char* source, char* dest, int inputSize);
LZ4_DEPRECATED("use LZ4_compress_fast_continue() instead") LZ4LIB_API int LZ4_compress_limitedOutput_continue  (LZ4_stream_t* LZ4_streamPtr, const char* source, char* dest, int inputSize, int maxOutputSize);

/*! Obsolete decompression functions (since v1.8.0) */
LZ4_DEPRECATED("use LZ4_decompress_fast() instead") LZ4LIB_API int LZ4_uncompress (const char* source, char* dest, int outputSize);
LZ4_DEPRECATED("use LZ4_decompress_safe() instead") LZ4LIB_API int LZ4_uncompress_unknownOutputSize (const char* source, char* dest, int isize, int maxOutputSize);

/* Obsolete streaming functions (since v1.7.0)
 * degraded functionality; do not use!
 *
 * In order to perform streaming compression, these functions depended on data
 * that is no longer tracked in the state. They have been preserved as well as
 * possible: using them will still produce a correct output. However, they don't
 * actually retain any history between compression calls. The compression ratio
 * achieved will therefore be no better than compressing each chunk
 * independently.
 */
LZ4_DEPRECATED("Use LZ4_createStream() instead") LZ4LIB_API void* LZ4_create (char* inputBuffer);
LZ4_DEPRECATED("Use LZ4_createStream() instead") LZ4LIB_API int   LZ4_sizeofStreamState(void);
LZ4_DEPRECATED("Use LZ4_resetStream() instead")  LZ4LIB_API int   LZ4_resetStreamState(void* state, char* inputBuffer);
LZ4_DEPRECATED("Use LZ4_saveDict() instead")     LZ4LIB_API char* LZ4_slideInputBuffer (void* state);

/*! Obsolete streaming decoding functions (since v1.7.0) */
LZ4_DEPRECATED("use LZ4_decompress_safe_usingDict() instead") LZ4LIB_API int LZ4_decompress_safe_withPrefix64k (const char* src, char* dst, int compressedSize, int maxDstSize);
LZ4_DEPRECATED("use LZ4_decompress_fast_usingDict() instead") LZ4LIB_API int LZ4_decompress_fast_withPrefix64k (const char* src, char* dst, int originalSize);

/*! Obsolete LZ4_decompress_fast variants (since v1.9.0) :
 *  These functions used to be faster than LZ4_decompress_safe(),
 *  but this is no longer the case. They are now slower.
 *  This is because LZ4_decompress_fast() doesn't know the input size,
 *  and therefore must progress more cautiously into the input buffer to not read beyond the end of block.
 *  On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability.
 *  As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated.
 *
 *  The last remaining LZ4_decompress_fast() specificity is that
 *  it can decompress a block without knowing its compressed size.
 *  Such functionality can be achieved in a more secure manner
 *  by employing LZ4_decompress_safe_partial().
 *
 *  Parameters:
 *  originalSize : is the uncompressed size to regenerate.
 *                 `dst` must be already allocated, its size must be >= 'originalSize' bytes.
 * @return : number of bytes read from source buffer (== compressed size).
 *           The function expects to finish at block's end exactly.
 *           If the source stream is detected malformed, the function stops decoding and returns a negative result.
 *  note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer.
 *         However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds.
 *         Also, since match offsets are not validated, match reads from 'src' may underflow too.
 *         These issues never happen if input (compressed) data is correct.
 *         But they may happen if input data is invalid (error or intentional tampering).
 *         As a consequence, use these functions in trusted environments with trusted data **only**.
 */
LZ4_DEPRECATED("This function is deprecated and unsafe. Consider using LZ4_decompress_safe() instead")
LZ4LIB_API int LZ4_decompress_fast (const char* src, char* dst, int originalSize);
LZ4_DEPRECATED("This function is deprecated and unsafe. Consider using LZ4_decompress_safe_continue() instead")
LZ4LIB_API int LZ4_decompress_fast_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* src, char* dst, int originalSize);
LZ4_DEPRECATED("This function is deprecated and unsafe. Consider using LZ4_decompress_safe_usingDict() instead")
LZ4LIB_API int LZ4_decompress_fast_usingDict (const char* src, char* dst, int originalSize, const char* dictStart, int dictSize);

/*! LZ4_resetStream() :
 *  An LZ4_stream_t structure must be initialized at least once.
 *  This is done with LZ4_initStream(), or LZ4_resetStream().
 *  Consider switching to LZ4_initStream(),
 *  invoking LZ4_resetStream() will trigger deprecation warnings in the future.
 */
LZ4LIB_API void LZ4_resetStream (LZ4_stream_t* streamPtr);


#endif /* LZ4_H_98237428734687 */


#if defined (__cplusplus)
}
#endif

     
//
// END FILE: lz4.h
// ----------------------------------------------------------------------------



// ----------------------------------------------------------------------------
// BEGIN FILE: tls.h
//


/* $OpenBSD: tls.h,v 1.62 2022/03/24 15:56:34 tb Exp $ */
/*
 * Copyright (c) 2014 Joel Sing <jsing@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef HEADER_TLS_H
#define HEADER_TLS_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#ifndef LIBRESSL_INTERNAL
#include <basetsd.h>
typedef SSIZE_T ssize_t;
#endif
#endif

#include <sys/types.h>

#include <stddef.h>
#include <stdint.h>

#define TLS_API	20200120

#define TLS_PROTOCOL_TLSv1_0	(1 << 1)
#define TLS_PROTOCOL_TLSv1_1	(1 << 2)
#define TLS_PROTOCOL_TLSv1_2	(1 << 3)
#define TLS_PROTOCOL_TLSv1_3	(1 << 4)

#define TLS_PROTOCOL_TLSv1 \
	(TLS_PROTOCOL_TLSv1_0|TLS_PROTOCOL_TLSv1_1|\
	 TLS_PROTOCOL_TLSv1_2|TLS_PROTOCOL_TLSv1_3)

#define TLS_PROTOCOLS_ALL TLS_PROTOCOL_TLSv1
#define TLS_PROTOCOLS_DEFAULT (TLS_PROTOCOL_TLSv1_2|TLS_PROTOCOL_TLSv1_3)

#define TLS_WANT_POLLIN		-2
#define TLS_WANT_POLLOUT	-3

/* RFC 6960 Section 2.3 */
#define TLS_OCSP_RESPONSE_SUCCESSFUL		0
#define TLS_OCSP_RESPONSE_MALFORMED		1
#define TLS_OCSP_RESPONSE_INTERNALERROR		2
#define TLS_OCSP_RESPONSE_TRYLATER		3
#define TLS_OCSP_RESPONSE_SIGREQUIRED		4
#define TLS_OCSP_RESPONSE_UNAUTHORIZED		5

/* RFC 6960 Section 2.2 */
#define TLS_OCSP_CERT_GOOD			0
#define TLS_OCSP_CERT_REVOKED			1
#define TLS_OCSP_CERT_UNKNOWN			2

/* RFC 5280 Section 5.3.1 */
#define TLS_CRL_REASON_UNSPECIFIED		0
#define TLS_CRL_REASON_KEY_COMPROMISE		1
#define TLS_CRL_REASON_CA_COMPROMISE		2
#define TLS_CRL_REASON_AFFILIATION_CHANGED	3
#define TLS_CRL_REASON_SUPERSEDED		4
#define TLS_CRL_REASON_CESSATION_OF_OPERATION	5
#define TLS_CRL_REASON_CERTIFICATE_HOLD		6
#define TLS_CRL_REASON_REMOVE_FROM_CRL		8
#define TLS_CRL_REASON_PRIVILEGE_WITHDRAWN	9
#define TLS_CRL_REASON_AA_COMPROMISE		10

#define TLS_MAX_SESSION_ID_LENGTH		32
#define TLS_TICKET_KEY_SIZE			48

struct tls;
struct tls_config;

typedef ssize_t (*tls_read_cb)(struct tls *_ctx, void *_buf, size_t _buflen,
    void *_cb_arg);
typedef ssize_t (*tls_write_cb)(struct tls *_ctx, const void *_buf,
    size_t _buflen, void *_cb_arg);

int tls_init(void);

const char *tls_config_error(struct tls_config *_config);
const char *tls_error(struct tls *_ctx);

struct tls_config *tls_config_new(void);
void tls_config_free(struct tls_config *_config);

const char *tls_default_ca_cert_file(void);

int tls_config_add_keypair_file(struct tls_config *_config,
    const char *_cert_file, const char *_key_file);
int tls_config_add_keypair_mem(struct tls_config *_config, const uint8_t *_cert,
    size_t _cert_len, const uint8_t *_key, size_t _key_len);
int tls_config_add_keypair_ocsp_file(struct tls_config *_config,
    const char *_cert_file, const char *_key_file,
    const char *_ocsp_staple_file);
int tls_config_add_keypair_ocsp_mem(struct tls_config *_config, const uint8_t *_cert,
    size_t _cert_len, const uint8_t *_key, size_t _key_len,
    const uint8_t *_staple, size_t _staple_len);
int tls_config_set_alpn(struct tls_config *_config, const char *_alpn);
int tls_config_set_ca_file(struct tls_config *_config, const char *_ca_file);
int tls_config_set_ca_path(struct tls_config *_config, const char *_ca_path);
int tls_config_set_ca_mem(struct tls_config *_config, const uint8_t *_ca,
    size_t _len);
int tls_config_set_cert_file(struct tls_config *_config,
    const char *_cert_file);
int tls_config_set_cert_mem(struct tls_config *_config, const uint8_t *_cert,
    size_t _len);
int tls_config_set_ciphers(struct tls_config *_config, const char *_ciphers);
int tls_config_set_crl_file(struct tls_config *_config, const char *_crl_file);
int tls_config_set_crl_mem(struct tls_config *_config, const uint8_t *_crl,
    size_t _len);
int tls_config_set_dheparams(struct tls_config *_config, const char *_params);
int tls_config_set_ecdhecurve(struct tls_config *_config, const char *_curve);
int tls_config_set_ecdhecurves(struct tls_config *_config, const char *_curves);
int tls_config_set_key_file(struct tls_config *_config, const char *_key_file);
int tls_config_set_key_mem(struct tls_config *_config, const uint8_t *_key,
    size_t _len);
int tls_config_set_keypair_file(struct tls_config *_config,
    const char *_cert_file, const char *_key_file);
int tls_config_set_keypair_mem(struct tls_config *_config, const uint8_t *_cert,
    size_t _cert_len, const uint8_t *_key, size_t _key_len);
int tls_config_set_keypair_ocsp_file(struct tls_config *_config,
    const char *_cert_file, const char *_key_file, const char *_staple_file);
int tls_config_set_keypair_ocsp_mem(struct tls_config *_config, const uint8_t *_cert,
    size_t _cert_len, const uint8_t *_key, size_t _key_len,
    const uint8_t *_staple, size_t staple_len);
int tls_config_set_ocsp_staple_mem(struct tls_config *_config,
    const uint8_t *_staple, size_t _len);
int tls_config_set_ocsp_staple_file(struct tls_config *_config,
    const char *_staple_file);
int tls_config_set_protocols(struct tls_config *_config, uint32_t _protocols);
int tls_config_set_session_fd(struct tls_config *_config, int _session_fd);
int tls_config_set_verify_depth(struct tls_config *_config, int _verify_depth);

void tls_config_prefer_ciphers_client(struct tls_config *_config);
void tls_config_prefer_ciphers_server(struct tls_config *_config);

void tls_config_insecure_noverifycert(struct tls_config *_config);
void tls_config_insecure_noverifyname(struct tls_config *_config);
void tls_config_insecure_noverifytime(struct tls_config *_config);
void tls_config_verify(struct tls_config *_config);

void tls_config_ocsp_require_stapling(struct tls_config *_config);
void tls_config_verify_client(struct tls_config *_config);
void tls_config_verify_client_optional(struct tls_config *_config);

void tls_config_clear_keys(struct tls_config *_config);
int tls_config_parse_protocols(uint32_t *_protocols, const char *_protostr);

int tls_config_set_session_id(struct tls_config *_config,
    const unsigned char *_session_id, size_t _len);
int tls_config_set_session_lifetime(struct tls_config *_config, int _lifetime);
int tls_config_add_ticket_key(struct tls_config *_config, uint32_t _keyrev,
    unsigned char *_key, size_t _keylen);

struct tls *tls_client(void);
struct tls *tls_server(void);
int tls_configure(struct tls *_ctx, struct tls_config *_config);
void tls_reset(struct tls *_ctx);
void tls_free(struct tls *_ctx);

int tls_accept_fds(struct tls *_ctx, struct tls **_cctx, int _fd_read,
    int _fd_write);
int tls_accept_socket(struct tls *_ctx, struct tls **_cctx, int _socket);
int tls_accept_cbs(struct tls *_ctx, struct tls **_cctx,
    tls_read_cb _read_cb, tls_write_cb _write_cb, void *_cb_arg);
int tls_connect(struct tls *_ctx, const char *_host, const char *_port);
int tls_connect_fds(struct tls *_ctx, int _fd_read, int _fd_write,
    const char *_servername);
int tls_connect_servername(struct tls *_ctx, const char *_host,
    const char *_port, const char *_servername);
int tls_connect_socket(struct tls *_ctx, int _s, const char *_servername);
int tls_connect_cbs(struct tls *_ctx, tls_read_cb _read_cb,
    tls_write_cb _write_cb, void *_cb_arg, const char *_servername);
int tls_handshake(struct tls *_ctx);
ssize_t tls_read(struct tls *_ctx, void *_buf, size_t _buflen);
ssize_t tls_write(struct tls *_ctx, const void *_buf, size_t _buflen);
int tls_close(struct tls *_ctx);

int tls_peer_cert_provided(struct tls *_ctx);
int tls_peer_cert_contains_name(struct tls *_ctx, const char *_name);

const char *tls_peer_cert_hash(struct tls *_ctx);
const char *tls_peer_cert_issuer(struct tls *_ctx);
const char *tls_peer_cert_subject(struct tls *_ctx);
time_t	tls_peer_cert_notbefore(struct tls *_ctx);
time_t	tls_peer_cert_notafter(struct tls *_ctx);
const uint8_t *tls_peer_cert_chain_pem(struct tls *_ctx, size_t *_len);

const char *tls_conn_alpn_selected(struct tls *_ctx);
const char *tls_conn_cipher(struct tls *_ctx);
int tls_conn_cipher_strength(struct tls *_ctx);
const char *tls_conn_servername(struct tls *_ctx);
int tls_conn_session_resumed(struct tls *_ctx);
const char *tls_conn_version(struct tls *_ctx);

uint8_t *tls_load_file(const char *_file, size_t *_len, char *_password);
void tls_unload_file(uint8_t *_buf, size_t len);

int tls_ocsp_process_response(struct tls *_ctx, const unsigned char *_response,
    size_t _size);
int tls_peer_ocsp_cert_status(struct tls *_ctx);
int tls_peer_ocsp_crl_reason(struct tls *_ctx);
time_t tls_peer_ocsp_next_update(struct tls *_ctx);
int tls_peer_ocsp_response_status(struct tls *_ctx);
const char *tls_peer_ocsp_result(struct tls *_ctx);
time_t tls_peer_ocsp_revocation_time(struct tls *_ctx);
time_t tls_peer_ocsp_this_update(struct tls *_ctx);
const char *tls_peer_ocsp_url(struct tls *_ctx);

#ifdef __cplusplus
}
#endif

#endif /* HEADER_TLS_H */

     
//
// END FILE: tls.h
// ----------------------------------------------------------------------------



// ----------------------------------------------------------------------------
// BEGIN FILE: sqcloud.h
//


//
//  sqcloud.h
//
//  Created by Marco Bambini on 08/02/21.
//

#ifndef __SQCLOUD_CLI__
#define __SQCLOUD_CLI__

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SQCLOUD_SDK_VERSION         "0.9.5"
#define SQCLOUD_SDK_VERSION_NUM     0x000905
#define SQCLOUD_DEFAULT_PORT        8860
#define SQCLOUD_DEFAULT_TIMEOUT     12
#define SQCLOUD_DEFAULT_UPLOAD_SIZE 512*1024

#define SQCLOUD_IPv4                0
#define SQCLOUD_IPv6                1
#define SQCLOUD_IPANY               2

#ifndef BITCHECK
#define BITCHECK(byte,nbit)         ((byte) &   (1<<(nbit)))
#endif

// defined in https://github.com/sqlitecloud/sdk/blob/master/PROTOCOL.md
// was int const but apparently gcc doesn't like them in case statements
#define CMD_STRING                  '+'
#define CMD_ZEROSTRING              '!'
#define CMD_ERROR                   '-'
#define CMD_INT                     ':'
#define CMD_FLOAT                   ','
#define CMD_ROWSET                  '*'
#define CMD_ROWSET_CHUNK            '/'
#define CMD_JSON                    '#'
#define CMD_RAWJSON                 '{'
#define CMD_NULL                    '_'
#define CMD_BLOB                    '$'
#define CMD_COMPRESSED              '%'
#define CMD_PUBSUB                  '|'
#define CMD_COMMAND                 '^'
#define CMD_RECONNECT               '@'
#define CMD_ARRAY                   '='

// MARK: -

// opaque datatypes
typedef struct SQCloudConnection            SQCloudConnection;
typedef struct SQCloudResult                SQCloudResult;
typedef struct SQCloudVM                    SQCloudVM;
typedef struct SQCloudBlob                  SQCloudBlob;
typedef struct SQCloudBackup                SQCloudBackup;
typedef void (*SQCloudPubSubCB)             (SQCloudConnection *connection, SQCloudResult *result, void *data);
typedef int (*config_cb)                    (char *buffer, int len, void *data);
typedef int64_t (*SQCloudBackupOnDataCB)    (SQCloudBackup *backup, const char *data, uint32_t len, int page_size, int page_counter);

// configuration struct to be passed to the connect function
typedef struct SQCloudConfigStruct {
    const char      *username;              // connection username
    const char      *password;              // connection password
    const char      *database;              // database to use during connection
    int             timeout;                // connection timeout parameter
    int             family;                 // can be: SQCLOUD_IPv4, SQCLOUD_IPv6 or SQCLOUD_IPANY
    bool            compression;            // compression flag
    bool            sqlite_mode;            // special sqlite compatibility mode
    bool            zero_text;              // flag to tell the server to zero-terminate strings
    bool            password_hashed;        // private flag
    bool            nonlinearizable;        // flag to request for immediate responses from the server node without waiting for linerizability guarantees
    bool            db_memory;              // flag to force the database to be in-memory
    bool            no_blob;                // flag to tell the server to not send BLOB columns
    bool            db_create;              // flag to force the creation of the database (if it does not exist)
    int             max_data;               // value to tell the server to not send columns with more than max_data bytes
    int             max_rows;               // value to control rowset chunks based on the number of rows
    int             max_rowset;             // value to control the maximum allowed size for a rowset
    #ifndef SQLITECLOUD_DISABLE_TSL
    const char      *tls_root_certificate;
    const char      *tls_certificate;
    const char      *tls_certificate_key;
    bool            insecure;               // flag to disable TLS
    #endif
    config_cb       callback;               // reserved callback for internal usage
    void            *data;                  // reserved callback data parameter
} SQCloudConfig;

// convenient struct to be used in SQCloudDownloadDatabase
typedef struct {
    void            *ptr;
    int             fd;
} SQCloudData;

typedef enum {
    RESULT_OK,
    RESULT_ERROR,
    RESULT_STRING,
    RESULT_INTEGER,
    RESULT_FLOAT,
    RESULT_ROWSET,
    RESULT_ARRAY,
    RESULT_NULL,
    RESULT_JSON,
    RESULT_BLOB
} SQCLOUD_RESULT_TYPE;

typedef enum {
    VALUE_INTEGER = 1,
    VALUE_FLOAT = 2,
    VALUE_TEXT = 3,
    VALUE_BLOB = 4,
    VALUE_NULL = 5
} SQCLOUD_VALUE_TYPE;

typedef enum {
    SQCLOUD_ROWSET_FLAG_STANDARD = 0,            // rowset contains standard header and data
    SQCLOUD_ROWSET_FLAG_METACOLS = 1,            // rowset contains additional columns metadata
    SQCLOUD_ROWSET_FLAG_HEADONLY = 2,            // rowset is header only
    SQCLOUD_ROWSET_FLAG_DATAONLY = 3,            // rowset is data only
    SQCLOUD_ROWSET_FLAG_METAVM = 4               // rowset contains VM metadata info
} SQCLOUD_ROWSET_FLAG;

typedef enum {
    ARRAY_TYPE_SQLITE_EXEC = 10,            // used in SQLITE_MODE only when a write statement is executed (instead of the OK reply)
    ARRAY_TYPE_DB_STATUS = 11,
    ARRAY_TYPE_METADATA = 12,
    
    ARRAY_TYPE_VM_STEP = 20,                // used in VM_STEP (when SQLITE_DONE is returned)
    ARRAY_TYPE_VM_COMPILE = 21,             // used in VM_PREPARE
    ARRAY_TYPE_VM_STEP_ONE = 22,            // unused in this version (will be used to step in a server-side rowset)
    ARRAY_TYPE_VM_SQL = 23,
    ARRAY_TYPE_VM_STATUS = 24,
    ARRAY_TYPE_VM_LIST = 25,
        
    ARRAY_TYPE_BACKUP_INIT = 40,            // used in BACKUP_INIT
    ARRAY_TYPE_BACKUP_STEP = 41,            // used in backupWrite (VFS)
    ARRAY_TYPE_BACKUP_END = 42,             // used in backupClose (VFS)
    
    ARRAY_TYPE_SQLITE_STATUS = 50           // used in sqlite_status
} SQCLOUD_ARRAY_TYPE;

typedef enum {
    INTERNAL_ERRCODE_NONE = 0,
    INTERNAL_ERRCODE_GENERIC = 100000,
    INTERNAL_ERRCODE_PUBSUB = 100001,
    INTERNAL_ERRCODE_TLS = 100002,
    INTERNAL_ERRCODE_URL = 100003,
    INTERNAL_ERRCODE_MEMORY = 100004,
    INTERNAL_ERRCODE_NETWORK = 100005,
    INTERNAL_ERRCODE_FORMAT = 100006,
    INTERNAL_ERRCODE_INDEX = 100007
} SQCLOUD_INTERNAL_ERRCODE;

// from SQLiteCloud
typedef enum {
    CLOUD_ERRCODE_MEM = 10000,
    CLOUD_ERRCODE_NOTFOUND = 10001,
    CLOUD_ERRCODE_COMMAND = 10002,
    CLOUD_ERRCODE_INTERNAL = 10003,
    CLOUD_ERRCODE_AUTH = 10004,
    CLOUD_ERRCODE_GENERIC = 10005,
    CLOUD_ERRCODE_RAFT = 10006
} SQCLOUD_CLOUD_ERRCODE;

// MARK: - General -
SQCloudConnection *SQCloudConnect (const char *hostname, int port, SQCloudConfig *config);
SQCloudConnection *SQCloudConnectWithString (const char *s, SQCloudConfig *config);
SQCloudResult *SQCloudExec (SQCloudConnection *connection, const char *command);
const char *SQCloudUUID (SQCloudConnection *connection);
void SQCloudDisconnect (SQCloudConnection *connection);

// MARK: - Pub/Sub -
void SQCloudSetPubSubCallback (SQCloudConnection *connection, SQCloudPubSubCB callback, void *data);
SQCloudResult *SQCloudSetPubSubOnly (SQCloudConnection *connection);

// MARK: - Error -
bool SQCloudIsError (SQCloudConnection *connection);
bool SQCloudIsSQLiteError (SQCloudConnection *connection);
int SQCloudErrorCode (SQCloudConnection *connection);
int SQCloudExtendedErrorCode (SQCloudConnection *connection);
int SQCloudErrorOffset (SQCloudConnection *connection);
const char *SQCloudErrorMsg (SQCloudConnection *connection);
void SQCloudErrorReset (SQCloudConnection *connection);
void SQCloudErrorSetCode (SQCloudConnection *connection, int errcode);
void SQCloudErrorSetMsg (SQCloudConnection *connection, const char *format, ...);

// MARK: - Result -
SQCLOUD_RESULT_TYPE SQCloudResultType (SQCloudResult *result);
uint32_t SQCloudResultLen (SQCloudResult *result);
char *SQCloudResultBuffer (SQCloudResult *result);
int32_t SQCloudResultInt32 (SQCloudResult *result);
int64_t SQCloudResultInt64 (SQCloudResult *result);
double SQCloudResultDouble (SQCloudResult *result);
float SQCloudResultFloat (SQCloudResult *result);
void SQCloudResultFree (SQCloudResult *result);
bool SQCloudResultIsOK (SQCloudResult *result);
bool SQCloudResultIsError (SQCloudResult *result);
void SQCloudResultDump (SQCloudConnection *connection, SQCloudResult *result);

// MARK: - Rowset -
SQCLOUD_VALUE_TYPE SQCloudRowsetValueType (SQCloudResult *result, uint32_t row, uint32_t col);
uint32_t SQCloudRowsetRowsMaxColumnLength (SQCloudResult *result, uint32_t col);
char *SQCloudRowsetColumnName (SQCloudResult *result, uint32_t col, uint32_t *len);
char *SQCloudRowsetColumnDeclType (SQCloudResult *result, uint32_t col, uint32_t *len);
char *SQCloudRowsetColumnDBName (SQCloudResult *result, uint32_t col, uint32_t *len);
char *SQCloudRowsetColumnTblName (SQCloudResult *result, uint32_t col, uint32_t *len);
char *SQCloudRowsetColumnOrigName (SQCloudResult *result, uint32_t col, uint32_t *len);
uint32_t SQCloudRowsetRows (SQCloudResult *result);
uint32_t SQCloudRowsetCols (SQCloudResult *result);
uint32_t SQCloudRowsetMaxLen (SQCloudResult *result);
char *SQCloudRowsetValue (SQCloudResult *result, uint32_t row, uint32_t col, uint32_t *len);
uint32_t SQCloudRowsetValueLen (SQCloudResult *result, uint32_t row, uint32_t col);
int32_t SQCloudRowsetInt32Value (SQCloudResult *result, uint32_t row, uint32_t col);
int64_t SQCloudRowsetInt64Value (SQCloudResult *result, uint32_t row, uint32_t col);
float SQCloudRowsetFloatValue (SQCloudResult *result, uint32_t row, uint32_t col);
double SQCloudRowsetDoubleValue (SQCloudResult *result, uint32_t row, uint32_t col);
void SQCloudRowsetDump (SQCloudResult *result, uint32_t maxline, bool quiet);
bool SQCloudRowsetCompare (SQCloudResult *result1, SQCloudResult *result2);

// MARK: - Array -
SQCloudResult *SQCloudExecArray (SQCloudConnection *connection, const char *command, const char **values, uint32_t len[], SQCLOUD_VALUE_TYPE types[], uint32_t n);
SQCLOUD_VALUE_TYPE SQCloudArrayValueType (SQCloudResult *result, uint32_t index);
uint32_t SQCloudArrayCount (SQCloudResult *result);
char *SQCloudArrayValue (SQCloudResult *result, uint32_t index, uint32_t *len);
int32_t SQCloudArrayInt32Value (SQCloudResult *result, uint32_t index);
int64_t SQCloudArrayInt64Value (SQCloudResult *result, uint32_t index);
float SQCloudArrayFloatValue (SQCloudResult *result, uint32_t index);
double SQCloudArrayDoubleValue (SQCloudResult *result, uint32_t index);
void SQCloudArrayDump (SQCloudResult *result);

// MARK: - Upload/Download -
bool SQCloudDownloadDatabase (SQCloudConnection *connection, const char *dbname, void *xdata,
                              int (*xCallback)(void *xdata, const void *buffer, uint32_t blen, int64_t ntot, int64_t nprogress));
bool SQCloudUploadDatabase (SQCloudConnection *connection, const char *dbname, const char *key, void *xdata, int64_t dbsize, int (*xCallback)(void *xdata, void *buffer, uint32_t *blen, int64_t ntot, int64_t nprogress));

// MARK: - VM -
SQCloudVM *SQCloudVMCompile (SQCloudConnection *connection, const char *sql, int32_t len, const char **tail);
SQCLOUD_RESULT_TYPE SQCloudVMStep (SQCloudVM *vm);
SQCloudResult *SQCloudVMResult (SQCloudVM *vm);
bool SQCloudVMClose (SQCloudVM *vm);
const char *SQCloudVMErrorMsg (SQCloudVM *vm);
int SQCloudVMErrorCode (SQCloudVM *vm);
int SQCloudVMIndex (SQCloudVM *vm);
bool SQCloudVMIsReadOnly (SQCloudVM *vm);
int SQCloudVMIsExplain (SQCloudVM *vm);
bool SQCloudVMIsFinalized (SQCloudVM *vm);
int SQCloudVMBindParameterCount (SQCloudVM *vm);
int SQCloudVMBindParameterIndex (SQCloudVM *vm, const char *name);
const char *SQCloudVMBindParameterName (SQCloudVM *vm, int index);
int SQCloudVMColumnCount (SQCloudVM *vm);
bool SQCloudVMBindDouble (SQCloudVM *vm, int index, double value);
bool SQCloudVMBindInt (SQCloudVM *vm, int index, int value);
bool SQCloudVMBindInt64 (SQCloudVM *vm, int index, int64_t value);
bool SQCloudVMBindNull (SQCloudVM *vm, int index);
bool SQCloudVMBindText (SQCloudVM *vm, int index, const char *value, int32_t len);
bool SQCloudVMBindBlob (SQCloudVM *vm, int index, void *value, int32_t len);
bool SQCloudVMBindZeroBlob (SQCloudVM *vm, int index, int64_t len);
const void *SQCloudVMColumnBlob (SQCloudVM *vm, int index, uint32_t *len);
const char *SQCloudVMColumnText (SQCloudVM *vm, int index, uint32_t *len);
double SQCloudVMColumnDouble (SQCloudVM *vm, int index);
int SQCloudVMColumnInt32 (SQCloudVM *vm, int index);
int64_t SQCloudVMColumnInt64 (SQCloudVM *vm, int index);
int64_t SQCloudVMColumnLen (SQCloudVM *vm, int index);
SQCLOUD_VALUE_TYPE SQCloudVMColumnType (SQCloudVM *vm, int index);
int64_t SQCloudVMLastRowID (SQCloudVM *vm);
int64_t SQCloudVMChanges (SQCloudVM *vm);
int64_t SQCloudVMTotalChanges (SQCloudVM *vm);

// MARK: - BLOB -
SQCloudBlob *SQCloudBlobOpen (SQCloudConnection *connection, const char *dbname, const char *tablename, const char *colname, int64_t rowid, bool wrflag);
bool SQCloudBlobReOpen (SQCloudBlob *blob, int64_t rowid);
bool SQCloudBlobClose (SQCloudBlob *blob);
int SQCloudBlobBytes (SQCloudBlob *blob);
int SQCloudBlobRead (SQCloudBlob *blob, void *buffer, int blen, int offset);
int SQCloudBlobWrite (SQCloudBlob *blob, const void *buffer, int blen, int offset);

// MARK: - Backup -
SQCloudBackup *SQCloudBackupInit (SQCloudConnection *connection, const char *dest_name, const char *source_name);
int SQCloudBackupStep (SQCloudBackup *backup, int n, SQCloudBackupOnDataCB on_data);
bool SQCloudBackupFinish (SQCloudBackup *backup);
int SQCloudBackupPageRemaining (SQCloudBackup *backup);
int SQCloudBackupPageCount (SQCloudBackup *backup);
void *SQCloudBackupSetData (SQCloudBackup *backup, void *data);
void *SQCloudBackupData (SQCloudBackup *backup);
SQCloudConnection *SQCloudBackupConnection (SQCloudBackup *backup);

// MARK: - Reserved -


#ifdef __cplusplus
}
#endif

#endif

     
//
// END FILE: sqcloud.h
// ----------------------------------------------------------------------------



// ----------------------------------------------------------------------------
// BEGIN FILE: sqlite3_internals.h
//


//
//  sqlite3_internals.h
//  sqlite3cloud_test
//
//  Created by Marco Bambini on 20/10/22.
//

#ifndef _SQLITE3_INTERNALS_
#define _SQLITE3_INTERNALS_

#define SQLITE_ASCII                            1
#define SQLITE_OMIT_AUTOINIT                    1
#define SQLITE_NOINLINE
#define SQLITE_PRIVATE                          static
#define SQLITE3CLOUD_ERRSTR_DEFINED             1

#define SQLITE_LIMIT_LENGTH                     0
#define SQLITE_LIMIT_SQL_LENGTH                 1
#define SQLITE_LIMIT_COLUMN                     2
#define SQLITE_LIMIT_EXPR_DEPTH                 3
#define SQLITE_LIMIT_COMPOUND_SELECT            4
#define SQLITE_LIMIT_VDBE_OP                    5
#define SQLITE_LIMIT_FUNCTION_ARG               6
#define SQLITE_LIMIT_ATTACHED                   7
#define SQLITE_LIMIT_LIKE_PATTERN_LENGTH        8
#define SQLITE_LIMIT_VARIABLE_NUMBER            9
#define SQLITE_LIMIT_TRIGGER_DEPTH              10
#define SQLITE_LIMIT_WORKER_THREADS             11
#define SQLITE_N_LIMIT                          (SQLITE_LIMIT_WORKER_THREADS+1)

/*
** Integers of known sizes.  These typedefs might change for architectures
** where the sizes very.  Preprocessor macros are available so that the
** types can be conveniently redefined at compile-type.  Like this:
**
**         cc '-DUINTPTR_TYPE=long long int' ...
*/
#ifndef UINT32_TYPE
# ifdef HAVE_UINT32_T
#  define UINT32_TYPE uint32_t
# else
#  define UINT32_TYPE unsigned int
# endif
#endif
#ifndef UINT16_TYPE
# ifdef HAVE_UINT16_T
#  define UINT16_TYPE uint16_t
# else
#  define UINT16_TYPE unsigned short int
# endif
#endif
#ifndef INT16_TYPE
# ifdef HAVE_INT16_T
#  define INT16_TYPE int16_t
# else
#  define INT16_TYPE short int
# endif
#endif
#ifndef UINT8_TYPE
# ifdef HAVE_UINT8_T
#  define UINT8_TYPE uint8_t
# else
#  define UINT8_TYPE unsigned char
# endif
#endif
#ifndef INT8_TYPE
# ifdef HAVE_INT8_T
#  define INT8_TYPE int8_t
# else
#  define INT8_TYPE signed char
# endif
#endif
#ifndef LONGDOUBLE_TYPE
# define LONGDOUBLE_TYPE long double
#endif

typedef sqlite_int64 i64;
typedef sqlite_uint64 u64;
typedef UINT32_TYPE u32;           /* 4-byte unsigned integer */
typedef UINT16_TYPE u16;           /* 2-byte unsigned integer */
typedef INT16_TYPE i16;            /* 2-byte signed integer */
typedef UINT8_TYPE u8;             /* 1-byte unsigned integer */
typedef INT8_TYPE i8;              /* 1-byte signed integer */
typedef int (*trace_callback)(unsigned,void*,void*,void*);

#ifdef SQLITE_RTREE_INT_ONLY
    typedef sqlite3_int64 RtreeDValue;
    typedef int RtreeValue;
    #define RTREE_ZERO 0
#else
    typedef double RtreeDValue;
    typedef float RtreeValue;
    #define RTREE_ZERO 0.0
#endif

/*
** Include standard header files as necessary
*/
#ifdef HAVE_STDINT_H
#include <stdint.h>
#endif
#ifdef HAVE_INTTYPES_H
#include <inttypes.h>
#endif

/*
** The following macros are used to cast pointers to integers and
** integers to pointers.  The way you do this varies from one compiler
** to the next, so we have developed the following set of #if statements
** to generate appropriate macros for a wide range of compilers.
**
** The correct "ANSI" way to do this is to use the intptr_t type.
** Unfortunately, that typedef is not available on all compilers, or
** if it is available, it requires an #include of specific headers
** that vary from one machine to the next.
**
** Ticket #3860:  The llvm-gcc-4.2 compiler from Apple chokes on
** the ((void*)&((char*)0)[X]) construct.  But MSVC chokes on ((void*)(X)).
** So we have to define the macros in different ways depending on the
** compiler.
*/
#if defined(HAVE_STDINT_H)   /* Use this case if we have ANSI headers */
# define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))
# define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))
#elif defined(__PTRDIFF_TYPE__)  /* This case should work for GCC */
# define SQLITE_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))
# define SQLITE_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))
#elif !defined(__GNUC__)       /* Works for compilers other than LLVM */
# define SQLITE_INT_TO_PTR(X)  ((void*)&((char*)0)[X])
# define SQLITE_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))
#else                          /* Generates a warning - but it always works */
# define SQLITE_INT_TO_PTR(X)  ((void*)(X))
# define SQLITE_PTR_TO_INT(X)  ((int)(X))
#endif

#define ALWAYS(X)               (X)
#define ArraySize(X)            ((int)(sizeof(X)/sizeof(X[0])))

#define PRINT_LINE(...)         printf(__VA_ARGS__);printf("\n");fflush(stdout)

// from sqlite3.c
typedef struct TabResult {
  char **azResult;   /* Accumulated output */
  char *zErrMsg;     /* Error message text, if an error occurs */
  u32 nAlloc;        /* Slots allocated for azResult[] */
  u32 nRow;          /* Number of rows in the result */
  u32 nColumn;       /* Number of columns in the result */
  u32 nData;         /* Slots used in azResult[].  (nRow+1)*nColumn */
  int rc;            /* Return code from sqlite3_exec() */
} TabResult;

// MARK: - SQLite3 Strings -

typedef struct sqlite3_str {
    sqlite3 *db;         /* Optional database for lookaside.  Can be NULL */
    char *zText;         /* The string collected so far */
    u32  nAlloc;         /* Amount of space allocated in zText */
    u32  mxAlloc;        /* Maximum allowed allocation.  0 for no malloc usage */
    u32  nChar;          /* Length of the string so far */
    u8   accError;       /* SQLITE_NOMEM or SQLITE_TOOBIG */
    u8   printfFlags;    /* SQLITE_PRINTF flags below */
} sqlite3_str;

typedef struct sqlite3_str StrAccum; /* Internal alias for sqlite3_str */

#define SQLITE_PRINTF_INTERNAL 0x01  /* Internal-use-only converters allowed */
#define SQLITE_PRINTF_SQLFUNC  0x02  /* SQL function arguments to VXPrintf */
#define SQLITE_PRINTF_MALLOCED 0x04  /* True if xText is allocated space */

#define isMalloced(X)  (((X)->printfFlags & SQLITE_PRINTF_MALLOCED)!=0)

/*
** Conversion types fall into various categories as defined by the
** following enumeration.
*/
#define etRADIX       0 /* non-decimal integer types.  %x %o */
#define etFLOAT       1 /* Floating point.  %f */
#define etEXP         2 /* Exponentional notation. %e and %E */
#define etGENERIC     3 /* Floating or exponential, depending on exponent. %g */
#define etSIZE        4 /* Return number of characters processed so far. %n */
#define etSTRING      5 /* Strings. %s */
#define etDYNSTRING   6 /* Dynamically allocated strings. %z */
#define etPERCENT     7 /* Percent symbol. %% */
#define etCHARX       8 /* Characters. %c */
/* The rest are extensions, not normally found in printf() */
#define etSQLESCAPE   9 /* Strings with '\'' doubled.  %q */
#define etSQLESCAPE2 10 /* Strings with '\'' doubled and enclosed in '',
                          NULL pointers replaced by SQL NULL.  %Q */
#define etTOKEN      11 /* a pointer to a Token structure */
#define etSRCITEM    12 /* a pointer to a SrcItem */
#define etPOINTER    13 /* The %p conversion */
#define etSQLESCAPE3 14 /* %w -> Strings with '\"' doubled */
#define etORDINAL    15 /* %r -> 1st, 2nd, 3rd, 4th, etc.  English only */
#define etDECIMAL    16 /* %d or %u, but not %x, %o */

#define etINVALID    17 /* Any unrecognized conversion type */

/*
** An "etByte" is an 8-bit unsigned value.
*/
typedef unsigned char etByte;

/*
** Each builtin conversion character (ex: the 'd' in "%d") is described
** by an instance of the following structure
*/
typedef struct et_info {   /* Information about each format field */
  char fmttype;            /* The format field code letter */
  etByte base;             /* The base for radix conversion */
  etByte flags;            /* One or more of FLAG_ constants below */
  etByte type;             /* Conversion paradigm */
  etByte charset;          /* Offset into aDigits[] of the digits string */
  etByte prefix;           /* Offset into aPrefix[] of the prefix string */
} et_info;

/*
** Allowed values for et_info.flags
*/
#define FLAG_SIGNED    1     /* True if the value to convert is signed */
#define FLAG_STRING    4     /* Allow infinite precision */

/*
** The following table is searched linearly, so it is good to put the
** most frequently used conversion types first.
*/
static const char aDigits[] = "0123456789ABCDEF0123456789abcdef";
static const char aPrefix[] = "-x0\000X0";
static const et_info fmtinfo[] = {
  {  'd', 10, 1, etDECIMAL,    0,  0 },
  {  's',  0, 4, etSTRING,     0,  0 },
  {  'g',  0, 1, etGENERIC,    30, 0 },
  {  'z',  0, 4, etDYNSTRING,  0,  0 },
  {  'q',  0, 4, etSQLESCAPE,  0,  0 },
  {  'Q',  0, 4, etSQLESCAPE2, 0,  0 },
  {  'w',  0, 4, etSQLESCAPE3, 0,  0 },
  {  'c',  0, 0, etCHARX,      0,  0 },
  {  'o',  8, 0, etRADIX,      0,  2 },
  {  'u', 10, 0, etDECIMAL,    0,  0 },
  {  'x', 16, 0, etRADIX,      16, 1 },
  {  'X', 16, 0, etRADIX,      0,  4 },
#ifndef SQLITE_OMIT_FLOATING_POINT
  {  'f',  0, 1, etFLOAT,      0,  0 },
  {  'e',  0, 1, etEXP,        30, 0 },
  {  'E',  0, 1, etEXP,        14, 0 },
  {  'G',  0, 1, etGENERIC,    14, 0 },
#endif
  {  'i', 10, 1, etDECIMAL,    0,  0 },
  {  'n',  0, 0, etSIZE,       0,  0 },
  {  '%',  0, 0, etPERCENT,    0,  0 },
  {  'p', 16, 0, etPOINTER,    0,  1 },

  /* All the rest are undocumented and are for internal use only */
  {  'T',  0, 0, etTOKEN,      0,  0 },
  {  'S',  0, 0, etSRCITEM,    0,  0 },
  {  'r', 10, 1, etORDINAL,    0,  0 },
};

/* Notes:
**
**    %S    Takes a pointer to SrcItem.  Shows name or database.name
**    %!S   Like %S but prefer the zName over the zAlias
*/

/* Floating point constants used for rounding */
static const double arRound[] = {
  5.0e-01, 5.0e-02, 5.0e-03, 5.0e-04, 5.0e-05,
  5.0e-06, 5.0e-07, 5.0e-08, 5.0e-09, 5.0e-10,
};

/*
** An instance of the following structure holds information about SQL
** functions arguments that are the parameters to the printf() function.
*/
typedef struct PrintfArguments {
  int nArg;                /* Total number of arguments */
  int nUsed;               /* Number of arguments used so far */
  sqlite3_value **apArg;   /* The argument values */
} PrintfArguments;

//
#if SQLITE3CLOUD_DEBUG
#define DEBUG_WRITE(...)                PRINT_LINE(__VA_ARGS__)
#else
#define DEBUG_WRITE(...)
#endif

#define testcase(X)
#define sqlite3MemdebugSetType(X,Y)  /* no-op */
#define sqlite3MemdebugHasType(X,Y)  1
#define sqlite3MemdebugNoType(X,Y)   1
#define MEMTYPE_HEAP       0x01  /* General heap allocations */
#define MEMTYPE_LOOKASIDE  0x02  /* Heap that might have been lookaside */
#define MEMTYPE_PCACHE     0x04  /* Page cache allocations */

/*
** Macro to disable warnings about missing "break" at the end of a "case".
*/
#if GCC_VERSION>=7000000
# define deliberate_fall_through __attribute__((fallthrough));
#else
# define deliberate_fall_through
#endif

#ifndef SQLITE_OMIT_FLOATING_POINT
# define EXP754 (((u64)0x7ff)<<52)
# define MAN754 ((((u64)1)<<52)-1)
# define IsNaN(X) (((X)&EXP754)==EXP754 && ((X)&MAN754)!=0)
static   int sqlite3IsNaN(double);
#else
# define IsNaN(X)         0
# define sqlite3IsNaN(X)  0
#endif

/*
** Macros to compute minimum and maximum of two numbers.
*/
#ifndef MIN
# define MIN(A,B) ((A)<(B)?(A):(B))
#endif
#ifndef MAX
# define MAX(A,B) ((A)>(B)?(A):(B))
#endif

static const unsigned char sqlite3Utf8Trans1[] = {
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};

/* An array to map all upper-case characters into their corresponding
** lower-case character.
**
** SQLite only considers US-ASCII (or EBCDIC) characters.  We do not
** handle case conversions for the UTF character set since the tables
** involved are nearly as big or bigger than SQLite itself.
*/
SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[] = {
#ifdef SQLITE_ASCII
      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
     36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
     54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,
    104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,
    122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,
    108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
    126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,
    162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,
    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,
    198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,
    216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,
    234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,
    252,253,254,255,
#endif
#ifdef SQLITE_EBCDIC
      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, /* 0x */
     16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, /* 1x */
     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, /* 2x */
     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, /* 3x */
     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, /* 4x */
     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, /* 5x */
     96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111, /* 6x */
    112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127, /* 7x */
    128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, /* 8x */
    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159, /* 9x */
    160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, /* Ax */
    176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, /* Bx */
    192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, /* Cx */
    208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, /* Dx */
    224,225,162,163,164,165,166,167,168,169,234,235,236,237,238,239, /* Ex */
    240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255, /* Fx */
#endif
/* All of the upper-to-lower conversion data is above.  The following
** 18 integers are completely unrelated.  They are appended to the
** sqlite3UpperToLower[] array to avoid UBSAN warnings.  Here's what is
** going on:
**
** The SQL comparison operators (<>, =, >, <=, <, and >=) are implemented
** by invoking sqlite3MemCompare(A,B) which compares values A and B and
** returns negative, zero, or positive if A is less then, equal to, or
** greater than B, respectively.  Then the true false results is found by
** consulting sqlite3aLTb[opcode], sqlite3aEQb[opcode], or
** sqlite3aGTb[opcode] depending on whether the result of compare(A,B)
** is negative, zero, or positive, where opcode is the specific opcode.
** The only works because the comparison opcodes are consecutive and in
** this order: NE EQ GT LE LT GE.  Various assert()s throughout the code
** ensure that is the case.
**
** These elements must be appended to another array.  Otherwise the
** index (here shown as [256-OP_Ne]) would be out-of-bounds and thus
** be undefined behavior.  That's goofy, but the C-standards people thought
** it was a good idea, so here we are.
*/
/* NE  EQ  GT  LE  LT  GE  */
   1,  0,  0,  1,  1,  0,  /* aLTb[]: Use when compare(A,B) less than zero */
   0,  1,  0,  1,  0,  1,  /* aEQb[]: Use when compare(A,B) equals zero */
   1,  0,  1,  0,  0,  1   /* aGTb[]: Use when compare(A,B) greater than zero*/
};

/*
** Translate a single UTF-8 character.  Return the unicode value.
**
** During translation, assume that the byte that zTerm points
** is a 0x00.
**
** Write a pointer to the next unread byte back into *pzNext.
**
** Notes On Invalid UTF-8:
**
**  *  This routine never allows a 7-bit character (0x00 through 0x7f) to
**     be encoded as a multi-byte character.  Any multi-byte character that
**     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.
**
**  *  This routine never allows a UTF16 surrogate value to be encoded.
**     If a multi-byte character attempts to encode a value between
**     0xd800 and 0xe000 then it is rendered as 0xfffd.
**
**  *  Bytes in the range of 0x80 through 0xbf which occur as the first
**     byte of a character are interpreted as single-byte characters
**     and rendered as themselves even though they are technically
**     invalid characters.
**
**  *  This routine accepts over-length UTF8 encodings
**     for unicode values 0x80 and greater.  It does not change over-length
**     encodings to 0xfffd as some systems recommend.
*/
#define READ_UTF8(zIn, zTerm, c)                           \
  c = *(zIn++);                                            \
  if( c>=0xc0 ){                                           \
    c = sqlite3Utf8Trans1[c-0xc0];                         \
    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \
      c = (c<<6) + (0x3f & *(zIn++));                      \
    }                                                      \
    if( c<0x80                                             \
        || (c&0xFFFFF800)==0xD800                          \
        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \
  }

/*
** The following macros mimic the standard library functions toupper(),
** isspace(), isalnum(), isdigit() and isxdigit(), respectively. The
** sqlite versions only work for ASCII characters, regardless of locale.
*/
#ifdef SQLITE_ASCII
# define sqlite3Toupper(x)  ((x)&~(sqlite3CtypeMap[(unsigned char)(x)]&0x20))
# define sqlite3Isspace(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x01)
# define sqlite3Isalnum(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x06)
# define sqlite3Isalpha(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x02)
# define sqlite3Isdigit(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x04)
# define sqlite3Isxdigit(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x08)
# define sqlite3Tolower(x)   (sqlite3UpperToLower[(unsigned char)(x)])
# define sqlite3Isquote(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x80)
#else
# define sqlite3Toupper(x)   toupper((unsigned char)(x))
# define sqlite3Isspace(x)   isspace((unsigned char)(x))
# define sqlite3Isalnum(x)   isalnum((unsigned char)(x))
# define sqlite3Isalpha(x)   isalpha((unsigned char)(x))
# define sqlite3Isdigit(x)   isdigit((unsigned char)(x))
# define sqlite3Isxdigit(x)  isxdigit((unsigned char)(x))
# define sqlite3Tolower(x)   tolower((unsigned char)(x))
# define sqlite3Isquote(x)   ((x)=='"'||(x)=='\''||(x)=='['||(x)=='`')
#endif

/* Convenient short-hand */
#define UpperToLower sqlite3UpperToLower

/*
** Assuming zIn points to the first byte of a UTF-8 character,
** advance zIn to point to the first byte of the next UTF-8 character.
*/
#define SQLITE_SKIP_UTF8(zIn) {                        \
  if( (*(zIn++))>=0xc0 ){                              \
    while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \
  }                                                    \
}

/*
** A structure defining how to do GLOB-style comparisons.
*/
struct compareInfo {
  u8 matchAll;          /* "*" or "%" */
  u8 matchOne;          /* "?" or "_" */
  u8 matchSet;          /* "[" or 0 */
  u8 noCase;            /* true to ignore case differences */
};

/*
** For LIKE and GLOB matching on EBCDIC machines, assume that every
** character is exactly one byte in size.  Also, provde the Utf8Read()
** macro for fast reading of the next character in the common case where
** the next character is ASCII.
*/
#if defined(SQLITE_EBCDIC)
# define sqlite3Utf8Read(A)        (*((*A)++))
# define Utf8Read(A)               (*(A++))
#else
# define Utf8Read(A)               (A[0]<0x80?*(A++):sqlite3Utf8Read(&A))
#endif

static const struct compareInfo globInfo = { '*', '?', '[', 0 };
/* The correct SQL-92 behavior is for the LIKE operator to ignore
** case.  Thus  'a' LIKE 'A' would be true. */
static const struct compareInfo likeInfoNorm = { '%', '_',   0, 1 };

/*
** Possible error returns from patternMatch()
*/
#define SQLITE_MATCH             0
#define SQLITE_NOMATCH           1
#define SQLITE_NOWILDCARDMATCH   2

/*
** On machines with a small stack size, you can redefine the
** SQLITE_PRINT_BUF_SIZE to be something smaller, if desired.
*/
#ifndef SQLITE_PRINT_BUF_SIZE
# define SQLITE_PRINT_BUF_SIZE 70
#endif
#define etBUFSIZE SQLITE_PRINT_BUF_SIZE  /* Size of the output buffer */

/*
** Hard limit on the precision of floating-point conversions.
*/
#ifndef SQLITE_PRINTF_PRECISION_LIMIT
# define SQLITE_FP_PRECISION_LIMIT 100000000
#endif

#ifndef SQLITE_MAX_LENGTH
# define SQLITE_MAX_LENGTH 1000000000
#endif

static sqlite3_str sqlite3OomStr = {
   0, 0, 0, 0, 0, SQLITE_NOMEM, 0
};

//MARK: -

typedef struct Token Token;
struct Token {
  const char *z;     /* Text of the token.  Not NULL-terminated! */
  unsigned int n;    /* Number of characters in this token */
};

// this is a dummy SrcItem because the struct is really complex and it is never used in this implementation
typedef struct Select Select;
struct Select {
    u32 selId;             /* Unique identifier number for this SELECT */
    u32 selFlags;          /* Various SF_* values */
};

typedef struct SrcItem SrcItem;
struct SrcItem {
    char *zDatabase;  /* Name of database holding this table */
    char *zName;      /* Name of the table */
    char *zAlias;     /* The "B" part of a "A AS B" phrase.  zName is the "A" */
    Select *pSelect;  /* A SELECT statement used in place of a table name */
};

// sqlite3_str_vappendf
// in a case etTOKEN code uses an Expr struct
// this case is used internally by SQLite to
// print TOKEN and it is never used by the end-users
// so add some dummy struct/definition to just compile
// that case

// just to make sqlite3_str_vappendf compilation happy
typedef struct {
    struct {
        const char *zToken;
    } u;
} Expr;

#define sqlite3RecordErrorOffsetOfExpr(_a, _b)
#define sqlite3RecordErrorByteOffset(_a, _b)
#define ExprHasProperty(_a, _b)     1

static int sqlite3ErrorToParser(sqlite3 *db, int errCode);

/*
** Allowed values for Select.selFlags.  The "SF" prefix stands for
** "Select Flag".
**
** Value constraints (all checked via assert())
**     SF_HasAgg      == NC_HasAgg
**     SF_MinMaxAgg   == NC_MinMaxAgg     == SQLITE_FUNC_MINMAX
**     SF_OrderByReqd == NC_OrderAgg      == SQLITE_FUNC_ANYORDER
**     SF_FixedLimit  == WHERE_USE_LIMIT
*/
#define SF_Distinct      0x0000001 /* Output should be DISTINCT */
#define SF_All           0x0000002 /* Includes the ALL keyword */
#define SF_Resolved      0x0000004 /* Identifiers have been resolved */
#define SF_Aggregate     0x0000008 /* Contains agg functions or a GROUP BY */
#define SF_HasAgg        0x0000010 /* Contains aggregate functions */
#define SF_UsesEphemeral 0x0000020 /* Uses the OpenEphemeral opcode */
#define SF_Expanded      0x0000040 /* sqlite3SelectExpand() called on this */
#define SF_HasTypeInfo   0x0000080 /* FROM subqueries have Table metadata */
#define SF_Compound      0x0000100 /* Part of a compound query */
#define SF_Values        0x0000200 /* Synthesized from VALUES clause */
#define SF_MultiValue    0x0000400 /* Single VALUES term with multiple rows */
#define SF_NestedFrom    0x0000800 /* Part of a parenthesized FROM clause */
#define SF_MinMaxAgg     0x0001000 /* Aggregate containing min() or max() */
#define SF_Recursive     0x0002000 /* The recursive part of a recursive CTE */
#define SF_FixedLimit    0x0004000 /* nSelectRow set by a constant LIMIT */
#define SF_MaybeConvert  0x0008000 /* Need convertCompoundSelectToSubquery() */
#define SF_Converted     0x0010000 /* By convertCompoundSelectToSubquery() */
#define SF_IncludeHidden 0x0020000 /* Include hidden columns in output */
#define SF_ComplexResult 0x0040000 /* Result contains subquery or function */
#define SF_WhereBegin    0x0080000 /* Really a WhereBegin() call.  Debug Only */
#define SF_WinRewrite    0x0100000 /* Window function rewrite accomplished */
#define SF_View          0x0200000 /* SELECT statement is a view */
#define SF_NoopOrderBy   0x0400000 /* ORDER BY is ignored for this query */
#define SF_UFSrcCheck    0x0800000 /* Check pSrc as required by UPDATE...FROM */
#define SF_PushDown      0x1000000 /* SELECT has be modified by push-down opt */
#define SF_MultiPart     0x2000000 /* Has multiple incompatible PARTITIONs */
#define SF_CopyCte       0x4000000 /* SELECT statement is a copy of a CTE */
#define SF_OrderByReqd   0x8000000 /* The ORDER BY clause may not be omitted */

/* True if S exists and has SF_NestedFrom */
#define IsNestedFrom(S) ((S)!=0 && ((S)->selFlags&SF_NestedFrom)!=0)

#define sqlite3DbMallocRaw(_db, _size)          sqlite3_malloc64(_size)
#define sqlite3DbRealloc(_db, _ptr, _size)      sqlite3_realloc64(_ptr, _size)
#define sqlite3Realloc(_ptr, _size)             sqlite3_realloc64(_ptr, _size)
#define sqlite3DbMallocSize(_db, _ptr)          (u32)sqlite3_msize(_ptr)
#define sqlite3DbFree(_db, _ptr)                sqlite3_free(_ptr)

SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[256] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 00..07    ........ */
  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  /* 08..0f    ........ */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 10..17    ........ */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 18..1f    ........ */
  0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80,  /* 20..27     !"#$%&' */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 28..2f    ()*+,-./ */
  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,  /* 30..37    01234567 */
  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 38..3f    89:;<=>? */

  0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,  /* 40..47    @ABCDEFG */
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 48..4f    HIJKLMNO */
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 50..57    PQRSTUVW */
  0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40,  /* 58..5f    XYZ[\]^_ */
  0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,  /* 60..67    `abcdefg */
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 68..6f    hijklmno */
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 70..77    pqrstuvw */
  0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 78..7f    xyz{|}~. */

  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 80..87    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 88..8f    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 90..97    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 98..9f    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a0..a7    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a8..af    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b0..b7    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b8..bf    ........ */

  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c0..c7    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c8..cf    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d0..d7    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d8..df    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e0..e7    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e8..ef    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* f0..f7    ........ */
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40   /* f8..ff    ........ */
};

#ifdef SQLITE_ASCII
#define IdChar(C)  ((sqlite3CtypeMap[(unsigned char)C]&0x46)!=0)
#endif
#ifdef SQLITE_EBCDIC
SQLITE_PRIVATE const char sqlite3IsEbcdicIdChar[] = {
/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 4x */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0,  /* 5x */
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,  /* 6x */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  /* 7x */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0,  /* 8x */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0,  /* 9x */
    1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0,  /* Ax */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* Bx */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Cx */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Dx */
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Ex */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0,  /* Fx */
};
#define IdChar(C)  (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40]))
#endif

/*
** Token types used by the sqlite3_complete() routine.  See the header
** comments on that procedure for additional information.
*/
#define tkSEMI    0
#define tkWS      1
#define tkOTHER   2
#ifndef SQLITE_OMIT_TRIGGER
#define tkEXPLAIN 3
#define tkCREATE  4
#define tkTEMP    5
#define tkTRIGGER 6
#define tkEND     7
#endif
#define sqlite3StrNICmp sqlite3_strnicmp

#endif

     
//
// END FILE: sqlite3_internals.h
// ----------------------------------------------------------------------------



// ----------------------------------------------------------------------------
// BEGIN FILE: sqlite3cloud_api.h
//


//
//  sqlite3cloud_api.h
//  sqlite3cloud_test
//
//  Created by Marco Bambini on 20/10/22.
//

#ifndef SQLITE3CLOUD_API
#define SQLITE3CLOUD_API

#include <stddef.h>
// (AMALGAMATED) #include "sqlite3.h"
// (AMALGAMATED) #include "sqcloud.h"
// (AMALGAMATED) #include "sqlite3_internals.h"

#define SQLITE3CLOUD_API_VERSION         "1.0.0"
#define SQLITE3CLOUD_API_VERSION_NUM     0x010000

struct sqlite3 {
    SQCloudConnection   *connection;
    
    int                 exterrcodes;
    sqlite3_int64       lastrowid;
    sqlite3_int64       totalchanges;
    sqlite3_int64       changes;
    
    char                *buffer;
    size_t              blen;
    
    int                 traceFlags;
    void                *traceData;
    trace_callback      trace;
    
    // local sqlite3 specific
    int aLimit[SQLITE_N_LIMIT];   /* Limits */
};

struct sqlite3_stmt {
    sqlite3             *db;
    SQCloudVM           *vm;
    SQCloudResult       *sql;
    char                sbuffer[64];
    char                *buffer;
};

struct sqlite3_value {
    int                 tag;
    sqlite3_uint64      len;
    union {
        sqlite3_int64   ivalue;
        double          dvalue;
        const char      *ptrvalue;
    };
};

struct sqlite3_blob {
    sqlite3             *db;
    SQCloudBlob         *blob;
};

struct sqlite3_backup {
    sqlite3             *db;
    SQCloudBackup       *backup;
};

typedef struct sqlite3_session sqlite3_session;
typedef struct sqlite3_changeset_iter sqlite3_changeset_iter;
typedef struct sqlite3_changegroup sqlite3_changegroup;
typedef struct sqlite3_rebaser sqlite3_rebaser;

struct sqlite3_session {
    int                 dummy;
};
struct sqlite3_changeset_iter {
    int                 dummy;
};
struct sqlite3_changegroup {
    int                 dummy;
};
struct sqlite3_rebaser {
    int                 dummy;
};

// MARK: - Function prototypes -

int sqlite3cloud_open(const char *filename, sqlite3 **db, int flags);

int sqlite3cloud_close(sqlite3 *db);

int sqlite3cloud_exec(
  sqlite3 *db,                /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  sqlite3_callback xCallback, /* Invoke this callback routine */
  void *pArg,                 /* First argument to xCallback() */
  char **pzErrMsg             /* Write error messages here */
);

int sqlite3cloud_gettable(
  sqlite3 *db,                /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  char ***pazResult,          /* Write the result table here */
  int *pnRow,                 /* Write the number of rows in the result here */
  int *pnColumn,              /* Write the number of columns of result here */
  char **pzErrMsg             /* Write error messages here */
);

void sqlite3cloud_freetable(char **azResult);

int sqlite3cloud_table_column_metadata(
  sqlite3 *db,                /* Connection handle */
  const char *zDbName,        /* Database name or NULL */
  const char *zTableName,     /* Table name */
  const char *zColumnName,    /* Column name */
  char const **pzDataType,    /* OUTPUT: Declared data type */
  char const **pzCollSeq,     /* OUTPUT: Collation sequence name */
  int *pNotNull,              /* OUTPUT: True if NOT NULL constraint exists */
  int *pPrimaryKey,           /* OUTPUT: True if column part of PK */
  int *pAutoinc               /* OUTPUT: True if column is auto-increment */
);

sqlite3_int64 sqlite3cloud_lastrowid(sqlite3 *db);

void sqlite3cloud_setlastrowid(sqlite3 *db, sqlite3_int64 iRowid);

sqlite3_int64 sqlite3cloud_changes(sqlite3 *db);

sqlite3_int64 sqlite3cloud_totalchanges(sqlite3 *db);

int sqlite3cloud_status(int op, sqlite3_int64 *pCurrent, sqlite3_int64 *pHighwater, int resetFlag);

void sqlite3cloud_interrupt(sqlite3 *db);

int sqlite3cloud_is_interrupted(sqlite3*);

sqlite3_int64 sqlite3cloud_memory_highwater(int resetFlag);

int sqlite3cloud_step(sqlite3_stmt *pStmt);

int sqlite3cloud_stmt_readonly(sqlite3_stmt *pStmt);

int sqlite3cloud_stmt_isexplain(sqlite3_stmt *pStmt);

int sqlite3cloud_stmt_busy(sqlite3_stmt *pStmt);

int sqlite3cloud_bind_double(sqlite3_stmt *pStmt, int i, double rValue);

int sqlite3cloud_bind_int(sqlite3_stmt *pStmt, int i, int iValue);

int sqlite3cloud_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue);

int sqlite3cloud_bind_null(sqlite3_stmt *pStmt, int i);

int sqlite3cloud_bind_blob(
                             sqlite3_stmt *pStmt,
                             int i,
                             const void *zData,
                             sqlite3_uint64 nData,
                             void (*xDel)(void*)
                           );

int sqlite3cloud_bind_text(
  sqlite3_stmt *pStmt,
  int i,
  const char *zData,
  sqlite3_uint64 nData,
  void (*xDel)(void*),
  unsigned char enc
);

int sqlite3cloud_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue);

int sqlite3cloud_bind_pointer(
  sqlite3_stmt *pStmt,
  int i,
  void *pPtr,
  const char *zPTtype,
  void (*xDestructor)(void*)
);

int sqlite3cloud_bind_zeroblob(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n);

int sqlite3cloud_bind_parameter_count(sqlite3_stmt *pStmt);

const char *sqlite3cloud_bind_parameter_name(sqlite3_stmt *pStmt, int i);

int sqlite3cloud_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName);

int sqlite3cloud_column_count(sqlite3_stmt *pStmt);

const char *sqlite3cloud_column_name(sqlite3_stmt *pStmt, int N);

const char *sqlite3cloud_column_database_name(sqlite3_stmt *pStmt, int N);

const char *sqlite3cloud_column_table_name(sqlite3_stmt *pStmt, int N);

const char *sqlite3cloud_column_origin_name(sqlite3_stmt *pStmt, int N);

const char *sqlite3cloud_column_decltype(sqlite3_stmt *pStmt, int N);

int sqlite3cloud_data_count(sqlite3_stmt *pStmt);

const void *sqlite3cloud_column_blob(sqlite3_stmt *pStmt, int i);

double sqlite3cloud_column_double(sqlite3_stmt *pStmt, int i);

int sqlite3cloud_column_int(sqlite3_stmt *pStmt, int i);

sqlite3_int64 sqlite3cloud_column_int64(sqlite3_stmt *pStmt, int i);

const unsigned char *sqlite3cloud_column_text(sqlite3_stmt *pStmt, int i);

sqlite3_value *sqlite3cloud_column_value(sqlite3_stmt *pStmt, int i);

int sqlite3cloud_column_bytes(sqlite3_stmt *pStmt, int i);

int sqlite3cloud_column_type(sqlite3_stmt *pStmt, int i);

int sqlite3cloud_clear_bindings(sqlite3_stmt *pStmt);

int sqlite3cloud_finalize(sqlite3_stmt *pStmt);

int sqlite3cloud_reset(sqlite3_stmt *pStmt);

int sqlite3cloud_retrieve_sql(sqlite3_stmt *pStmt);

sqlite3_stmt *sqlite3cloud_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);

int sqlite3cloud_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag);

int sqlite3cloud_stmt_scanstatus(
  sqlite3_stmt *pStmt,            /* Prepared statement being queried */
  int idx,                        /* Index of loop to report on */
  int iScanStatusOp,              /* Which metric to return */
  int flags,                      /* Mask of flags defined below */
  void *pOut                      /* OUT: Write the answer here */
);

int sqlite3cloud_stmt_scanstatus_v2(
  sqlite3_stmt *pStmt,      /* Prepared statement for which info desired */
  int idx,                  /* Index of loop to report on */
  int iScanStatusOp,        /* Information desired.  SQLITE_SCANSTAT_* */
  int flags,                /* Mask of flags defined below */
  void *pOut                /* Result written here */
);

void sqlite3cloud_stmt_scanstatus_reset(sqlite3_stmt *pStmt);

int sqlite3cloud_blob_open(
  sqlite3* db,            /* The database connection */
  const char *zDb,        /* The attached database containing the blob */
  const char *zTable,     /* The table containing the blob */
  const char *zColumn,    /* The column containing the blob */
  sqlite_int64 iRow,      /* The row containing the glob */
  int wrFlag,             /* True -> read/write access, false -> read-only */
  sqlite3_blob **ppBlob   /* Handle for accessing the blob returned here */
);

int sqlite3cloud_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow);

int sqlite3cloud_blob_close(sqlite3_blob *pBlob);

int sqlite3cloud_blob_bytes(sqlite3_blob *pBlob);

int sqlite3cloud_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset);

int sqlite3cloud_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset);

sqlite3_backup *sqlite3cloud_backup_init(
  sqlite3* pDestDb,                     /* Database to write to */
  const char *zDestDb,                  /* Name of database within pDestDb */
  sqlite3* pSrcDb,                      /* Database connection to read from */
  const char *zSrcDb                    /* Name of database within pSrcDb */
);

int sqlite3cloud_backup_step(sqlite3_backup *p, int nPage);

int sqlite3cloud_backup_finish(sqlite3_backup *p);

int sqlite3cloud_backup_remaining(sqlite3_backup *p);

int sqlite3cloud_backup_pagecount(sqlite3_backup *p);

int sqlite3cloud_db_cacheflush(sqlite3 *db);

int sqlite3cloud_system_errno(sqlite3 *db);

int sqlite3cloud_txn_state(sqlite3 *db, const char *zSchema);

int sqlite3cloud_error_offset(sqlite3 *db);

int sqlite3cloud_keyword_count(void);

int sqlite3cloud_keyword_name(int i,const char **pzName,int *pnName);

int sqlite3cloud_keyword_check(const char *zName, int nName);

int sqlite3cloud_complete(const char *zSql);

sqlite3_value *sqlite3cloud_value_dup(const sqlite3_value *pOrig);

void *sqlite3cloud_malloc(sqlite3_uint64 n);

void *sqlite3cloud_zeroalloc(sqlite3_uint64 n);

void *sqlite3cloud_realloc(void *pPrior, sqlite3_uint64 n);

void sqlite3cloud_free(void *pPrior);

char *sqlite3cloud_strndup(const char *str1, size_t len);

char *sqlite3cloud_strdup(const char *str1);

sqlite3_uint64 sqlite3cloud_msize(void *pPrior);

sqlite3_uint64 sqlite3cloud_totmem(void);

int sqlite3cloud_errcode(sqlite3 *db);

int sqlite3cloud_extended_errcode(sqlite3 *db);

const char *sqlite3cloud_errmsg(sqlite3 *db);

sqlite3_stmt *sqlite3cloud_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);

int sqlite3cloud_limit(sqlite3 *db, int limitId, int newLimit);

const char *sqlite3cloud_db_filename(sqlite3 *db, const char *zDbName);

const char *sqlite3cloud_db_name(sqlite3 *db, int N);

int sqlite3cloud_db_readonly(sqlite3 *db, const char *zDbName);

int sqlite3cloud_sleep(int ms);

int sqlite3cloud_db_status(sqlite3 *db, int op, int *pCur, int *pHiwtr, int resetFlag);

int sqlite3cloud_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag);

int sqlite3cloud_compileoption_used(const char *zOptName);

const char *sqlite3cloud_compileoption_get(int N);

void sqlite3cloud_log(int iErrCode, const char *format, va_list args);

int sqlite3cloud_prepare(
    sqlite3 *db,              /* Database handle. */
    const char *zSql,         /* UTF-8 encoded SQL statement. */
    int nBytes,               /* Length of zSql in bytes. */
    unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */
    sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
    const char **pzTail       /* OUT: End of parsed string */
);

#endif

     
//
// END FILE: sqlite3cloud_api.h
// ----------------------------------------------------------------------------



// ----------------------------------------------------------------------------
// BEGIN FILE: lz4.c
//


/*
   LZ4 - Fast LZ compression algorithm
   Copyright (C) 2011-present, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
    - LZ4 homepage : http://www.lz4.org
    - LZ4 source repository : https://github.com/lz4/lz4
*/

/*-************************************
*  Tuning parameters
**************************************/
/*
 * LZ4_HEAPMODE :
 * Select how default compression functions will allocate memory for their hash table,
 * in memory stack (0:default, fastest), or in memory heap (1:requires malloc()).
 */
#ifndef LZ4_HEAPMODE
#  define LZ4_HEAPMODE 0
#endif

/*
 * LZ4_ACCELERATION_DEFAULT :
 * Select "acceleration" for LZ4_compress_fast() when parameter value <= 0
 */
#define LZ4_ACCELERATION_DEFAULT 1
/*
 * LZ4_ACCELERATION_MAX :
 * Any "acceleration" value higher than this threshold
 * get treated as LZ4_ACCELERATION_MAX instead (fix #876)
 */
#define LZ4_ACCELERATION_MAX 65537


/*-************************************
*  CPU Feature Detection
**************************************/
/* LZ4_FORCE_MEMORY_ACCESS
 * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
 * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
 * The below switch allow to select different access method for improved performance.
 * Method 0 (default) : use `memcpy()`. Safe and portable.
 * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
 *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
 * Method 2 : direct access. This method is portable but violate C standard.
 *            It can generate buggy code on targets which assembly generation depends on alignment.
 *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
 * See https://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.
 * Prefer these methods in priority order (0 > 1 > 2)
 */
#ifndef LZ4_FORCE_MEMORY_ACCESS   /* can be defined externally */
#  if defined(__GNUC__) && \
  ( defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) \
  || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) )
#    define LZ4_FORCE_MEMORY_ACCESS 2
#  elif (defined(__INTEL_COMPILER) && !defined(_WIN32)) || defined(__GNUC__)
#    define LZ4_FORCE_MEMORY_ACCESS 1
#  endif
#endif

/*
 * LZ4_FORCE_SW_BITCOUNT
 * Define this parameter if your target system or compiler does not support hardware bit count
 */
#if defined(_MSC_VER) && defined(_WIN32_WCE)   /* Visual Studio for WinCE doesn't support Hardware bit count */
#  undef  LZ4_FORCE_SW_BITCOUNT  /* avoid double def */
#  define LZ4_FORCE_SW_BITCOUNT
#endif



/*-************************************
*  Dependency
**************************************/
/*
 * LZ4_SRC_INCLUDED:
 * Amalgamation flag, whether lz4.c is included
 */
#ifndef LZ4_SRC_INCLUDED
#  define LZ4_SRC_INCLUDED 1
#endif

#ifndef LZ4_STATIC_LINKING_ONLY
#define LZ4_STATIC_LINKING_ONLY
#endif

#ifndef LZ4_DISABLE_DEPRECATE_WARNINGS
#define LZ4_DISABLE_DEPRECATE_WARNINGS /* due to LZ4_decompress_safe_withPrefix64k */
#endif

#define LZ4_STATIC_LINKING_ONLY  /* LZ4_DISTANCE_MAX */
// (AMALGAMATED) #include "lz4.h"
/* see also "memory routines" below */


/*-************************************
*  Compiler Options
**************************************/
#if defined(_MSC_VER) && (_MSC_VER >= 1400)  /* Visual Studio 2005+ */
#  include <intrin.h>               /* only present in VS2005+ */
#  pragma warning(disable : 4127)   /* disable: C4127: conditional expression is constant */
#endif  /* _MSC_VER */

#ifndef LZ4_FORCE_INLINE
#  ifdef _MSC_VER    /* Visual Studio */
#    define LZ4_FORCE_INLINE static __forceinline
#  else
#    if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
#      ifdef __GNUC__
#        define LZ4_FORCE_INLINE static inline __attribute__((always_inline))
#      else
#        define LZ4_FORCE_INLINE static inline
#      endif
#    else
#      define LZ4_FORCE_INLINE static
#    endif /* __STDC_VERSION__ */
#  endif  /* _MSC_VER */
#endif /* LZ4_FORCE_INLINE */

/* LZ4_FORCE_O2 and LZ4_FORCE_INLINE
 * gcc on ppc64le generates an unrolled SIMDized loop for LZ4_wildCopy8,
 * together with a simple 8-byte copy loop as a fall-back path.
 * However, this optimization hurts the decompression speed by >30%,
 * because the execution does not go to the optimized loop
 * for typical compressible data, and all of the preamble checks
 * before going to the fall-back path become useless overhead.
 * This optimization happens only with the -O3 flag, and -O2 generates
 * a simple 8-byte copy loop.
 * With gcc on ppc64le, all of the LZ4_decompress_* and LZ4_wildCopy8
 * functions are annotated with __attribute__((optimize("O2"))),
 * and also LZ4_wildCopy8 is forcibly inlined, so that the O2 attribute
 * of LZ4_wildCopy8 does not affect the compression speed.
 */
#if defined(__PPC64__) && defined(__LITTLE_ENDIAN__) && defined(__GNUC__) && !defined(__clang__)
#  define LZ4_FORCE_O2  __attribute__((optimize("O2")))
#  undef LZ4_FORCE_INLINE
#  define LZ4_FORCE_INLINE  static __inline __attribute__((optimize("O2"),always_inline))
#else
#  define LZ4_FORCE_O2
#endif

#if (defined(__GNUC__) && (__GNUC__ >= 3)) || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) || defined(__clang__)
#  define expect(expr,value)    (__builtin_expect ((expr),(value)) )
#else
#  define expect(expr,value)    (expr)
#endif

#ifndef likely
#define likely(expr)     expect((expr) != 0, 1)
#endif
#ifndef unlikely
#define unlikely(expr)   expect((expr) != 0, 0)
#endif

/* Should the alignment test prove unreliable, for some reason,
 * it can be disabled by setting LZ4_ALIGN_TEST to 0 */
#ifndef LZ4_ALIGN_TEST  /* can be externally provided */
# define LZ4_ALIGN_TEST 1
#endif


/*-************************************
*  Memory routines
**************************************/
#ifdef LZ4_USER_MEMORY_FUNCTIONS
/* memory management functions can be customized by user project.
 * Below functions must exist somewhere in the Project
 * and be available at link time */
void* LZ4_malloc(size_t s);
void* LZ4_calloc(size_t n, size_t s);
void  LZ4_free(void* p);
# define ALLOC(s)          LZ4_malloc(s)
# define ALLOC_AND_ZERO(s) LZ4_calloc(1,s)
# define FREEMEM(p)        LZ4_free(p)
#else
# include <stdlib.h>   /* malloc, calloc, free */
# define ALLOC(s)          malloc(s)
# define ALLOC_AND_ZERO(s) calloc(1,s)
# define FREEMEM(p)        free(p)
#endif

#include <string.h>   /* memset, memcpy */
#define MEM_INIT(p,v,s)   memset((p),(v),(s))


/*-************************************
*  Common Constants
**************************************/
#define MINMATCH 4

#define WILDCOPYLENGTH 8
#define LASTLITERALS   5   /* see ../doc/lz4_Block_format.md#parsing-restrictions */
#define MFLIMIT       12   /* see ../doc/lz4_Block_format.md#parsing-restrictions */
#define MATCH_SAFEGUARD_DISTANCE  ((2*WILDCOPYLENGTH) - MINMATCH)   /* ensure it's possible to write 2 x wildcopyLength without overflowing output buffer */
#define FASTLOOP_SAFE_DISTANCE 64
static const int LZ4_minLength = (MFLIMIT+1);

#define KB *(1 <<10)
#define MB *(1 <<20)
#define GB *(1U<<30)

#define LZ4_DISTANCE_ABSOLUTE_MAX 65535
#if (LZ4_DISTANCE_MAX > LZ4_DISTANCE_ABSOLUTE_MAX)   /* max supported by LZ4 format */
#  error "LZ4_DISTANCE_MAX is too big : must be <= 65535"
#endif

#define ML_BITS  4
#define ML_MASK  ((1U<<ML_BITS)-1)
#define RUN_BITS (8-ML_BITS)
#define RUN_MASK ((1U<<RUN_BITS)-1)


/*-************************************
*  Error detection
**************************************/
#if defined(LZ4_DEBUG) && (LZ4_DEBUG>=1)
#  include <assert.h>
#else
#  ifndef assert
#    define assert(condition) ((void)0)
#  endif
#endif

#define LZ4_STATIC_ASSERT(c)   { enum { LZ4_static_assert = 1/(int)(!!(c)) }; }   /* use after variable declarations */

#if defined(LZ4_DEBUG) && (LZ4_DEBUG>=2)
#  include <stdio.h>
   static int g_debuglog_enable = 1;
#  define DEBUGLOG(l, ...) {                          \
        if ((g_debuglog_enable) && (l<=LZ4_DEBUG)) {  \
            fprintf(stderr, __FILE__ ": ");           \
            fprintf(stderr, __VA_ARGS__);             \
            fprintf(stderr, " \n");                   \
    }   }
#else
#  define DEBUGLOG(l, ...) {}    /* disabled */
#endif

static int LZ4_isAligned(const void* ptr, size_t alignment)
{
    return ((size_t)ptr & (alignment -1)) == 0;
}


/*-************************************
*  Types
**************************************/
#include <limits.h>
#if defined(__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
# include <stdint.h>
  typedef  uint8_t BYTE;
  typedef uint16_t U16;
  typedef uint32_t U32;
  typedef  int32_t S32;
  typedef uint64_t U64;
  typedef uintptr_t uptrval;
#else
# if UINT_MAX != 4294967295UL
#   error "LZ4 code (when not C++ or C99) assumes that sizeof(int) == 4"
# endif
  typedef unsigned char       BYTE;
  typedef unsigned short      U16;
  typedef unsigned int        U32;
  typedef   signed int        S32;
  typedef unsigned long long  U64;
  typedef size_t              uptrval;   /* generally true, except OpenVMS-64 */
#endif

#if defined(__x86_64__)
  typedef U64    reg_t;   /* 64-bits in x32 mode */
#else
  typedef size_t reg_t;   /* 32-bits in x32 mode */
#endif

typedef enum {
    notLimited = 0,
    limitedOutput = 1,
    fillOutput = 2
} limitedOutput_directive;


/*-************************************
*  Reading and writing into memory
**************************************/

/**
 * LZ4 relies on memcpy with a constant size being inlined. In freestanding
 * environments, the compiler can't assume the implementation of memcpy() is
 * standard compliant, so it can't apply its specialized memcpy() inlining
 * logic. When possible, use __builtin_memcpy() to tell the compiler to analyze
 * memcpy() as if it were standard compliant, so it can inline it in freestanding
 * environments. This is needed when decompressing the Linux Kernel, for example.
 */
#if defined(__GNUC__) && (__GNUC__ >= 4)
#define LZ4_memcpy(dst, src, size) __builtin_memcpy(dst, src, size)
#else
#define LZ4_memcpy(dst, src, size) memcpy(dst, src, size)
#endif

static unsigned LZ4_isLittleEndian(void)
{
    const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental */
    return one.c[0];
}


#if defined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==2)
/* lie to the compiler about data alignment; use with caution */

static U16 LZ4_read16(const void* memPtr) { return *(const U16*) memPtr; }
static U32 LZ4_read32(const void* memPtr) { return *(const U32*) memPtr; }
static reg_t LZ4_read_ARCH(const void* memPtr) { return *(const reg_t*) memPtr; }

static void LZ4_write16(void* memPtr, U16 value) { *(U16*)memPtr = value; }
static void LZ4_write32(void* memPtr, U32 value) { *(U32*)memPtr = value; }

#elif defined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==1)

/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
/* currently only defined for gcc and icc */
typedef union { U16 u16; U32 u32; reg_t uArch; } __attribute__((packed)) unalign;

static U16 LZ4_read16(const void* ptr) { return ((const unalign*)ptr)->u16; }
static U32 LZ4_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }

static void LZ4_write16(void* memPtr, U16 value) { ((unalign*)memPtr)->u16 = value; }
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }

#else  /* safe and portable access using memcpy() */

static U16 LZ4_read16(const void* memPtr)
{
    U16 val; LZ4_memcpy(&val, memPtr, sizeof(val)); return val;
}

static U32 LZ4_read32(const void* memPtr)
{
    U32 val; LZ4_memcpy(&val, memPtr, sizeof(val)); return val;
}

static reg_t LZ4_read_ARCH(const void* memPtr)
{
    reg_t val; LZ4_memcpy(&val, memPtr, sizeof(val)); return val;
}

static void LZ4_write16(void* memPtr, U16 value)
{
    LZ4_memcpy(memPtr, &value, sizeof(value));
}

static void LZ4_write32(void* memPtr, U32 value)
{
    LZ4_memcpy(memPtr, &value, sizeof(value));
}

#endif /* LZ4_FORCE_MEMORY_ACCESS */


static U16 LZ4_readLE16(const void* memPtr)
{
    if (LZ4_isLittleEndian()) {
        return LZ4_read16(memPtr);
    } else {
        const BYTE* p = (const BYTE*)memPtr;
        return (U16)((U16)p[0] + (p[1]<<8));
    }
}

static void LZ4_writeLE16(void* memPtr, U16 value)
{
    if (LZ4_isLittleEndian()) {
        LZ4_write16(memPtr, value);
    } else {
        BYTE* p = (BYTE*)memPtr;
        p[0] = (BYTE) value;
        p[1] = (BYTE)(value>>8);
    }
}

/* customized variant of memcpy, which can overwrite up to 8 bytes beyond dstEnd */
LZ4_FORCE_INLINE
void LZ4_wildCopy8(void* dstPtr, const void* srcPtr, void* dstEnd)
{
    BYTE* d = (BYTE*)dstPtr;
    const BYTE* s = (const BYTE*)srcPtr;
    BYTE* const e = (BYTE*)dstEnd;

    do { LZ4_memcpy(d,s,8); d+=8; s+=8; } while (d<e);
}

static const unsigned inc32table[8] = {0, 1, 2,  1,  0,  4, 4, 4};
static const int      dec64table[8] = {0, 0, 0, -1, -4,  1, 2, 3};


#ifndef LZ4_FAST_DEC_LOOP
#  if defined __i386__ || defined _M_IX86 || defined __x86_64__ || defined _M_X64
#    define LZ4_FAST_DEC_LOOP 1
#  elif defined(__aarch64__) && !defined(__clang__)
     /* On aarch64, we disable this optimization for clang because on certain
      * mobile chipsets, performance is reduced with clang. For information
      * refer to https://github.com/lz4/lz4/pull/707 */
#    define LZ4_FAST_DEC_LOOP 1
#  else
#    define LZ4_FAST_DEC_LOOP 0
#  endif
#endif

#if LZ4_FAST_DEC_LOOP

LZ4_FORCE_INLINE void
LZ4_memcpy_using_offset_base(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const size_t offset)
{
    assert(srcPtr + offset == dstPtr);
    if (offset < 8) {
        LZ4_write32(dstPtr, 0);   /* silence an msan warning when offset==0 */
        dstPtr[0] = srcPtr[0];
        dstPtr[1] = srcPtr[1];
        dstPtr[2] = srcPtr[2];
        dstPtr[3] = srcPtr[3];
        srcPtr += inc32table[offset];
        LZ4_memcpy(dstPtr+4, srcPtr, 4);
        srcPtr -= dec64table[offset];
        dstPtr += 8;
    } else {
        LZ4_memcpy(dstPtr, srcPtr, 8);
        dstPtr += 8;
        srcPtr += 8;
    }

    LZ4_wildCopy8(dstPtr, srcPtr, dstEnd);
}

/* customized variant of memcpy, which can overwrite up to 32 bytes beyond dstEnd
 * this version copies two times 16 bytes (instead of one time 32 bytes)
 * because it must be compatible with offsets >= 16. */
LZ4_FORCE_INLINE void
LZ4_wildCopy32(void* dstPtr, const void* srcPtr, void* dstEnd)
{
    BYTE* d = (BYTE*)dstPtr;
    const BYTE* s = (const BYTE*)srcPtr;
    BYTE* const e = (BYTE*)dstEnd;

    do { LZ4_memcpy(d,s,16); LZ4_memcpy(d+16,s+16,16); d+=32; s+=32; } while (d<e);
}

/* LZ4_memcpy_using_offset()  presumes :
 * - dstEnd >= dstPtr + MINMATCH
 * - there is at least 8 bytes available to write after dstEnd */
LZ4_FORCE_INLINE void
LZ4_memcpy_using_offset(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const size_t offset)
{
    BYTE v[8];

    assert(dstEnd >= dstPtr + MINMATCH);

    switch(offset) {
    case 1:
        MEM_INIT(v, *srcPtr, 8);
        break;
    case 2:
        LZ4_memcpy(v, srcPtr, 2);
        LZ4_memcpy(&v[2], srcPtr, 2);
        LZ4_memcpy(&v[4], v, 4);
        break;
    case 4:
        LZ4_memcpy(v, srcPtr, 4);
        LZ4_memcpy(&v[4], srcPtr, 4);
        break;
    default:
        LZ4_memcpy_using_offset_base(dstPtr, srcPtr, dstEnd, offset);
        return;
    }

    LZ4_memcpy(dstPtr, v, 8);
    dstPtr += 8;
    while (dstPtr < dstEnd) {
        LZ4_memcpy(dstPtr, v, 8);
        dstPtr += 8;
    }
}
#endif


/*-************************************
*  Common functions
**************************************/
static unsigned LZ4_NbCommonBytes (reg_t val)
{
    assert(val != 0);
    if (LZ4_isLittleEndian()) {
        if (sizeof(val) == 8) {
#       if defined(_MSC_VER) && (_MSC_VER >= 1800) && defined(_M_AMD64) && !defined(LZ4_FORCE_SW_BITCOUNT)
            /* x64 CPUS without BMI support interpret `TZCNT` as `REP BSF` */
            return (unsigned)_tzcnt_u64(val) >> 3;
#       elif defined(_MSC_VER) && defined(_WIN64) && !defined(LZ4_FORCE_SW_BITCOUNT)
            unsigned long r = 0;
            _BitScanForward64(&r, (U64)val);
            return (unsigned)r >> 3;
#       elif (defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 3) || \
                            ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4))))) && \
                                        !defined(LZ4_FORCE_SW_BITCOUNT)
            return (unsigned)__builtin_ctzll((U64)val) >> 3;
#       else
            const U64 m = 0x0101010101010101ULL;
            val ^= val - 1;
            return (unsigned)(((U64)((val & (m - 1)) * m)) >> 56);
#       endif
        } else /* 32 bits */ {
#       if defined(_MSC_VER) && (_MSC_VER >= 1400) && !defined(LZ4_FORCE_SW_BITCOUNT)
            unsigned long r;
            _BitScanForward(&r, (U32)val);
            return (unsigned)r >> 3;
#       elif (defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 3) || \
                            ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4))))) && \
                        !defined(__TINYC__) && !defined(LZ4_FORCE_SW_BITCOUNT)
            return (unsigned)__builtin_ctz((U32)val) >> 3;
#       else
            const U32 m = 0x01010101;
            return (unsigned)((((val - 1) ^ val) & (m - 1)) * m) >> 24;
#       endif
        }
    } else   /* Big Endian CPU */ {
        if (sizeof(val)==8) {
#       if (defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 3) || \
                            ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4))))) && \
                        !defined(__TINYC__) && !defined(LZ4_FORCE_SW_BITCOUNT)
            return (unsigned)__builtin_clzll((U64)val) >> 3;
#       else
#if 1
            /* this method is probably faster,
             * but adds a 128 bytes lookup table */
            static const unsigned char ctz7_tab[128] = {
                7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
            };
            U64 const mask = 0x0101010101010101ULL;
            U64 const t = (((val >> 8) - mask) | val) & mask;
            return ctz7_tab[(t * 0x0080402010080402ULL) >> 57];
#else
            /* this method doesn't consume memory space like the previous one,
             * but it contains several branches,
             * that may end up slowing execution */
            static const U32 by32 = sizeof(val)*4;  /* 32 on 64 bits (goal), 16 on 32 bits.
            Just to avoid some static analyzer complaining about shift by 32 on 32-bits target.
            Note that this code path is never triggered in 32-bits mode. */
            unsigned r;
            if (!(val>>by32)) { r=4; } else { r=0; val>>=by32; }
            if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
            r += (!val);
            return r;
#endif
#       endif
        } else /* 32 bits */ {
#       if (defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 3) || \
                            ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4))))) && \
                                        !defined(LZ4_FORCE_SW_BITCOUNT)
            return (unsigned)__builtin_clz((U32)val) >> 3;
#       else
            val >>= 8;
            val = ((((val + 0x00FFFF00) | 0x00FFFFFF) + val) |
              (val + 0x00FF0000)) >> 24;
            return (unsigned)val ^ 3;
#       endif
        }
    }
}


#define STEPSIZE sizeof(reg_t)
LZ4_FORCE_INLINE
unsigned LZ4_count(const BYTE* pIn, const BYTE* pMatch, const BYTE* pInLimit)
{
    const BYTE* const pStart = pIn;

    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
        if (!diff) {
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
        } else {
            return LZ4_NbCommonBytes(diff);
    }   }

    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
        pIn += LZ4_NbCommonBytes(diff);
        return (unsigned)(pIn - pStart);
    }

    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
    return (unsigned)(pIn - pStart);
}


#ifndef LZ4_COMMONDEFS_ONLY
/*-************************************
*  Local Constants
**************************************/
static const int LZ4_64Klimit = ((64 KB) + (MFLIMIT-1));
static const U32 LZ4_skipTrigger = 6;  /* Increase this value ==> compression run slower on incompressible data */


/*-************************************
*  Local Structures and types
**************************************/
typedef enum { clearedTable = 0, byPtr, byU32, byU16 } tableType_t;

/**
 * This enum distinguishes several different modes of accessing previous
 * content in the stream.
 *
 * - noDict        : There is no preceding content.
 * - withPrefix64k : Table entries up to ctx->dictSize before the current blob
 *                   blob being compressed are valid and refer to the preceding
 *                   content (of length ctx->dictSize), which is available
 *                   contiguously preceding in memory the content currently
 *                   being compressed.
 * - usingExtDict  : Like withPrefix64k, but the preceding content is somewhere
 *                   else in memory, starting at ctx->dictionary with length
 *                   ctx->dictSize.
 * - usingDictCtx  : Like usingExtDict, but everything concerning the preceding
 *                   content is in a separate context, pointed to by
 *                   ctx->dictCtx. ctx->dictionary, ctx->dictSize, and table
 *                   entries in the current context that refer to positions
 *                   preceding the beginning of the current compression are
 *                   ignored. Instead, ctx->dictCtx->dictionary and ctx->dictCtx
 *                   ->dictSize describe the location and size of the preceding
 *                   content, and matches are found by looking in the ctx
 *                   ->dictCtx->hashTable.
 */
typedef enum { noDict = 0, withPrefix64k, usingExtDict, usingDictCtx } dict_directive;
typedef enum { noDictIssue = 0, dictSmall } dictIssue_directive;


/*-************************************
*  Local Utils
**************************************/
int LZ4_versionNumber (void) { return LZ4_VERSION_NUMBER; }
const char* LZ4_versionString(void) { return LZ4_VERSION_STRING; }
int LZ4_compressBound(int isize)  { return LZ4_COMPRESSBOUND(isize); }
int LZ4_sizeofState(void) { return LZ4_STREAMSIZE; }


/*-************************************
*  Internal Definitions used in Tests
**************************************/
#if defined (__cplusplus)
extern "C" {
#endif

int LZ4_compress_forceExtDict (LZ4_stream_t* LZ4_dict, const char* source, char* dest, int srcSize);

int LZ4_decompress_safe_forceExtDict(const char* source, char* dest,
                                     int compressedSize, int maxOutputSize,
                                     const void* dictStart, size_t dictSize);

#if defined (__cplusplus)
}
#endif

/*-******************************
*  Compression functions
********************************/
LZ4_FORCE_INLINE U32 LZ4_hash4(U32 sequence, tableType_t const tableType)
{
    if (tableType == byU16)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
    else
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-LZ4_HASHLOG));
}

LZ4_FORCE_INLINE U32 LZ4_hash5(U64 sequence, tableType_t const tableType)
{
    const U32 hashLog = (tableType == byU16) ? LZ4_HASHLOG+1 : LZ4_HASHLOG;
    if (LZ4_isLittleEndian()) {
        const U64 prime5bytes = 889523592379ULL;
        return (U32)(((sequence << 24) * prime5bytes) >> (64 - hashLog));
    } else {
        const U64 prime8bytes = 11400714785074694791ULL;
        return (U32)(((sequence >> 24) * prime8bytes) >> (64 - hashLog));
    }
}

LZ4_FORCE_INLINE U32 LZ4_hashPosition(const void* const p, tableType_t const tableType)
{
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
    return LZ4_hash4(LZ4_read32(p), tableType);
}

LZ4_FORCE_INLINE void LZ4_clearHash(U32 h, void* tableBase, tableType_t const tableType)
{
    switch (tableType)
    {
    default: /* fallthrough */
    case clearedTable: { /* illegal! */ assert(0); return; }
    case byPtr: { const BYTE** hashTable = (const BYTE**)tableBase; hashTable[h] = NULL; return; }
    case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = 0; return; }
    case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = 0; return; }
    }
}

LZ4_FORCE_INLINE void LZ4_putIndexOnHash(U32 idx, U32 h, void* tableBase, tableType_t const tableType)
{
    switch (tableType)
    {
    default: /* fallthrough */
    case clearedTable: /* fallthrough */
    case byPtr: { /* illegal! */ assert(0); return; }
    case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
    case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
    }
}

LZ4_FORCE_INLINE void LZ4_putPositionOnHash(const BYTE* p, U32 h,
                                  void* tableBase, tableType_t const tableType,
                            const BYTE* srcBase)
{
    switch (tableType)
    {
    case clearedTable: { /* illegal! */ assert(0); return; }
    case byPtr: { const BYTE** hashTable = (const BYTE**)tableBase; hashTable[h] = p; return; }
    case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
    case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
    }
}

LZ4_FORCE_INLINE void LZ4_putPosition(const BYTE* p, void* tableBase, tableType_t tableType, const BYTE* srcBase)
{
    U32 const h = LZ4_hashPosition(p, tableType);
    LZ4_putPositionOnHash(p, h, tableBase, tableType, srcBase);
}

/* LZ4_getIndexOnHash() :
 * Index of match position registered in hash table.
 * hash position must be calculated by using base+index, or dictBase+index.
 * Assumption 1 : only valid if tableType == byU32 or byU16.
 * Assumption 2 : h is presumed valid (within limits of hash table)
 */
LZ4_FORCE_INLINE U32 LZ4_getIndexOnHash(U32 h, const void* tableBase, tableType_t tableType)
{
    LZ4_STATIC_ASSERT(LZ4_MEMORY_USAGE > 2);
    if (tableType == byU32) {
        const U32* const hashTable = (const U32*) tableBase;
        assert(h < (1U << (LZ4_MEMORY_USAGE-2)));
        return hashTable[h];
    }
    if (tableType == byU16) {
        const U16* const hashTable = (const U16*) tableBase;
        assert(h < (1U << (LZ4_MEMORY_USAGE-1)));
        return hashTable[h];
    }
    assert(0); return 0;  /* forbidden case */
}

static const BYTE* LZ4_getPositionOnHash(U32 h, const void* tableBase, tableType_t tableType, const BYTE* srcBase)
{
    if (tableType == byPtr) { const BYTE* const* hashTable = (const BYTE* const*) tableBase; return hashTable[h]; }
    if (tableType == byU32) { const U32* const hashTable = (const U32*) tableBase; return hashTable[h] + srcBase; }
    { const U16* const hashTable = (const U16*) tableBase; return hashTable[h] + srcBase; }   /* default, to ensure a return */
}

LZ4_FORCE_INLINE const BYTE*
LZ4_getPosition(const BYTE* p,
                const void* tableBase, tableType_t tableType,
                const BYTE* srcBase)
{
    U32 const h = LZ4_hashPosition(p, tableType);
    return LZ4_getPositionOnHash(h, tableBase, tableType, srcBase);
}

LZ4_FORCE_INLINE void
LZ4_prepareTable(LZ4_stream_t_internal* const cctx,
           const int inputSize,
           const tableType_t tableType) {
    /* If the table hasn't been used, it's guaranteed to be zeroed out, and is
     * therefore safe to use no matter what mode we're in. Otherwise, we figure
     * out if it's safe to leave as is or whether it needs to be reset.
     */
    if ((tableType_t)cctx->tableType != clearedTable) {
        assert(inputSize >= 0);
        if ((tableType_t)cctx->tableType != tableType
          || ((tableType == byU16) && cctx->currentOffset + (unsigned)inputSize >= 0xFFFFU)
          || ((tableType == byU32) && cctx->currentOffset > 1 GB)
          || tableType == byPtr
          || inputSize >= 4 KB)
        {
            DEBUGLOG(4, "LZ4_prepareTable: Resetting table in %p", cctx);
            MEM_INIT(cctx->hashTable, 0, LZ4_HASHTABLESIZE);
            cctx->currentOffset = 0;
            cctx->tableType = (U32)clearedTable;
        } else {
            DEBUGLOG(4, "LZ4_prepareTable: Re-use hash table (no reset)");
        }
    }

    /* Adding a gap, so all previous entries are > LZ4_DISTANCE_MAX back, is faster
     * than compressing without a gap. However, compressing with
     * currentOffset == 0 is faster still, so we preserve that case.
     */
    if (cctx->currentOffset != 0 && tableType == byU32) {
        DEBUGLOG(5, "LZ4_prepareTable: adding 64KB to currentOffset");
        cctx->currentOffset += 64 KB;
    }

    /* Finally, clear history */
    cctx->dictCtx = NULL;
    cctx->dictionary = NULL;
    cctx->dictSize = 0;
}

/** LZ4_compress_generic() :
 *  inlined, to ensure branches are decided at compilation time.
 *  Presumed already validated at this stage:
 *  - source != NULL
 *  - inputSize > 0
 */
LZ4_FORCE_INLINE int LZ4_compress_generic_validated(
                 LZ4_stream_t_internal* const cctx,
                 const char* const source,
                 char* const dest,
                 const int inputSize,
                 int *inputConsumed, /* only written when outputDirective == fillOutput */
                 const int maxOutputSize,
                 const limitedOutput_directive outputDirective,
                 const tableType_t tableType,
                 const dict_directive dictDirective,
                 const dictIssue_directive dictIssue,
                 const int acceleration)
{
    int result;
    const BYTE* ip = (const BYTE*) source;

    U32 const startIndex = cctx->currentOffset;
    const BYTE* base = (const BYTE*) source - startIndex;
    const BYTE* lowLimit;

    const LZ4_stream_t_internal* dictCtx = (const LZ4_stream_t_internal*) cctx->dictCtx;
    const BYTE* const dictionary =
        dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;
    const U32 dictSize =
        dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;
    const U32 dictDelta = (dictDirective == usingDictCtx) ? startIndex - dictCtx->currentOffset : 0;   /* make indexes in dictCtx comparable with index in current context */

    int const maybe_extMem = (dictDirective == usingExtDict) || (dictDirective == usingDictCtx);
    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */
    const BYTE* const dictEnd = dictionary ? dictionary + dictSize : dictionary;
    const BYTE* anchor = (const BYTE*) source;
    const BYTE* const iend = ip + inputSize;
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
    const BYTE* const matchlimit = iend - LASTLITERALS;

    /* the dictCtx currentOffset is indexed on the start of the dictionary,
     * while a dictionary in the current context precedes the currentOffset */
    const BYTE* dictBase = !dictionary ? NULL : (dictDirective == usingDictCtx) ?
                            dictionary + dictSize - dictCtx->currentOffset :
                            dictionary + dictSize - startIndex;

    BYTE* op = (BYTE*) dest;
    BYTE* const olimit = op + maxOutputSize;

    U32 offset = 0;
    U32 forwardH;

    DEBUGLOG(5, "LZ4_compress_generic_validated: srcSize=%i, tableType=%u", inputSize, tableType);
    assert(ip != NULL);
    /* If init conditions are not met, we don't have to mark stream
     * as having dirty context, since no action was taken yet */
    if (outputDirective == fillOutput && maxOutputSize < 1) { return 0; } /* Impossible to store anything */
    if ((tableType == byU16) && (inputSize>=LZ4_64Klimit)) { return 0; }  /* Size too large (not within 64K limit) */
    if (tableType==byPtr) assert(dictDirective==noDict);      /* only supported use case with byPtr */
    assert(acceleration >= 1);

    lowLimit = (const BYTE*)source - (dictDirective == withPrefix64k ? dictSize : 0);

    /* Update context state */
    if (dictDirective == usingDictCtx) {
        /* Subsequent linked blocks can't use the dictionary. */
        /* Instead, they use the block we just compressed. */
        cctx->dictCtx = NULL;
        cctx->dictSize = (U32)inputSize;
    } else {
        cctx->dictSize += (U32)inputSize;
    }
    cctx->currentOffset += (U32)inputSize;
    cctx->tableType = (U32)tableType;

    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */

    /* First Byte */
    LZ4_putPosition(ip, cctx->hashTable, tableType, base);
    ip++; forwardH = LZ4_hashPosition(ip, tableType);

    /* Main Loop */
    for ( ; ; ) {
        const BYTE* match;
        BYTE* token;
        const BYTE* filledIp;

        /* Find a match */
        if (tableType == byPtr) {
            const BYTE* forwardIp = ip;
            int step = 1;
            int searchMatchNb = acceleration << LZ4_skipTrigger;
            do {
                U32 const h = forwardH;
                ip = forwardIp;
                forwardIp += step;
                step = (searchMatchNb++ >> LZ4_skipTrigger);

                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
                assert(ip < mflimitPlusOne);

                match = LZ4_getPositionOnHash(h, cctx->hashTable, tableType, base);
                forwardH = LZ4_hashPosition(forwardIp, tableType);
                LZ4_putPositionOnHash(ip, h, cctx->hashTable, tableType, base);

            } while ( (match+LZ4_DISTANCE_MAX < ip)
                   || (LZ4_read32(match) != LZ4_read32(ip)) );

        } else {   /* byU32, byU16 */

            const BYTE* forwardIp = ip;
            int step = 1;
            int searchMatchNb = acceleration << LZ4_skipTrigger;
            do {
                U32 const h = forwardH;
                U32 const current = (U32)(forwardIp - base);
                U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);
                assert(matchIndex <= current);
                assert(forwardIp - base < (ptrdiff_t)(2 GB - 1));
                ip = forwardIp;
                forwardIp += step;
                step = (searchMatchNb++ >> LZ4_skipTrigger);

                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
                assert(ip < mflimitPlusOne);

                if (dictDirective == usingDictCtx) {
                    if (matchIndex < startIndex) {
                        /* there was no match, try the dictionary */
                        assert(tableType == byU32);
                        matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);
                        match = dictBase + matchIndex;
                        matchIndex += dictDelta;   /* make dictCtx index comparable with current context */
                        lowLimit = dictionary;
                    } else {
                        match = base + matchIndex;
                        lowLimit = (const BYTE*)source;
                    }
                } else if (dictDirective==usingExtDict) {
                    if (matchIndex < startIndex) {
                        DEBUGLOG(7, "extDict candidate: matchIndex=%5u  <  startIndex=%5u", matchIndex, startIndex);
                        assert(startIndex - matchIndex >= MINMATCH);
                        match = dictBase + matchIndex;
                        lowLimit = dictionary;
                    } else {
                        match = base + matchIndex;
                        lowLimit = (const BYTE*)source;
                    }
                } else {   /* single continuous memory segment */
                    match = base + matchIndex;
                }
                forwardH = LZ4_hashPosition(forwardIp, tableType);
                LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);

                DEBUGLOG(7, "candidate at pos=%u  (offset=%u \n", matchIndex, current - matchIndex);
                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) { continue; }    /* match outside of valid area */
                assert(matchIndex < current);
                if ( ((tableType != byU16) || (LZ4_DISTANCE_MAX < LZ4_DISTANCE_ABSOLUTE_MAX))
                  && (matchIndex+LZ4_DISTANCE_MAX < current)) {
                    continue;
                } /* too far */
                assert((current - matchIndex) <= LZ4_DISTANCE_MAX);  /* match now expected within distance */

                if (LZ4_read32(match) == LZ4_read32(ip)) {
                    if (maybe_extMem) offset = current - matchIndex;
                    break;   /* match found */
                }

            } while(1);
        }

        /* Catch up */
        filledIp = ip;
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }

        /* Encode Literals */
        {   unsigned const litLength = (unsigned)(ip - anchor);
            token = op++;
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
            }
            if ((outputDirective == fillOutput) &&
                (unlikely(op + (litLength+240)/255 /* litlen */ + litLength /* literals */ + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit))) {
                op--;
                goto _last_literals;
            }
            if (litLength >= RUN_MASK) {
                int len = (int)(litLength - RUN_MASK);
                *token = (RUN_MASK<<ML_BITS);
                for(; len >= 255 ; len-=255) *op++ = 255;
                *op++ = (BYTE)len;
            }
            else *token = (BYTE)(litLength<<ML_BITS);

            /* Copy Literals */
            LZ4_wildCopy8(op, anchor, op+litLength);
            op+=litLength;
            DEBUGLOG(6, "seq.start:%i, literals=%u, match.start:%i",
                        (int)(anchor-(const BYTE*)source), litLength, (int)(ip-(const BYTE*)source));
        }

_next_match:
        /* at this stage, the following variables must be correctly set :
         * - ip : at start of LZ operation
         * - match : at start of previous pattern occurence; can be within current prefix, or within extDict
         * - offset : if maybe_ext_memSegment==1 (constant)
         * - lowLimit : must be == dictionary to mean "match is within extDict"; must be == source otherwise
         * - token and *token : position to write 4-bits for match length; higher 4-bits for literal length supposed already written
         */

        if ((outputDirective == fillOutput) &&
            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {
            /* the match was too close to the end, rewind and go to last literals */
            op = token;
            goto _last_literals;
        }

        /* Encode Offset */
        if (maybe_extMem) {   /* static test */
            DEBUGLOG(6, "             with offset=%u  (ext if > %i)", offset, (int)(ip - (const BYTE*)source));
            assert(offset <= LZ4_DISTANCE_MAX && offset > 0);
            LZ4_writeLE16(op, (U16)offset); op+=2;
        } else  {
            DEBUGLOG(6, "             with offset=%u  (same segment)", (U32)(ip - match));
            assert(ip-match <= LZ4_DISTANCE_MAX);
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
        }

        /* Encode MatchLength */
        {   unsigned matchCode;

            if ( (dictDirective==usingExtDict || dictDirective==usingDictCtx)
              && (lowLimit==dictionary) /* match within extDict */ ) {
                const BYTE* limit = ip + (dictEnd-match);
                assert(dictEnd > match);
                if (limit > matchlimit) limit = matchlimit;
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
                ip += (size_t)matchCode + MINMATCH;
                if (ip==limit) {
                    unsigned const more = LZ4_count(limit, (const BYTE*)source, matchlimit);
                    matchCode += more;
                    ip += more;
                }
                DEBUGLOG(6, "             with matchLength=%u starting in extDict", matchCode+MINMATCH);
            } else {
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
                ip += (size_t)matchCode + MINMATCH;
                DEBUGLOG(6, "             with matchLength=%u", matchCode+MINMATCH);
            }

            if ((outputDirective) &&    /* Check output buffer overflow */
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
                if (outputDirective == fillOutput) {
                    /* Match description too long : reduce it */
                    U32 newMatchCode = 15 /* in token */ - 1 /* to avoid needing a zero byte */ + ((U32)(olimit - op) - 1 - LASTLITERALS) * 255;
                    ip -= matchCode - newMatchCode;
                    assert(newMatchCode < matchCode);
                    matchCode = newMatchCode;
                    if (unlikely(ip <= filledIp)) {
                        /* We have already filled up to filledIp so if ip ends up less than filledIp
                         * we have positions in the hash table beyond the current position. This is
                         * a problem if we reuse the hash table. So we have to remove these positions
                         * from the hash table.
                         */
                        const BYTE* ptr;
                        DEBUGLOG(5, "Clearing %u positions", (U32)(filledIp - ip));
                        for (ptr = ip; ptr <= filledIp; ++ptr) {
                            U32 const h = LZ4_hashPosition(ptr, tableType);
                            LZ4_clearHash(h, cctx->hashTable, tableType);
                        }
                    }
                } else {
                    assert(outputDirective == limitedOutput);
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
                }
            }
            if (matchCode >= ML_MASK) {
                *token += ML_MASK;
                matchCode -= ML_MASK;
                LZ4_write32(op, 0xFFFFFFFF);
                while (matchCode >= 4*255) {
                    op+=4;
                    LZ4_write32(op, 0xFFFFFFFF);
                    matchCode -= 4*255;
                }
                op += matchCode / 255;
                *op++ = (BYTE)(matchCode % 255);
            } else
                *token += (BYTE)(matchCode);
        }
        /* Ensure we have enough space for the last literals. */
        assert(!(outputDirective == fillOutput && op + 1 + LASTLITERALS > olimit));

        anchor = ip;

        /* Test end of chunk */
        if (ip >= mflimitPlusOne) break;

        /* Fill table */
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);

        /* Test next position */
        if (tableType == byPtr) {

            match = LZ4_getPosition(ip, cctx->hashTable, tableType, base);
            LZ4_putPosition(ip, cctx->hashTable, tableType, base);
            if ( (match+LZ4_DISTANCE_MAX >= ip)
              && (LZ4_read32(match) == LZ4_read32(ip)) )
            { token=op++; *token=0; goto _next_match; }

        } else {   /* byU32, byU16 */

            U32 const h = LZ4_hashPosition(ip, tableType);
            U32 const current = (U32)(ip-base);
            U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);
            assert(matchIndex < current);
            if (dictDirective == usingDictCtx) {
                if (matchIndex < startIndex) {
                    /* there was no match, try the dictionary */
                    matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);
                    match = dictBase + matchIndex;
                    lowLimit = dictionary;   /* required for match length counter */
                    matchIndex += dictDelta;
                } else {
                    match = base + matchIndex;
                    lowLimit = (const BYTE*)source;  /* required for match length counter */
                }
            } else if (dictDirective==usingExtDict) {
                if (matchIndex < startIndex) {
                    match = dictBase + matchIndex;
                    lowLimit = dictionary;   /* required for match length counter */
                } else {
                    match = base + matchIndex;
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
                }
            } else {   /* single memory segment */
                match = base + matchIndex;
            }
            LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);
            assert(matchIndex < current);
            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)
              && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
              && (LZ4_read32(match) == LZ4_read32(ip)) ) {
                token=op++;
                *token=0;
                if (maybe_extMem) offset = current - matchIndex;
                DEBUGLOG(6, "seq.start:%i, literals=%u, match.start:%i",
                            (int)(anchor-(const BYTE*)source), 0, (int)(ip-(const BYTE*)source));
                goto _next_match;
            }
        }

        /* Prepare next loop */
        forwardH = LZ4_hashPosition(++ip, tableType);

    }

_last_literals:
    /* Encode Last Literals */
    {   size_t lastRun = (size_t)(iend - anchor);
        if ( (outputDirective) &&  /* Check output buffer overflow */
            (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
            if (outputDirective == fillOutput) {
                /* adapt lastRun to fill 'dst' */
                assert(olimit >= op);
                lastRun  = (size_t)(olimit-op) - 1/*token*/;
                lastRun -= (lastRun + 256 - RUN_MASK) / 256;  /*additional length tokens*/
            } else {
                assert(outputDirective == limitedOutput);
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
            }
        }
        DEBUGLOG(6, "Final literal run : %i literals", (int)lastRun);
        if (lastRun >= RUN_MASK) {
            size_t accumulator = lastRun - RUN_MASK;
            *op++ = RUN_MASK << ML_BITS;
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
            *op++ = (BYTE) accumulator;
        } else {
            *op++ = (BYTE)(lastRun<<ML_BITS);
        }
        LZ4_memcpy(op, anchor, lastRun);
        ip = anchor + lastRun;
        op += lastRun;
    }

    if (outputDirective == fillOutput) {
        *inputConsumed = (int) (((const char*)ip)-source);
    }
    result = (int)(((char*)op) - dest);
    assert(result > 0);
    DEBUGLOG(5, "LZ4_compress_generic: compressed %i bytes into %i bytes", inputSize, result);
    return result;
}

/** LZ4_compress_generic() :
 *  inlined, to ensure branches are decided at compilation time;
 *  takes care of src == (NULL, 0)
 *  and forward the rest to LZ4_compress_generic_validated */
LZ4_FORCE_INLINE int LZ4_compress_generic(
                 LZ4_stream_t_internal* const cctx,
                 const char* const src,
                 char* const dst,
                 const int srcSize,
                 int *inputConsumed, /* only written when outputDirective == fillOutput */
                 const int dstCapacity,
                 const limitedOutput_directive outputDirective,
                 const tableType_t tableType,
                 const dict_directive dictDirective,
                 const dictIssue_directive dictIssue,
                 const int acceleration)
{
    DEBUGLOG(5, "LZ4_compress_generic: srcSize=%i, dstCapacity=%i",
                srcSize, dstCapacity);

    if ((U32)srcSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }  /* Unsupported srcSize, too large (or negative) */
    if (srcSize == 0) {   /* src == NULL supported if srcSize == 0 */
        if (outputDirective != notLimited && dstCapacity <= 0) return 0;  /* no output, can't write anything */
        DEBUGLOG(5, "Generating an empty block");
        assert(outputDirective == notLimited || dstCapacity >= 1);
        assert(dst != NULL);
        dst[0] = 0;
        if (outputDirective == fillOutput) {
            assert (inputConsumed != NULL);
            *inputConsumed = 0;
        }
        return 1;
    }
    assert(src != NULL);

    return LZ4_compress_generic_validated(cctx, src, dst, srcSize,
                inputConsumed, /* only written into if outputDirective == fillOutput */
                dstCapacity, outputDirective,
                tableType, dictDirective, dictIssue, acceleration);
}


int LZ4_compress_fast_extState(void* state, const char* source, char* dest, int inputSize, int maxOutputSize, int acceleration)
{
    LZ4_stream_t_internal* const ctx = & LZ4_initStream(state, sizeof(LZ4_stream_t)) -> internal_donotuse;
    assert(ctx != NULL);
    if (acceleration < 1) acceleration = LZ4_ACCELERATION_DEFAULT;
    if (acceleration > LZ4_ACCELERATION_MAX) acceleration = LZ4_ACCELERATION_MAX;
    if (maxOutputSize >= LZ4_compressBound(inputSize)) {
        if (inputSize < LZ4_64Klimit) {
            return LZ4_compress_generic(ctx, source, dest, inputSize, NULL, 0, notLimited, byU16, noDict, noDictIssue, acceleration);
        } else {
            const tableType_t tableType = ((sizeof(void*)==4) && ((uptrval)source > LZ4_DISTANCE_MAX)) ? byPtr : byU32;
            return LZ4_compress_generic(ctx, source, dest, inputSize, NULL, 0, notLimited, tableType, noDict, noDictIssue, acceleration);
        }
    } else {
        if (inputSize < LZ4_64Klimit) {
            return LZ4_compress_generic(ctx, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, byU16, noDict, noDictIssue, acceleration);
        } else {
            const tableType_t tableType = ((sizeof(void*)==4) && ((uptrval)source > LZ4_DISTANCE_MAX)) ? byPtr : byU32;
            return LZ4_compress_generic(ctx, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, noDict, noDictIssue, acceleration);
        }
    }
}

/**
 * LZ4_compress_fast_extState_fastReset() :
 * A variant of LZ4_compress_fast_extState().
 *
 * Using this variant avoids an expensive initialization step. It is only safe
 * to call if the state buffer is known to be correctly initialized already
 * (see comment in lz4.h on LZ4_resetStream_fast() for a definition of
 * "correctly initialized").
 */
int LZ4_compress_fast_extState_fastReset(void* state, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration)
{
    LZ4_stream_t_internal* ctx = &((LZ4_stream_t*)state)->internal_donotuse;
    if (acceleration < 1) acceleration = LZ4_ACCELERATION_DEFAULT;
    if (acceleration > LZ4_ACCELERATION_MAX) acceleration = LZ4_ACCELERATION_MAX;

    if (dstCapacity >= LZ4_compressBound(srcSize)) {
        if (srcSize < LZ4_64Klimit) {
            const tableType_t tableType = byU16;
            LZ4_prepareTable(ctx, srcSize, tableType);
            if (ctx->currentOffset) {
                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, 0, notLimited, tableType, noDict, dictSmall, acceleration);
            } else {
                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, 0, notLimited, tableType, noDict, noDictIssue, acceleration);
            }
        } else {
            const tableType_t tableType = ((sizeof(void*)==4) && ((uptrval)src > LZ4_DISTANCE_MAX)) ? byPtr : byU32;
            LZ4_prepareTable(ctx, srcSize, tableType);
            return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, 0, notLimited, tableType, noDict, noDictIssue, acceleration);
        }
    } else {
        if (srcSize < LZ4_64Klimit) {
            const tableType_t tableType = byU16;
            LZ4_prepareTable(ctx, srcSize, tableType);
            if (ctx->currentOffset) {
                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, dstCapacity, limitedOutput, tableType, noDict, dictSmall, acceleration);
            } else {
                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, dstCapacity, limitedOutput, tableType, noDict, noDictIssue, acceleration);
            }
        } else {
            const tableType_t tableType = ((sizeof(void*)==4) && ((uptrval)src > LZ4_DISTANCE_MAX)) ? byPtr : byU32;
            LZ4_prepareTable(ctx, srcSize, tableType);
            return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, dstCapacity, limitedOutput, tableType, noDict, noDictIssue, acceleration);
        }
    }
}


int LZ4_compress_fast(const char* source, char* dest, int inputSize, int maxOutputSize, int acceleration)
{
    int result;
#if (LZ4_HEAPMODE)
    LZ4_stream_t* ctxPtr = ALLOC(sizeof(LZ4_stream_t));   /* malloc-calloc always properly aligned */
    if (ctxPtr == NULL) return 0;
#else
    LZ4_stream_t ctx;
    LZ4_stream_t* const ctxPtr = &ctx;
#endif
    result = LZ4_compress_fast_extState(ctxPtr, source, dest, inputSize, maxOutputSize, acceleration);

#if (LZ4_HEAPMODE)
    FREEMEM(ctxPtr);
#endif
    return result;
}


int LZ4_compress_default(const char* src, char* dst, int srcSize, int maxOutputSize)
{
    return LZ4_compress_fast(src, dst, srcSize, maxOutputSize, 1);
}


/* Note!: This function leaves the stream in an unclean/broken state!
 * It is not safe to subsequently use the same state with a _fastReset() or
 * _continue() call without resetting it. */
static int LZ4_compress_destSize_extState (LZ4_stream_t* state, const char* src, char* dst, int* srcSizePtr, int targetDstSize)
{
    void* const s = LZ4_initStream(state, sizeof (*state));
    assert(s != NULL); (void)s;

    if (targetDstSize >= LZ4_compressBound(*srcSizePtr)) {  /* compression success is guaranteed */
        return LZ4_compress_fast_extState(state, src, dst, *srcSizePtr, targetDstSize, 1);
    } else {
        if (*srcSizePtr < LZ4_64Klimit) {
            return LZ4_compress_generic(&state->internal_donotuse, src, dst, *srcSizePtr, srcSizePtr, targetDstSize, fillOutput, byU16, noDict, noDictIssue, 1);
        } else {
            tableType_t const addrMode = ((sizeof(void*)==4) && ((uptrval)src > LZ4_DISTANCE_MAX)) ? byPtr : byU32;
            return LZ4_compress_generic(&state->internal_donotuse, src, dst, *srcSizePtr, srcSizePtr, targetDstSize, fillOutput, addrMode, noDict, noDictIssue, 1);
    }   }
}


int LZ4_compress_destSize(const char* src, char* dst, int* srcSizePtr, int targetDstSize)
{
#if (LZ4_HEAPMODE)
    LZ4_stream_t* ctx = (LZ4_stream_t*)ALLOC(sizeof(LZ4_stream_t));   /* malloc-calloc always properly aligned */
    if (ctx == NULL) return 0;
#else
    LZ4_stream_t ctxBody;
    LZ4_stream_t* ctx = &ctxBody;
#endif

    int result = LZ4_compress_destSize_extState(ctx, src, dst, srcSizePtr, targetDstSize);

#if (LZ4_HEAPMODE)
    FREEMEM(ctx);
#endif
    return result;
}



/*-******************************
*  Streaming functions
********************************/

LZ4_stream_t* LZ4_createStream(void)
{
    LZ4_stream_t* const lz4s = (LZ4_stream_t*)ALLOC(sizeof(LZ4_stream_t));
    LZ4_STATIC_ASSERT(LZ4_STREAMSIZE >= sizeof(LZ4_stream_t_internal));    /* A compilation error here means LZ4_STREAMSIZE is not large enough */
    DEBUGLOG(4, "LZ4_createStream %p", lz4s);
    if (lz4s == NULL) return NULL;
    LZ4_initStream(lz4s, sizeof(*lz4s));
    return lz4s;
}

static size_t LZ4_stream_t_alignment(void)
{
#if LZ4_ALIGN_TEST
    typedef struct { char c; LZ4_stream_t t; } t_a;
    return sizeof(t_a) - sizeof(LZ4_stream_t);
#else
    return 1;  /* effectively disabled */
#endif
}

LZ4_stream_t* LZ4_initStream (void* buffer, size_t size)
{
    DEBUGLOG(5, "LZ4_initStream");
    if (buffer == NULL) { return NULL; }
    if (size < sizeof(LZ4_stream_t)) { return NULL; }
    if (!LZ4_isAligned(buffer, LZ4_stream_t_alignment())) return NULL;
    MEM_INIT(buffer, 0, sizeof(LZ4_stream_t_internal));
    return (LZ4_stream_t*)buffer;
}

/* resetStream is now deprecated,
 * prefer initStream() which is more general */
void LZ4_resetStream (LZ4_stream_t* LZ4_stream)
{
    DEBUGLOG(5, "LZ4_resetStream (ctx:%p)", LZ4_stream);
    MEM_INIT(LZ4_stream, 0, sizeof(LZ4_stream_t_internal));
}

void LZ4_resetStream_fast(LZ4_stream_t* ctx) {
    LZ4_prepareTable(&(ctx->internal_donotuse), 0, byU32);
}

int LZ4_freeStream (LZ4_stream_t* LZ4_stream)
{
    if (!LZ4_stream) return 0;   /* support free on NULL */
    DEBUGLOG(5, "LZ4_freeStream %p", LZ4_stream);
    FREEMEM(LZ4_stream);
    return (0);
}


#define HASH_UNIT sizeof(reg_t)
int LZ4_loadDict (LZ4_stream_t* LZ4_dict, const char* dictionary, int dictSize)
{
    LZ4_stream_t_internal* dict = &LZ4_dict->internal_donotuse;
    const tableType_t tableType = byU32;
    const BYTE* p = (const BYTE*)dictionary;
    const BYTE* const dictEnd = p + dictSize;
    const BYTE* base;

    DEBUGLOG(4, "LZ4_loadDict (%i bytes from %p into %p)", dictSize, dictionary, LZ4_dict);

    /* It's necessary to reset the context,
     * and not just continue it with prepareTable()
     * to avoid any risk of generating overflowing matchIndex
     * when compressing using this dictionary */
    LZ4_resetStream(LZ4_dict);

    /* We always increment the offset by 64 KB, since, if the dict is longer,
     * we truncate it to the last 64k, and if it's shorter, we still want to
     * advance by a whole window length so we can provide the guarantee that
     * there are only valid offsets in the window, which allows an optimization
     * in LZ4_compress_fast_continue() where it uses noDictIssue even when the
     * dictionary isn't a full 64k. */
    dict->currentOffset += 64 KB;

    if (dictSize < (int)HASH_UNIT) {
        return 0;
    }

    if ((dictEnd - p) > 64 KB) p = dictEnd - 64 KB;
    base = dictEnd - dict->currentOffset;
    dict->dictionary = p;
    dict->dictSize = (U32)(dictEnd - p);
    dict->tableType = (U32)tableType;

    while (p <= dictEnd-HASH_UNIT) {
        LZ4_putPosition(p, dict->hashTable, tableType, base);
        p+=3;
    }

    return (int)dict->dictSize;
}

void LZ4_attach_dictionary(LZ4_stream_t* workingStream, const LZ4_stream_t* dictionaryStream) {
    const LZ4_stream_t_internal* dictCtx = dictionaryStream == NULL ? NULL :
        &(dictionaryStream->internal_donotuse);

    DEBUGLOG(4, "LZ4_attach_dictionary (%p, %p, size %u)",
             workingStream, dictionaryStream,
             dictCtx != NULL ? dictCtx->dictSize : 0);

    if (dictCtx != NULL) {
        /* If the current offset is zero, we will never look in the
         * external dictionary context, since there is no value a table
         * entry can take that indicate a miss. In that case, we need
         * to bump the offset to something non-zero.
         */
        if (workingStream->internal_donotuse.currentOffset == 0) {
            workingStream->internal_donotuse.currentOffset = 64 KB;
        }

        /* Don't actually attach an empty dictionary.
         */
        if (dictCtx->dictSize == 0) {
            dictCtx = NULL;
        }
    }
    workingStream->internal_donotuse.dictCtx = dictCtx;
}


static void LZ4_renormDictT(LZ4_stream_t_internal* LZ4_dict, int nextSize)
{
    assert(nextSize >= 0);
    if (LZ4_dict->currentOffset + (unsigned)nextSize > 0x80000000) {   /* potential ptrdiff_t overflow (32-bits mode) */
        /* rescale hash table */
        U32 const delta = LZ4_dict->currentOffset - 64 KB;
        const BYTE* dictEnd = LZ4_dict->dictionary + LZ4_dict->dictSize;
        int i;
        DEBUGLOG(4, "LZ4_renormDictT");
        for (i=0; i<LZ4_HASH_SIZE_U32; i++) {
            if (LZ4_dict->hashTable[i] < delta) LZ4_dict->hashTable[i]=0;
            else LZ4_dict->hashTable[i] -= delta;
        }
        LZ4_dict->currentOffset = 64 KB;
        if (LZ4_dict->dictSize > 64 KB) LZ4_dict->dictSize = 64 KB;
        LZ4_dict->dictionary = dictEnd - LZ4_dict->dictSize;
    }
}


int LZ4_compress_fast_continue (LZ4_stream_t* LZ4_stream,
                                const char* source, char* dest,
                                int inputSize, int maxOutputSize,
                                int acceleration)
{
    const tableType_t tableType = byU32;
    LZ4_stream_t_internal* streamPtr = &LZ4_stream->internal_donotuse;
    const BYTE* dictEnd = streamPtr->dictionary + streamPtr->dictSize;

    DEBUGLOG(5, "LZ4_compress_fast_continue (inputSize=%i)", inputSize);

    LZ4_renormDictT(streamPtr, inputSize);   /* avoid index overflow */
    if (acceleration < 1) acceleration = LZ4_ACCELERATION_DEFAULT;
    if (acceleration > LZ4_ACCELERATION_MAX) acceleration = LZ4_ACCELERATION_MAX;

    /* invalidate tiny dictionaries */
    if ( (streamPtr->dictSize-1 < 4-1)   /* intentional underflow */
      && (dictEnd != (const BYTE*)source) ) {
        DEBUGLOG(5, "LZ4_compress_fast_continue: dictSize(%u) at addr:%p is too small", streamPtr->dictSize, streamPtr->dictionary);
        streamPtr->dictSize = 0;
        streamPtr->dictionary = (const BYTE*)source;
        dictEnd = (const BYTE*)source;
    }

    /* Check overlapping input/dictionary space */
    {   const BYTE* sourceEnd = (const BYTE*) source + inputSize;
        if ((sourceEnd > streamPtr->dictionary) && (sourceEnd < dictEnd)) {
            streamPtr->dictSize = (U32)(dictEnd - sourceEnd);
            if (streamPtr->dictSize > 64 KB) streamPtr->dictSize = 64 KB;
            if (streamPtr->dictSize < 4) streamPtr->dictSize = 0;
            streamPtr->dictionary = dictEnd - streamPtr->dictSize;
        }
    }

    /* prefix mode : source data follows dictionary */
    if (dictEnd == (const BYTE*)source) {
        if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset))
            return LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, withPrefix64k, dictSmall, acceleration);
        else
            return LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, withPrefix64k, noDictIssue, acceleration);
    }

    /* external dictionary mode */
    {   int result;
        if (streamPtr->dictCtx) {
            /* We depend here on the fact that dictCtx'es (produced by
             * LZ4_loadDict) guarantee that their tables contain no references
             * to offsets between dictCtx->currentOffset - 64 KB and
             * dictCtx->currentOffset - dictCtx->dictSize. This makes it safe
             * to use noDictIssue even when the dict isn't a full 64 KB.
             */
            if (inputSize > 4 KB) {
                /* For compressing large blobs, it is faster to pay the setup
                 * cost to copy the dictionary's tables into the active context,
                 * so that the compression loop is only looking into one table.
                 */
                LZ4_memcpy(streamPtr, streamPtr->dictCtx, sizeof(*streamPtr));
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingExtDict, noDictIssue, acceleration);
            } else {
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingDictCtx, noDictIssue, acceleration);
            }
        } else {
            if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset)) {
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingExtDict, dictSmall, acceleration);
            } else {
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingExtDict, noDictIssue, acceleration);
            }
        }
        streamPtr->dictionary = (const BYTE*)source;
        streamPtr->dictSize = (U32)inputSize;
        return result;
    }
}


/* Hidden debug function, to force-test external dictionary mode */
int LZ4_compress_forceExtDict (LZ4_stream_t* LZ4_dict, const char* source, char* dest, int srcSize)
{
    LZ4_stream_t_internal* streamPtr = &LZ4_dict->internal_donotuse;
    int result;

    LZ4_renormDictT(streamPtr, srcSize);

    if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset)) {
        result = LZ4_compress_generic(streamPtr, source, dest, srcSize, NULL, 0, notLimited, byU32, usingExtDict, dictSmall, 1);
    } else {
        result = LZ4_compress_generic(streamPtr, source, dest, srcSize, NULL, 0, notLimited, byU32, usingExtDict, noDictIssue, 1);
    }

    streamPtr->dictionary = (const BYTE*)source;
    streamPtr->dictSize = (U32)srcSize;

    return result;
}


/*! LZ4_saveDict() :
 *  If previously compressed data block is not guaranteed to remain available at its memory location,
 *  save it into a safer place (char* safeBuffer).
 *  Note : you don't need to call LZ4_loadDict() afterwards,
 *         dictionary is immediately usable, you can therefore call LZ4_compress_fast_continue().
 *  Return : saved dictionary size in bytes (necessarily <= dictSize), or 0 if error.
 */
int LZ4_saveDict (LZ4_stream_t* LZ4_dict, char* safeBuffer, int dictSize)
{
    LZ4_stream_t_internal* const dict = &LZ4_dict->internal_donotuse;
    const BYTE* const previousDictEnd = dict->dictionary + dict->dictSize;

    if ((U32)dictSize > 64 KB) { dictSize = 64 KB; } /* useless to define a dictionary > 64 KB */
    if ((U32)dictSize > dict->dictSize) { dictSize = (int)dict->dictSize; }

    if (safeBuffer == NULL) assert(dictSize == 0);
    if (safeBuffer && dictSize > 0)
        memmove(safeBuffer, previousDictEnd - dictSize, dictSize);

    dict->dictionary = (const BYTE*)safeBuffer;
    dict->dictSize = (U32)dictSize;

    return dictSize;
}



/*-*******************************
 *  Decompression functions
 ********************************/

typedef enum { endOnOutputSize = 0, endOnInputSize = 1 } endCondition_directive;
typedef enum { decode_full_block = 0, partial_decode = 1 } earlyEnd_directive;

#undef MIN
#define MIN(a,b)    ( (a) < (b) ? (a) : (b) )

/* Read the variable-length literal or match length.
 *
 * ip - pointer to use as input.
 * lencheck - end ip.  Return an error if ip advances >= lencheck.
 * loop_check - check ip >= lencheck in body of loop.  Returns loop_error if so.
 * initial_check - check ip >= lencheck before start of loop.  Returns initial_error if so.
 * error (output) - error code.  Should be set to 0 before call.
 */
typedef enum { loop_error = -2, initial_error = -1, ok = 0 } variable_length_error;
LZ4_FORCE_INLINE unsigned
read_variable_length(const BYTE**ip, const BYTE* lencheck,
                     int loop_check, int initial_check,
                     variable_length_error* error)
{
    U32 length = 0;
    U32 s;
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
        *error = initial_error;
        return length;
    }
    do {
        s = **ip;
        (*ip)++;
        length += s;
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
            *error = loop_error;
            return length;
        }
    } while (s==255);

    return length;
}

/*! LZ4_decompress_generic() :
 *  This generic decompression function covers all use cases.
 *  It shall be instantiated several times, using different sets of directives.
 *  Note that it is important for performance that this function really get inlined,
 *  in order to remove useless branches during compilation optimization.
 */
LZ4_FORCE_INLINE int
LZ4_decompress_generic(
                 const char* const src,
                 char* const dst,
                 int srcSize,
                 int outputSize,         /* If endOnInput==endOnInputSize, this value is `dstCapacity` */

                 endCondition_directive endOnInput,   /* endOnOutputSize, endOnInputSize */
                 earlyEnd_directive partialDecoding,  /* full, partial */
                 dict_directive dict,                 /* noDict, withPrefix64k, usingExtDict */
                 const BYTE* const lowPrefix,  /* always <= dst, == dst when no prefix */
                 const BYTE* const dictStart,  /* only if dict==usingExtDict */
                 const size_t dictSize         /* note : = 0 if noDict */
                 )
{
    if (src == NULL) { return -1; }

    {   const BYTE* ip = (const BYTE*) src;
        const BYTE* const iend = ip + srcSize;

        BYTE* op = (BYTE*) dst;
        BYTE* const oend = op + outputSize;
        BYTE* cpy;

        const BYTE* const dictEnd = (dictStart == NULL) ? NULL : dictStart + dictSize;

        const int safeDecode = (endOnInput==endOnInputSize);
        const int checkOffset = ((safeDecode) && (dictSize < (int)(64 KB)));


        /* Set up the "end" pointers for the shortcut. */
        const BYTE* const shortiend = iend - (endOnInput ? 14 : 8) /*maxLL*/ - 2 /*offset*/;
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;

        const BYTE* match;
        size_t offset;
        unsigned token;
        size_t length;


        DEBUGLOG(5, "LZ4_decompress_generic (srcSize:%i, dstSize:%i)", srcSize, outputSize);

        /* Special cases */
        assert(lowPrefix <= op);
        if ((endOnInput) && (unlikely(outputSize==0))) {
            /* Empty output buffer */
            if (partialDecoding) return 0;
            return ((srcSize==1) && (*ip==0)) ? 0 : -1;
        }
        if ((!endOnInput) && (unlikely(outputSize==0))) { return (*ip==0 ? 1 : -1); }
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }

	/* Currently the fast loop shows a regression on qualcomm arm chips. */
#if LZ4_FAST_DEC_LOOP
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
            DEBUGLOG(6, "skip fast decode loop");
            goto safe_decode;
        }

        /* Fast loop : decode sequences as long as output < iend-FASTLOOP_SAFE_DISTANCE */
        while (1) {
            /* Main fastloop assertion: We can always wildcopy FASTLOOP_SAFE_DISTANCE */
            assert(oend - op >= FASTLOOP_SAFE_DISTANCE);
            if (endOnInput) { assert(ip < iend); }
            token = *ip++;
            length = token >> ML_BITS;  /* literal length */

            assert(!endOnInput || ip <= iend); /* ip < iend before the increment */

            /* decode literal length */
            if (length == RUN_MASK) {
                variable_length_error error = ok;
                length += read_variable_length(&ip, iend-RUN_MASK, (int)endOnInput, (int)endOnInput, &error);
                if (error == initial_error) { goto _output_error; }
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */

                /* copy literals */
                cpy = op+length;
                LZ4_STATIC_ASSERT(MFLIMIT >= WILDCOPYLENGTH);
                if (endOnInput) {  /* LZ4_decompress_safe() */
                    if ((cpy>oend-32) || (ip+length>iend-32)) { goto safe_literal_copy; }
                    LZ4_wildCopy32(op, ip, cpy);
                } else {   /* LZ4_decompress_fast() */
                    if (cpy>oend-8) { goto safe_literal_copy; }
                    LZ4_wildCopy8(op, ip, cpy); /* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
                                                 * it doesn't know input length, and only relies on end-of-block properties */
                }
                ip += length; op = cpy;
            } else {
                cpy = op+length;
                if (endOnInput) {  /* LZ4_decompress_safe() */
                    DEBUGLOG(7, "copy %u bytes in a 16-bytes stripe", (unsigned)length);
                    /* We don't need to check oend, since we check it once for each loop below */
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
                    /* Literals can only be 14, but hope compilers optimize if we copy by a register size */
                    LZ4_memcpy(op, ip, 16);
                } else {  /* LZ4_decompress_fast() */
                    /* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
                     * it doesn't know input length, and relies on end-of-block properties */
                    LZ4_memcpy(op, ip, 8);
                    if (length > 8) { LZ4_memcpy(op+8, ip+8, 8); }
                }
                ip += length; op = cpy;
            }

            /* get offset */
            offset = LZ4_readLE16(ip); ip+=2;
            match = op - offset;
            assert(match <= op);

            /* get matchlength */
            length = token & ML_MASK;

            if (length == ML_MASK) {
                variable_length_error error = ok;
                if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, (int)endOnInput, 0, &error);
                if (error != ok) { goto _output_error; }
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) { goto _output_error; } /* overflow detection */
                length += MINMATCH;
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
                    goto safe_match_copy;
                }
            } else {
                length += MINMATCH;
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
                    goto safe_match_copy;
                }

                /* Fastpath check: Avoids a branch in LZ4_wildCopy32 if true */
                if ((dict == withPrefix64k) || (match >= lowPrefix)) {
                    if (offset >= 8) {
                        assert(match >= lowPrefix);
                        assert(match <= op);
                        assert(op + 18 <= oend);

                        LZ4_memcpy(op, match, 8);
                        LZ4_memcpy(op+8, match+8, 8);
                        LZ4_memcpy(op+16, match+16, 2);
                        op += length;
                        continue;
            }   }   }

            if (checkOffset && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
            /* match starting within external dictionary */
            if ((dict==usingExtDict) && (match < lowPrefix)) {
                if (unlikely(op+length > oend-LASTLITERALS)) {
                    if (partialDecoding) {
                        DEBUGLOG(7, "partialDecoding: dictionary match, close to dstEnd");
                        length = MIN(length, (size_t)(oend-op));
                    } else {
                        goto _output_error;  /* end-of-block condition violated */
                }   }

                if (length <= (size_t)(lowPrefix-match)) {
                    /* match fits entirely within external dictionary : just copy */
                    memmove(op, dictEnd - (lowPrefix-match), length);
                    op += length;
                } else {
                    /* match stretches into both external dictionary and current block */
                    size_t const copySize = (size_t)(lowPrefix - match);
                    size_t const restSize = length - copySize;
                    LZ4_memcpy(op, dictEnd - copySize, copySize);
                    op += copySize;
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
                        BYTE* const endOfMatch = op + restSize;
                        const BYTE* copyFrom = lowPrefix;
                        while (op < endOfMatch) { *op++ = *copyFrom++; }
                    } else {
                        LZ4_memcpy(op, lowPrefix, restSize);
                        op += restSize;
                }   }
                continue;
            }

            /* copy match within block */
            cpy = op + length;

            assert((op <= oend) && (oend-op >= 32));
            if (unlikely(offset<16)) {
                LZ4_memcpy_using_offset(op, match, cpy, offset);
            } else {
                LZ4_wildCopy32(op, match, cpy);
            }

            op = cpy;   /* wildcopy correction */
        }
    safe_decode:
#endif

        /* Main Loop : decode remaining sequences where output < FASTLOOP_SAFE_DISTANCE */
        while (1) {
            token = *ip++;
            length = token >> ML_BITS;  /* literal length */

            assert(!endOnInput || ip <= iend); /* ip < iend before the increment */

            /* A two-stage shortcut for the most common case:
             * 1) If the literal length is 0..14, and there is enough space,
             * enter the shortcut and copy 16 bytes on behalf of the literals
             * (in the fast mode, only 8 bytes can be safely copied this way).
             * 2) Further if the match length is 4..18, copy 18 bytes in a similar
             * manner; but we ensure that there's enough space in the output for
             * those 18 bytes earlier, upon entering the shortcut (in other words,
             * there is a combined check for both stages).
             */
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
                /* strictly "less than" on input, to re-enter the loop with at least one byte */
              && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
                /* Copy the literals */
                LZ4_memcpy(op, ip, endOnInput ? 16 : 8);
                op += length; ip += length;

                /* The second stage: prepare for match copying, decode full info.
                 * If it doesn't work out, the info won't be wasted. */
                length = token & ML_MASK; /* match length */
                offset = LZ4_readLE16(ip); ip += 2;
                match = op - offset;
                assert(match <= op); /* check overflow */

                /* Do not deal with overlapping matches. */
                if ( (length != ML_MASK)
                  && (offset >= 8)
                  && (dict==withPrefix64k || match >= lowPrefix) ) {
                    /* Copy the match. */
                    LZ4_memcpy(op + 0, match + 0, 8);
                    LZ4_memcpy(op + 8, match + 8, 8);
                    LZ4_memcpy(op +16, match +16, 2);
                    op += length + MINMATCH;
                    /* Both stages worked, load the next token. */
                    continue;
                }

                /* The second stage didn't work out, but the info is ready.
                 * Propel it right to the point of match copying. */
                goto _copy_match;
            }

            /* decode literal length */
            if (length == RUN_MASK) {
                variable_length_error error = ok;
                length += read_variable_length(&ip, iend-RUN_MASK, (int)endOnInput, (int)endOnInput, &error);
                if (error == initial_error) { goto _output_error; }
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
            }

            /* copy literals */
            cpy = op+length;
#if LZ4_FAST_DEC_LOOP
        safe_literal_copy:
#endif
            LZ4_STATIC_ASSERT(MFLIMIT >= WILDCOPYLENGTH);
            if ( ((endOnInput) && ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) )
              || ((!endOnInput) && (cpy>oend-WILDCOPYLENGTH)) )
            {
                /* We've either hit the input parsing restriction or the output parsing restriction.
                 * In the normal scenario, decoding a full block, it must be the last sequence,
                 * otherwise it's an error (invalid input or dimensions).
                 * In partialDecoding scenario, it's necessary to ensure there is no buffer overflow.
                 */
                if (partialDecoding) {
                    /* Since we are partial decoding we may be in this block because of the output parsing
                     * restriction, which is not valid since the output buffer is allowed to be undersized.
                     */
                    assert(endOnInput);
                    DEBUGLOG(7, "partialDecoding: copying literals, close to input or output end")
                    DEBUGLOG(7, "partialDecoding: literal length = %u", (unsigned)length);
                    DEBUGLOG(7, "partialDecoding: remaining space in dstBuffer : %i", (int)(oend - op));
                    DEBUGLOG(7, "partialDecoding: remaining space in srcBuffer : %i", (int)(iend - ip));
                    /* Finishing in the middle of a literals segment,
                     * due to lack of input.
                     */
                    if (ip+length > iend) {
                        length = (size_t)(iend-ip);
                        cpy = op + length;
                    }
                    /* Finishing in the middle of a literals segment,
                     * due to lack of output space.
                     */
                    if (cpy > oend) {
                        cpy = oend;
                        assert(op<=oend);
                        length = (size_t)(oend-op);
                    }
                } else {
                    /* We must be on the last sequence because of the parsing limitations so check
                     * that we exactly regenerate the original size (must be exact when !endOnInput).
                     */
                    if ((!endOnInput) && (cpy != oend)) { goto _output_error; }
                     /* We must be on the last sequence (or invalid) because of the parsing limitations
                      * so check that we exactly consume the input and don't overrun the output buffer.
                      */
                    if ((endOnInput) && ((ip+length != iend) || (cpy > oend))) {
                        DEBUGLOG(6, "should have been last run of literals")
                        DEBUGLOG(6, "ip(%p) + length(%i) = %p != iend (%p)", ip, (int)length, ip+length, iend);
                        DEBUGLOG(6, "or cpy(%p) > oend(%p)", cpy, oend);
                        goto _output_error;
                    }
                }
                memmove(op, ip, length);  /* supports overlapping memory regions; only matters for in-place decompression scenarios */
                ip += length;
                op += length;
                /* Necessarily EOF when !partialDecoding.
                 * When partialDecoding, it is EOF if we've either
                 * filled the output buffer or
                 * can't proceed with reading an offset for following match.
                 */
                if (!partialDecoding || (cpy == oend) || (ip >= (iend-2))) {
                    break;
                }
            } else {
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
                ip += length; op = cpy;
            }

            /* get offset */
            offset = LZ4_readLE16(ip); ip+=2;
            match = op - offset;

            /* get matchlength */
            length = token & ML_MASK;

    _copy_match:
            if (length == ML_MASK) {
              variable_length_error error = ok;
              length += read_variable_length(&ip, iend - LASTLITERALS + 1, (int)endOnInput, 0, &error);
              if (error != ok) goto _output_error;
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
            }
            length += MINMATCH;

#if LZ4_FAST_DEC_LOOP
        safe_match_copy:
#endif
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
            /* match starting within external dictionary */
            if ((dict==usingExtDict) && (match < lowPrefix)) {
                if (unlikely(op+length > oend-LASTLITERALS)) {
                    if (partialDecoding) length = MIN(length, (size_t)(oend-op));
                    else goto _output_error;   /* doesn't respect parsing restriction */
                }

                if (length <= (size_t)(lowPrefix-match)) {
                    /* match fits entirely within external dictionary : just copy */
                    memmove(op, dictEnd - (lowPrefix-match), length);
                    op += length;
                } else {
                    /* match stretches into both external dictionary and current block */
                    size_t const copySize = (size_t)(lowPrefix - match);
                    size_t const restSize = length - copySize;
                    LZ4_memcpy(op, dictEnd - copySize, copySize);
                    op += copySize;
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
                        BYTE* const endOfMatch = op + restSize;
                        const BYTE* copyFrom = lowPrefix;
                        while (op < endOfMatch) *op++ = *copyFrom++;
                    } else {
                        LZ4_memcpy(op, lowPrefix, restSize);
                        op += restSize;
                }   }
                continue;
            }
            assert(match >= lowPrefix);

            /* copy match within block */
            cpy = op + length;

            /* partialDecoding : may end anywhere within the block */
            assert(op<=oend);
            if (partialDecoding && (cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
                size_t const mlen = MIN(length, (size_t)(oend-op));
                const BYTE* const matchEnd = match + mlen;
                BYTE* const copyEnd = op + mlen;
                if (matchEnd > op) {   /* overlap copy */
                    while (op < copyEnd) { *op++ = *match++; }
                } else {
                    LZ4_memcpy(op, match, mlen);
                }
                op = copyEnd;
                if (op == oend) { break; }
                continue;
            }

            if (unlikely(offset<8)) {
                LZ4_write32(op, 0);   /* silence msan warning when offset==0 */
                op[0] = match[0];
                op[1] = match[1];
                op[2] = match[2];
                op[3] = match[3];
                match += inc32table[offset];
                LZ4_memcpy(op+4, match, 4);
                match -= dec64table[offset];
            } else {
                LZ4_memcpy(op, match, 8);
                match += 8;
            }
            op += 8;

            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
                if (op < oCopyLimit) {
                    LZ4_wildCopy8(op, match, oCopyLimit);
                    match += oCopyLimit - op;
                    op = oCopyLimit;
                }
                while (op < cpy) { *op++ = *match++; }
            } else {
                LZ4_memcpy(op, match, 8);
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
            }
            op = cpy;   /* wildcopy correction */
        }

        /* end of decoding */
        if (endOnInput) {
            DEBUGLOG(5, "decoded %i bytes", (int) (((char*)op)-dst));
           return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
       } else {
           return (int) (((const char*)ip)-src);   /* Nb of input bytes read */
       }

        /* Overflow error detected */
    _output_error:
        return (int) (-(((const char*)ip)-src))-1;
    }
}


/*===== Instantiate the API decoding functions. =====*/

LZ4_FORCE_O2
int LZ4_decompress_safe(const char* source, char* dest, int compressedSize, int maxDecompressedSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize,
                                  endOnInputSize, decode_full_block, noDict,
                                  (BYTE*)dest, NULL, 0);
}

LZ4_FORCE_O2
int LZ4_decompress_safe_partial(const char* src, char* dst, int compressedSize, int targetOutputSize, int dstCapacity)
{
    dstCapacity = MIN(targetOutputSize, dstCapacity);
    return LZ4_decompress_generic(src, dst, compressedSize, dstCapacity,
                                  endOnInputSize, partial_decode,
                                  noDict, (BYTE*)dst, NULL, 0);
}

LZ4_FORCE_O2
int LZ4_decompress_fast(const char* source, char* dest, int originalSize)
{
    return LZ4_decompress_generic(source, dest, 0, originalSize,
                                  endOnOutputSize, decode_full_block, withPrefix64k,
                                  (BYTE*)dest - 64 KB, NULL, 0);
}

/*===== Instantiate a few more decoding cases, used more than once. =====*/

LZ4_FORCE_O2 /* Exported, an obsolete API function. */
int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int compressedSize, int maxOutputSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  endOnInputSize, decode_full_block, withPrefix64k,
                                  (BYTE*)dest - 64 KB, NULL, 0);
}

/* Another obsolete API function, paired with the previous one. */
int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int originalSize)
{
    /* LZ4_decompress_fast doesn't validate match offsets,
     * and thus serves well with any prefixed dictionary. */
    return LZ4_decompress_fast(source, dest, originalSize);
}

LZ4_FORCE_O2
static int LZ4_decompress_safe_withSmallPrefix(const char* source, char* dest, int compressedSize, int maxOutputSize,
                                               size_t prefixSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  endOnInputSize, decode_full_block, noDict,
                                  (BYTE*)dest-prefixSize, NULL, 0);
}

LZ4_FORCE_O2
int LZ4_decompress_safe_forceExtDict(const char* source, char* dest,
                                     int compressedSize, int maxOutputSize,
                                     const void* dictStart, size_t dictSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  endOnInputSize, decode_full_block, usingExtDict,
                                  (BYTE*)dest, (const BYTE*)dictStart, dictSize);
}

LZ4_FORCE_O2
static int LZ4_decompress_fast_extDict(const char* source, char* dest, int originalSize,
                                       const void* dictStart, size_t dictSize)
{
    return LZ4_decompress_generic(source, dest, 0, originalSize,
                                  endOnOutputSize, decode_full_block, usingExtDict,
                                  (BYTE*)dest, (const BYTE*)dictStart, dictSize);
}

/* The "double dictionary" mode, for use with e.g. ring buffers: the first part
 * of the dictionary is passed as prefix, and the second via dictStart + dictSize.
 * These routines are used only once, in LZ4_decompress_*_continue().
 */
LZ4_FORCE_INLINE
int LZ4_decompress_safe_doubleDict(const char* source, char* dest, int compressedSize, int maxOutputSize,
                                   size_t prefixSize, const void* dictStart, size_t dictSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  endOnInputSize, decode_full_block, usingExtDict,
                                  (BYTE*)dest-prefixSize, (const BYTE*)dictStart, dictSize);
}

LZ4_FORCE_INLINE
int LZ4_decompress_fast_doubleDict(const char* source, char* dest, int originalSize,
                                   size_t prefixSize, const void* dictStart, size_t dictSize)
{
    return LZ4_decompress_generic(source, dest, 0, originalSize,
                                  endOnOutputSize, decode_full_block, usingExtDict,
                                  (BYTE*)dest-prefixSize, (const BYTE*)dictStart, dictSize);
}

/*===== streaming decompression functions =====*/

LZ4_streamDecode_t* LZ4_createStreamDecode(void)
{
    LZ4_streamDecode_t* lz4s = (LZ4_streamDecode_t*) ALLOC_AND_ZERO(sizeof(LZ4_streamDecode_t));
    LZ4_STATIC_ASSERT(LZ4_STREAMDECODESIZE >= sizeof(LZ4_streamDecode_t_internal));    /* A compilation error here means LZ4_STREAMDECODESIZE is not large enough */
    return lz4s;
}

int LZ4_freeStreamDecode (LZ4_streamDecode_t* LZ4_stream)
{
    if (LZ4_stream == NULL) { return 0; }  /* support free on NULL */
    FREEMEM(LZ4_stream);
    return 0;
}

/*! LZ4_setStreamDecode() :
 *  Use this function to instruct where to find the dictionary.
 *  This function is not necessary if previous data is still available where it was decoded.
 *  Loading a size of 0 is allowed (same effect as no dictionary).
 * @return : 1 if OK, 0 if error
 */
int LZ4_setStreamDecode (LZ4_streamDecode_t* LZ4_streamDecode, const char* dictionary, int dictSize)
{
    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
    lz4sd->prefixSize = (size_t) dictSize;
    lz4sd->prefixEnd = (const BYTE*) dictionary + dictSize;
    lz4sd->externalDict = NULL;
    lz4sd->extDictSize  = 0;
    return 1;
}

/*! LZ4_decoderRingBufferSize() :
 *  when setting a ring buffer for streaming decompression (optional scenario),
 *  provides the minimum size of this ring buffer
 *  to be compatible with any source respecting maxBlockSize condition.
 *  Note : in a ring buffer scenario,
 *  blocks are presumed decompressed next to each other.
 *  When not enough space remains for next block (remainingSize < maxBlockSize),
 *  decoding resumes from beginning of ring buffer.
 * @return : minimum ring buffer size,
 *           or 0 if there is an error (invalid maxBlockSize).
 */
int LZ4_decoderRingBufferSize(int maxBlockSize)
{
    if (maxBlockSize < 0) return 0;
    if (maxBlockSize > LZ4_MAX_INPUT_SIZE) return 0;
    if (maxBlockSize < 16) maxBlockSize = 16;
    return LZ4_DECODER_RING_BUFFER_SIZE(maxBlockSize);
}

/*
*_continue() :
    These decoding functions allow decompression of multiple blocks in "streaming" mode.
    Previously decoded blocks must still be available at the memory position where they were decoded.
    If it's not possible, save the relevant part of decoded data into a safe buffer,
    and indicate where it stands using LZ4_setStreamDecode()
*/
LZ4_FORCE_O2
int LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int compressedSize, int maxOutputSize)
{
    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
    int result;

    if (lz4sd->prefixSize == 0) {
        /* The first call, no dictionary yet. */
        assert(lz4sd->extDictSize == 0);
        result = LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)result;
        lz4sd->prefixEnd = (BYTE*)dest + result;
    } else if (lz4sd->prefixEnd == (BYTE*)dest) {
        /* They're rolling the current segment. */
        if (lz4sd->prefixSize >= 64 KB - 1)
            result = LZ4_decompress_safe_withPrefix64k(source, dest, compressedSize, maxOutputSize);
        else if (lz4sd->extDictSize == 0)
            result = LZ4_decompress_safe_withSmallPrefix(source, dest, compressedSize, maxOutputSize,
                                                         lz4sd->prefixSize);
        else
            result = LZ4_decompress_safe_doubleDict(source, dest, compressedSize, maxOutputSize,
                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize += (size_t)result;
        lz4sd->prefixEnd  += result;
    } else {
        /* The buffer wraps around, or they're switching to another buffer. */
        lz4sd->extDictSize = lz4sd->prefixSize;
        lz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;
        result = LZ4_decompress_safe_forceExtDict(source, dest, compressedSize, maxOutputSize,
                                                  lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)result;
        lz4sd->prefixEnd  = (BYTE*)dest + result;
    }

    return result;
}

LZ4_FORCE_O2
int LZ4_decompress_fast_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int originalSize)
{
    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
    int result;
    assert(originalSize >= 0);

    if (lz4sd->prefixSize == 0) {
        assert(lz4sd->extDictSize == 0);
        result = LZ4_decompress_fast(source, dest, originalSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)originalSize;
        lz4sd->prefixEnd = (BYTE*)dest + originalSize;
    } else if (lz4sd->prefixEnd == (BYTE*)dest) {
        if (lz4sd->prefixSize >= 64 KB - 1 || lz4sd->extDictSize == 0)
            result = LZ4_decompress_fast(source, dest, originalSize);
        else
            result = LZ4_decompress_fast_doubleDict(source, dest, originalSize,
                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize += (size_t)originalSize;
        lz4sd->prefixEnd  += originalSize;
    } else {
        lz4sd->extDictSize = lz4sd->prefixSize;
        lz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;
        result = LZ4_decompress_fast_extDict(source, dest, originalSize,
                                             lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)originalSize;
        lz4sd->prefixEnd  = (BYTE*)dest + originalSize;
    }

    return result;
}


/*
Advanced decoding functions :
*_usingDict() :
    These decoding functions work the same as "_continue" ones,
    the dictionary must be explicitly provided within parameters
*/

int LZ4_decompress_safe_usingDict(const char* source, char* dest, int compressedSize, int maxOutputSize, const char* dictStart, int dictSize)
{
    if (dictSize==0)
        return LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);
    if (dictStart+dictSize == dest) {
        if (dictSize >= 64 KB - 1) {
            return LZ4_decompress_safe_withPrefix64k(source, dest, compressedSize, maxOutputSize);
        }
        assert(dictSize >= 0);
        return LZ4_decompress_safe_withSmallPrefix(source, dest, compressedSize, maxOutputSize, (size_t)dictSize);
    }
    assert(dictSize >= 0);
    return LZ4_decompress_safe_forceExtDict(source, dest, compressedSize, maxOutputSize, dictStart, (size_t)dictSize);
}

int LZ4_decompress_fast_usingDict(const char* source, char* dest, int originalSize, const char* dictStart, int dictSize)
{
    if (dictSize==0 || dictStart+dictSize == dest)
        return LZ4_decompress_fast(source, dest, originalSize);
    assert(dictSize >= 0);
    return LZ4_decompress_fast_extDict(source, dest, originalSize, dictStart, (size_t)dictSize);
}


/*=*************************************************
*  Obsolete Functions
***************************************************/
/* obsolete compression functions */
int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize)
{
    return LZ4_compress_default(source, dest, inputSize, maxOutputSize);
}
int LZ4_compress(const char* src, char* dest, int srcSize)
{
    return LZ4_compress_default(src, dest, srcSize, LZ4_compressBound(srcSize));
}
int LZ4_compress_limitedOutput_withState (void* state, const char* src, char* dst, int srcSize, int dstSize)
{
    return LZ4_compress_fast_extState(state, src, dst, srcSize, dstSize, 1);
}
int LZ4_compress_withState (void* state, const char* src, char* dst, int srcSize)
{
    return LZ4_compress_fast_extState(state, src, dst, srcSize, LZ4_compressBound(srcSize), 1);
}
int LZ4_compress_limitedOutput_continue (LZ4_stream_t* LZ4_stream, const char* src, char* dst, int srcSize, int dstCapacity)
{
    return LZ4_compress_fast_continue(LZ4_stream, src, dst, srcSize, dstCapacity, 1);
}
int LZ4_compress_continue (LZ4_stream_t* LZ4_stream, const char* source, char* dest, int inputSize)
{
    return LZ4_compress_fast_continue(LZ4_stream, source, dest, inputSize, LZ4_compressBound(inputSize), 1);
}

/*
These decompression functions are deprecated and should no longer be used.
They are only provided here for compatibility with older user programs.
- LZ4_uncompress is totally equivalent to LZ4_decompress_fast
- LZ4_uncompress_unknownOutputSize is totally equivalent to LZ4_decompress_safe
*/
int LZ4_uncompress (const char* source, char* dest, int outputSize)
{
    return LZ4_decompress_fast(source, dest, outputSize);
}
int LZ4_uncompress_unknownOutputSize (const char* source, char* dest, int isize, int maxOutputSize)
{
    return LZ4_decompress_safe(source, dest, isize, maxOutputSize);
}

/* Obsolete Streaming functions */

int LZ4_sizeofStreamState(void) { return LZ4_STREAMSIZE; }

int LZ4_resetStreamState(void* state, char* inputBuffer)
{
    (void)inputBuffer;
    LZ4_resetStream((LZ4_stream_t*)state);
    return 0;
}

void* LZ4_create (char* inputBuffer)
{
    (void)inputBuffer;
    return LZ4_createStream();
}

char* LZ4_slideInputBuffer (void* state)
{
    /* avoid const char * -> char * conversion warning */
    return (char *)(uptrval)((LZ4_stream_t*)state)->internal_donotuse.dictionary;
}

#endif   /* LZ4_COMMONDEFS_ONLY */

     
//
// END FILE: lz4.c
// ----------------------------------------------------------------------------



// ----------------------------------------------------------------------------
// BEGIN FILE: sqcloud.c
//


//
//  sqcloud.c
//
//  Created by Marco Bambini on 08/02/21.
//

// (AMALGAMATED) #include "lz4.h"
// (AMALGAMATED) #include "sqcloud.h"

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <assert.h>
#include <sys/time.h>

#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "Ws2_32.lib")
#include <Shlwapi.h>
#include <io.h>
#include <float.h>
// (AMALGAMATED) #include "pthread.h"
#else
#include <errno.h>
#include <netdb.h>
#include <signal.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>
#include <sys/ioctl.h>
#include <pthread.h>
#include <inttypes.h>
#endif

#ifndef SQLITECLOUD_DISABLE_TSL
// (AMALGAMATED) #include "tls.h"
#endif

// MARK: MACROS -
#ifdef _WIN32
#pragma warning (disable: 4005)
#pragma warning (disable: 4068)
#define readsocket(a,b,c)                   recv((a), (b), (c), 0L)
#define writesocket(a,b,c)                  send((a), (b), (c), 0L)
#else
#define readsocket                          read
#define writesocket                         write
#define closesocket(s)                      close(s)
#endif

#ifndef mem_alloc
#define mem_realloc                         realloc
#define mem_zeroalloc(_s)                   calloc(1,_s)
#define mem_alloc(_s)                       malloc(_s)
#define mem_free(_s)                        free(_s)
#define mem_string_dup(_s)                  strdup(_s)
#endif
#ifndef MIN
#define MIN(a,b)                            (((a)<(b))?(a):(b))
#endif

#define MAX_SOCK_LIST                       6           // maximum number of socket descriptor to try to connect to
                                                        // this change is required to support IPv4/IPv6 connections
#define DEFAULT_TIMEOUT                     12          // default connection timeout in seconds

#define REPLY_OK                            "+2 OK"     // default OK reply
#define REPLY_OK_LEN                        5           // default OK reply string length

// https://levelup.gitconnected.com/8-ways-to-measure-execution-time-in-c-c-48634458d0f9
#define TIME_GET(_t1)                       struct timeval _t1; gettimeofday(&_t1, NULL)
#define TIME_VAL(_t1, _t2)                  ((double)(_t2.tv_sec - _t1.tv_sec) + (double)((_t2.tv_usec - _t1.tv_usec)*1e-6))

#define CMD_MINLEN                          2

#define CONNSTRING_KEYVALUE_SEPARATOR       '='
#define CONNSTRING_TOKEN_SEPARATOR          ';'

#define DEFAULT_CHUCK_NBUFFERS              20
#define DEFAULT_CHUNK_MINROWS               2000

#define ARRAY_STATIC_COUNT                  256
#define ARRAY_HEADER_BUFFER_SIZE            64

#ifndef TLS_DEFAULT_CA_FILE
#if CLI_WINDOWS
// windows
#elif __APPLE__
// macos
#define TLS_DEFAULT_CA_FILE                 "/etc/ssl/cert.pem"
#else
// linux
#define TLS_DEFAULT_CA_FILE                 "/etc/ssl/certs/ca-certificates.crt"
#endif
#endif

// MARK: - PROTOTYPES -

static SQCloudResult *internal_socket_read (SQCloudConnection *connection, bool mainfd);
static bool internal_socket_write (SQCloudConnection *connection, const char *buffer, size_t len, bool mainfd, bool compute_header);
static uint32_t internal_parse_number (char *buffer, uint32_t blen, uint32_t *cstart);
static SQCloudResult *internal_parse_buffer (SQCloudConnection *connection, char *buffer, uint32_t blen, uint32_t cstart, bool isstatic, bool externalbuffer);
static bool internal_connect (SQCloudConnection *connection, const char *hostname, int port, SQCloudConfig *config, bool mainfd);
static bool internal_set_error (SQCloudConnection *connection, int errcode, const char *format, ...);
static SQCloudResult *internal_array_exec (SQCloudConnection *connection, const char *r[], int64_t len[], uint32_t n, uint32_t count);

// MARK: -

struct SQCloudResult {
    SQCLOUD_RESULT_TYPE  tag;               // RESULT_OK, RESULT_ERROR, RESULT_STRING, RESULT_INTEGER, RESULT_FLOAT, RESULT_ROWSET, RESULT_NULL
    
    bool            ischunk;                // flag used to correctly access the union below
    union {
        struct {
            char        *buffer;            // buffer used by the user (it could be a ptr inside rawbuffer)
            char        *rawbuffer;         // ptr to the buffer to be freed
            uint32_t    balloc;             // buffer allocation size
        };
        struct {
            char        **buffers;          // array of buffers used by rowset sent in chunk
            uint32_t    *blens;             // array of buffer len
            uint32_t    *nheads;            // array of header len
            uint32_t    bcount;             // number of buffers in the array
            uint32_t    bnum;               // number of pre-allocated buffers
            uint32_t    brows;              // number of pre-allocated rows
        };
    };
    
    // common
    uint32_t        blen;                   // total buffer length (also the sum of buffers)
    double          time;                   // full execution time (latency + server side time)
    bool            externalbuffer;         // true if the buffer is managed by the caller code
                                            // false if the buffer can be freed by the SQCloudResultFree func
    uint32_t        nheader;                // number of character in the first part of the header (which is usually skipped)
    
    // used in TYPE_ROWSET only
    uint32_t        flags;                  // rowset flags
    uint32_t        nrows;                  // number of rows
    uint32_t        ncols;                  // number of columns
    uint32_t        ndata;                  // number of items stores in data
    char            **data;                 // data contained in the rowset
    char            **name;                 // column names
    char            **decltype;             // column declared types (sqlite mode only)
    char            **dbname;               // column database names (sqlite mode only)
    char            **tblname;              // column table names (sqlite mode only)
    char            **origname;             // column origin names (sqlite mode only)
    uint32_t        *clen;                  // max len for each column (used to display result)
    uint32_t        maxlen;                 // max len for each row/column
    
    // vm related fields (reserved)
    uint32_t        n1;
    uint32_t        n2;
    uint32_t        n3;
    uint32_t        n4;
    uint32_t        n5;
} _SQCloudResult;

struct SQCloudConnection {
    int             fd;
    char            errmsg[1024];
    int             errcode;                // error code
    int             extcode;                // extended error code
    int             offcode;                // offset error code
    SQCloudResult   *_chunk;
    SQCloudConfig   *_config;
    bool            isblob;
    bool            config_to_free;
    
    // pub/sub
    char            *uuid;
    int             pubsubfd;
    SQCloudPubSubCB callback;
    void            *data;
    char            *hostname;
    int             port;
    pthread_t       tid;
    
    #ifndef SQLITECLOUD_DISABLE_TSL
    struct tls      *tls_context;
    struct tls      *tls_pubsub_context;
    #endif
} _SQCloudConnection;

struct SQCloudVM {
    SQCloudConnection   *connection;
    SQCloudResult       *result;
    int                 index;
    int                 type;
    bool                finalized;
    
    bool                isreadonly;
    int                 isexplain;
    int                 rowindex;
    int                 nparams;
    int                 ncolumns;
    
    int64_t             lastrowid;
    int64_t             changes;
    int64_t             totalchanges;
    
    char                *errmsg;
    int                 errcode;
    int                 xerrcode;
} _SQCloudVM;

struct SQCloudBlob {
    SQCloudConnection   *connection;
    int                 index;
    int64_t             bytes;
    int                 rc;
} _SQCloudBlob;

struct SQCloudBackup {
    SQCloudConnection   *connection;
    int                 index;
    int                 page_size;
    int                 page_total;
    int                 page_remaining;
    int                 counter;
    int                 size;
    void                *data;
} _SQCloudBackup;

static SQCloudResult SQCloudResultOK = {RESULT_OK, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0};
static SQCloudResult SQCloudResultNULL = {RESULT_NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0};

// MARK: - UTILS -

static uint32_t utf8_charbytes (const char *s, uint32_t i) {
    unsigned char c = (unsigned char)s[i];
    
    // determine bytes needed for character, based on RFC 3629
    if ((c > 0) && (c <= 127)) return 1;
    if ((c >= 194) && (c <= 223)) return 2;
    if ((c >= 224) && (c <= 239)) return 3;
    if ((c >= 240) && (c <= 244)) return 4;
    
    // means error
    return 0;
}

static uint32_t utf8_len (const char *s, uint32_t nbytes) {
    uint32_t pos = 0;
    uint32_t len = 0;
    
    while (pos < nbytes) {
        ++len;
        uint32_t n = utf8_charbytes(s, pos);
        if (n == 0) return 0; // means error
        pos += n;
    }
    
    return len;
}

#if 0
static char *extract_connection_token (const char *s, char *key, char buffer[256]) {
    char *target = strstr(s, key);
    if (!target) return NULL;
    
    // find out = separator
    char *p = target;
    while (p[0]) {
        if (p[0] == CONNSTRING_KEYVALUE_SEPARATOR) break;
        ++p;
    }
    
    // skip =
    ++p;
    
    // skip spaces (if any)
    while (p[0]) {
        if (!isspace(p[0])) break;
        ++p;
    }
    
    // copy value to buffer
    int len = 0;
    while (p[0] && len < 255) {
        if (isspace(p[0])) break;
        if (p[0] == CONNSTRING_TOKEN_SEPARATOR) break;
        buffer[len] = p[0];
        ++len;
        ++p;
    }
    
    // null-terminate returning value
    buffer[len] = 0;
    p = &buffer[0];
    
    return p;
}
#endif

// MARK: - PRIVATE -

static int socket_geterror (int fd) {
    int err;
    socklen_t errlen = sizeof(err);
    
    int sockerr = getsockopt(fd, SOL_SOCKET, SO_ERROR, (void *)&err, &errlen);
    if (sockerr < 0) return -1;
    
    return ((err == 0 || err == EINTR || err == EAGAIN || err == EINPROGRESS)) ? 0 : err;
}

static void *pubsub_thread (void *arg) {
    SQCloudConnection *connection = (SQCloudConnection *)arg;
    
    int fd = connection->pubsubfd;
    #ifndef SQLITECLOUD_DISABLE_TSL
    struct tls *tls = connection->tls_pubsub_context;
    #endif
    
    size_t blen = 2048;
    char *buffer = mem_alloc(blen);
    if (buffer == NULL) return NULL;
    
    char *original = buffer;
    uint32_t tread = 0;

    while (1) {
        fd_set set;
        FD_ZERO(&set);
        FD_SET(fd, &set);
        
        // wait for read event
        int rc = select(fd + 1, &set, NULL, NULL, NULL);
        if (rc <= 0) continue;
        
        //  read payload string
        #ifndef SQLITECLOUD_DISABLE_TSL
        ssize_t nread = (tls) ? tls_read(tls, buffer, blen) : readsocket(fd, buffer, blen);
        if ((tls) && (nread == TLS_WANT_POLLIN || nread == TLS_WANT_POLLOUT)) continue;
        #else
        ssize_t nread = readsocket(fd, buffer, blen);
        #endif
        
        if (nread < 0) {
            const char *msg = "";
            #ifndef SQLITECLOUD_DISABLE_TSL
            if (tls) msg = tls_error(tls);
            #endif
            
            internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "An error occurred while reading data: %s (%s).", strerror(errno), msg);
            connection->callback(connection, NULL, connection->data);
            break;
        }
        
        if (nread == 0) {
            const char *msg = "";
            #ifndef SQLITECLOUD_DISABLE_TSL
            if (tls) msg = tls_error(tls);
            #endif
            
            internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "An error occurred while reading data: %s (%s).", strerror(errno), msg);
            connection->callback(connection, NULL, connection->data);
            break;
        }
        
        tread += (uint32_t)nread;
        blen -= (uint32_t)nread;
        buffer += nread;
        
        uint32_t cstart = 0;
        uint32_t clen = internal_parse_number (&original[1], tread-1, &cstart);
        if (clen == 0) continue;
        
        // check if read is complete
        // clen is the lenght parsed in the buffer
        // cstart is the index of the first space
        // +1 because we skipped the first character in the internal_parse_number function
        if (clen + cstart + 1 != tread) {
            // check buffer allocation and continue reading
            if (clen + cstart > blen) {
                char *clone = mem_alloc(clen + cstart + 1);
                if (!clone) {
                    internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate memory: %d.", clen + cstart + 1);
                    connection->callback(connection, NULL, connection->data);
                    break;
                }
                memcpy(clone, original, tread);
                buffer = original = clone;
                blen = (clen + cstart + 1) - tread;
                buffer += tread;
            }
            
            continue;
        }
        
        SQCloudResult *result = internal_parse_buffer(connection, original, tread, (clen) ? cstart : 0, false, false);
        if (result->tag == RESULT_STRING) result->tag = RESULT_JSON;
        
        connection->callback(connection, result, connection->data);
        
        blen = 2048;
        buffer = mem_alloc(blen);
        if (!buffer) break;
        
        original = buffer;
        tread = 0;
    }
    
    return NULL;
}

// MARK: -

static bool internal_init (void) {
    static bool inited = false;
    if (inited) return true;
    
    #ifdef _WIN32
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2,2), &wsaData);
    #else
    // IGNORE SIGPIPE and SIGABORT
    struct sigaction act;
    act.sa_handler = SIG_IGN;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    sigaction(SIGPIPE, &act, (struct sigaction *)NULL);
    sigaction(SIGABRT, &act, (struct sigaction *)NULL);
    #endif
    
    inited = true;
    return true;
}

static bool internal_set_error (SQCloudConnection *connection, int errcode, const char *format, ...) {
    connection->errcode = errcode;
    
    va_list arg;
    va_start (arg, format);
    vsnprintf(connection->errmsg, sizeof(connection->errmsg), format, arg);
    va_end (arg);
    
    return false;
}

static void internal_parse_uuid (SQCloudConnection *connection, const char *buffer, size_t blen) {
    // sanity check
    if (!buffer || blen == 0) return;
    
    // expected buffer is PAUTH uuid secret
    // PUATH -> 5
    // uuid -> 36
    // secret -> 36
    // spaces -> 2
    if (blen != (5 + 36 + 36 + 2)) return;
    
    if (strncmp(buffer, "PAUTH ", 6) != 0) return;
    
    // allocate 36 (UUID) + 1 (null-terminated) zero-bytes
    char *uuid = mem_zeroalloc(37);
    if (!uuid) return;
    
    memcpy(uuid, &buffer[6], 36);
    connection->uuid = uuid;
}

static void internal_clear_error (SQCloudConnection *connection) {
    connection->errcode = 0;
    connection->extcode = 0;
    connection->offcode = -1;   // If the most recent error does not reference a specific token in the input SQL, then the sqlite3_error_offset() function returns -1.
    connection->errmsg[0] = 0;
}

static bool internal_setup_tls (SQCloudConnection *connection, SQCloudConfig *config, bool mainfd) {
    #ifndef SQLITECLOUD_DISABLE_TSL
    if (config && config->insecure) return true;
    
    int rc = 0;
    
    if (tls_init() < 0) {
        return internal_set_error(connection, INTERNAL_ERRCODE_TLS, "Error while initializing TLS library.");
    }
    
    struct tls_config *tls_conf = tls_config_new();
    if (!tls_conf) {
        return internal_set_error(connection, INTERNAL_ERRCODE_TLS, "Error while initializing a new TLS configuration.");
    }
    
    // loads a file containing the root certificates
    if (config && config->tls_root_certificate) {
        rc = tls_config_set_ca_file(tls_conf, config->tls_root_certificate);
        if (rc < 0) {internal_set_error(connection, INTERNAL_ERRCODE_TLS, "Error in tls_config_set_ca_file: %s.", tls_config_error(tls_conf));}
    #ifdef TLS_DEFAULT_CA_FILE
    } else {
        rc = tls_config_set_ca_file(tls_conf, TLS_DEFAULT_CA_FILE);
        if (rc < 0) {internal_set_error(connection, INTERNAL_ERRCODE_TLS, "Error in tls_config_set_ca_file: %s.", tls_config_error(tls_conf));}
    #endif
    }
    
    // loads a file containing the server certificate
    if (config && config->tls_certificate) {
        rc = tls_config_set_cert_file(tls_conf, config->tls_certificate);
        if (rc < 0) {internal_set_error(connection, INTERNAL_ERRCODE_TLS, "Error in tls_config_set_cert_file: %s.", tls_config_error(tls_conf));}
    }
    
    // loads a file containing the private key
    if (config && config->tls_certificate_key) {
        rc = tls_config_set_key_file(tls_conf, config->tls_certificate_key);
        if (rc < 0) {internal_set_error(connection, INTERNAL_ERRCODE_TLS, "Error in tls_config_set_key_file: %s.", tls_config_error(tls_conf));}
    }
    
    struct tls *tls_context = tls_client();
    if (!tls_context) {
        return internal_set_error(connection, INTERNAL_ERRCODE_TLS, "Error while initializing a new TLS client.");
    }
    
    // apply configuration to context
    rc = tls_configure(tls_context, tls_conf);
    if (rc < 0) {
        return internal_set_error(connection, INTERNAL_ERRCODE_TLS, "Error in tls_configure: %s.", tls_error(tls_context));
    }
    
    // save context
    if (mainfd) connection->tls_context = tls_context;
    else connection->tls_pubsub_context = tls_context;
    
    #endif
    return true;
}

static SQCLOUD_VALUE_TYPE internal_type (char *buffer) {
    // for VALUE_NULL values we don't return _ but the NULL value itself, so check for this special case
    // internal_parse_value is used both internally to set the value inside a Rowset (1)
    // and also from the public API SQCloudRowsetValue (2)
    // to fix this misbehaviour, (1) should return _ while (2) should return NULL
    // this is really just a convention so it is much more easier to just return NULL everytime
    if (!buffer) return VALUE_NULL;
    
    switch (buffer[0]) {
        case CMD_STRING:
        case CMD_ZEROSTRING: return VALUE_TEXT;
        case CMD_INT: return VALUE_INTEGER;
        case CMD_FLOAT: return VALUE_FLOAT;
        case CMD_NULL: return VALUE_NULL;
        case CMD_BLOB: return VALUE_BLOB;
    }
    return VALUE_NULL;
}

static bool internal_has_commandlen (int c) {
    return ((c == CMD_INT) || (c == CMD_FLOAT) || (c == CMD_NULL)) ? false : true;
}

static bool internal_canbe_zerolength (int c) {
    return ((c == CMD_BLOB) || (c == CMD_STRING));
}

static uint32_t internal_buffer_maxlen (SQCloudResult *result, char *value) {
    if (!value) return 2;
    
    // chunk case
    if (result->ischunk) {
        // lookup value index
        int32_t index = -1;
        char *buffer = NULL;
        uint32_t blen = 0;
        
        for (int32_t i=0; i < result->bcount; ++i) {
            buffer = result->buffers[i];
            blen = result->blens[i];
            if ((value >= buffer) && (value <= buffer + blen)) {
                index = i;
                break;
            }
        }
        
        // sanity check
        if (index == -1) return 0;
        
        return (uint32_t)(blen - (uint32_t)(value - buffer) + result->nheads[index]);
    }
    
    // default case
    return (uint32_t)(result->blen - (uint32_t)(value - result->rawbuffer) + result->nheader);
}

static uint32_t internal_parse_number_extended (char *buffer, uint32_t blen, uint32_t *cstart, uint32_t *extcode, int32_t *offcode) {
    uint32_t value = 0;
    uint32_t extvalue = 0;
    int32_t offvalue = -1;
    bool isext = false;
    bool isoff = false;
    
    for (uint32_t i=0; i<blen; ++i) {
        int c = buffer[i];
        
        // check for optional extended error code (ERRCODE[:EXTCODE:OFFCODE])
        if (c == ':') {
            if (isext == false) isext = true;
            else {isext = false; isoff = true; offvalue = 0;}
            continue;
        }
        
        // check for end of value
        if (c == ' ') {
            if (cstart) *cstart = i+1;
            if (extcode) *extcode = extvalue;
            if (offcode) *offcode = offvalue;
            return value;
        }
        
        // compute numeric value
        if (isext) extvalue = (extvalue * 10) + (buffer[i] - '0');
        else if (isoff) offvalue = (offvalue * 10) + (buffer[i] - '0');
        else value = (value * 10) + (buffer[i] - '0');
    }
    
    return 0;
}

static uint32_t internal_parse_number (char *buffer, uint32_t blen, uint32_t *cstart) {
    return internal_parse_number_extended(buffer, blen, cstart, NULL, NULL);
}

static int internal_parse_type (char *buffer) {
    if (!buffer) return 0;
    return buffer[0];
}

static char *internal_parse_value (char *buffer, uint32_t *len, uint32_t *cellsize) {
    if (*len <= 0) return NULL;
    
    // handle special NULL value case
    if (!buffer || buffer[0] == CMD_NULL) {
        *len = 0;
        if (cellsize) *cellsize = 2;
        return NULL;
    }
    
    // blen originally was hard coded to 24 because the max 64bit value is 20 characters long
    uint32_t cstart = 0;
    uint32_t blen = *len;   
    blen = internal_parse_number(&buffer[1], blen, &cstart);
    
    // handle decimal/float cases
    if ((buffer[0] == CMD_INT) || (buffer[0] == CMD_FLOAT)) {
        *len = cstart - 1;
        if (cellsize) *cellsize = cstart + 1;
        return &buffer[1];
    }

    // sanity check
    if (blen > *len) return NULL;
    
    *len = (buffer[0] == CMD_ZEROSTRING) ? blen - 1 : blen;
    if (cellsize) *cellsize = cstart + blen + 1;
    return &buffer[1+cstart];
}

static SQCloudResult *internal_run_command (SQCloudConnection *connection, const char *buffer, size_t blen, bool mainfd) {
    internal_clear_error(connection);
    
    if (!buffer || blen < CMD_MINLEN) return NULL;
    
    TIME_GET(tstart);
    if (!internal_socket_write(connection, buffer, blen, mainfd, true)) return NULL;
    SQCloudResult *result = internal_socket_read(connection, mainfd);
    TIME_GET(tend);
    if (result) result->time = TIME_VAL(tstart, tend);
    return result;
}

static bool internal_send_blob(SQCloudConnection *connection, void *buffer, uint32_t blen) {
    internal_clear_error(connection);
    
    // set connection to be BLOB
    connection->isblob = true;
    
    // check zero-size BLOB
    TIME_GET(tstart);
    bool rc = internal_socket_write(connection, (blen) ? buffer : NULL, blen, true, true);
    connection->isblob = false;
    if (!rc) return false;
    SQCloudResult *result = internal_socket_read(connection, true);
    TIME_GET(tend);
    if (result) result->time = TIME_VAL(tstart, tend);
    
    rc = (SQCloudResultType(result) == RESULT_OK);
    SQCloudResultFree(result);
    return rc;
}

static SQCloudResult *internal_setup_pubsub (SQCloudConnection *connection, const char *buffer, size_t blen) {
    // check if pubsub was already setup
    if (connection->pubsubfd != 0) return &SQCloudResultOK;
    
    if (!internal_setup_tls(connection, connection->_config, false)) return NULL;
    
    if (internal_connect(connection, connection->hostname, connection->port, connection->_config, false)) {
        SQCloudResult *result = internal_run_command(connection, buffer, blen, false);
        if (!SQCloudResultIsOK(result)) return result;
        internal_parse_uuid(connection, buffer, blen);
        pthread_create(&connection->tid, NULL, pubsub_thread, (void *)connection);
    } else {
        return NULL;
    }
    
    return &SQCloudResultOK;
}

static SQCloudResult *internal_reconnect (SQCloudConnection *connection, const char *buffer, size_t blen) {
    // DO RE-CONNECT HERE
    return NULL;
}

static int32_t internal_array_count (char *buffer, uint32_t blen) {
    // =LEN N VALUE1 VALUE2 ... VALUEN
    if (buffer[0] != CMD_ARRAY) return -1;
    
    do {
        ++buffer;
        --blen;
    }
    while (buffer[0] != ' ');
    ++buffer; --blen;
    
    uint32_t size = 0;
    return internal_parse_number(buffer, blen, &size);
}

static SQCloudResult *internal_parse_array (SQCloudConnection *connection, char *buffer, uint32_t blen, uint32_t bstart) {
    SQCloudResult *rowset = (SQCloudResult *)mem_zeroalloc(sizeof(SQCloudResult));
    if (!rowset) {
        internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate memory for SQCloudResult: %d.", sizeof(SQCloudResult));
        return NULL;
    }
    
    rowset->tag = RESULT_ARRAY;
    rowset->rawbuffer = buffer;
    rowset->blen = blen;
    rowset->nheader = bstart;
    
    // =LEN N VALUE1 VALUE2 ... VALUEN
    uint32_t start1 = 0;
    uint32_t n = internal_parse_number(&buffer[bstart], blen-1, &start1);
    
    rowset->ndata = n;
    rowset->data = (char **) mem_alloc(rowset->ndata * sizeof(char *));
    if (!rowset->data) {
        internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate memory for SQCloudResult: %d.", rowset->ndata * sizeof(char *));
        mem_free(rowset);
        return NULL;
    }
    
    // loop from i to n to parse each data
    buffer += bstart + start1;
    for (uint32_t i=0; i<n; ++i) {
        uint32_t len = blen - (bstart + start1), cellsize;
        char *value = internal_parse_value(buffer, &len, &cellsize);
        rowset->data[i] = (value) ? buffer : NULL;
        buffer += cellsize;
        blen -= cellsize;
    }
    
    return rowset;
}

static SQCloudResult *internal_rowset_type (SQCloudConnection *connection, char *buffer, uint32_t blen, uint32_t bstart, SQCLOUD_RESULT_TYPE type) {
    SQCloudResult *rowset = (SQCloudResult *)mem_zeroalloc(sizeof(SQCloudResult));
    if (!rowset) {
        internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate memory for SQCloudResult: %d.", sizeof(SQCloudResult));
        return NULL;
    }
    
    rowset->tag = type;
    rowset->buffer = &buffer[bstart];
    rowset->rawbuffer = buffer;
    rowset->blen = blen;
    rowset->balloc = blen;
    
    return rowset;
}

static char *internal_get_rowset_header (SQCloudResult *result, char **header, uint32_t col, uint32_t *len) {
    if (!result || result->tag != RESULT_ROWSET) return NULL;
    if (col >= result->ncols) return NULL;
    if (header == NULL) return NULL;
    
    char *buffer = (result->ischunk) ? result->buffers[0] : result->rawbuffer;
    *len = result->blen - (uint32_t)(header[col] - buffer);
    return internal_parse_value(header[col], len, NULL);
}

static bool internal_parse_rowset_header (SQCloudResult *rowset, char **pbuffer, uint32_t *pblen, uint32_t ncols, uint32_t flags) {
    if (BITCHECK(flags, SQCLOUD_ROWSET_FLAG_DATAONLY)) return true;
    
    char *buffer = *pbuffer;
    uint32_t blen = *pblen;
    
    if (BITCHECK(flags, SQCLOUD_ROWSET_FLAG_METAVM)) {
        uint32_t cstart1 = 0, cstart2 = 0, cstart3 = 0, cstart4 = 0, cstart5 = 0;
        
        // bind parameter count
        buffer += 1; blen -= 1;
        uint32_t n1 = internal_parse_number(buffer, blen, &cstart1);
        
        // vm is readonly
        buffer += cstart1; blen -= cstart1;
        uint32_t n2 = internal_parse_number(buffer, blen, &cstart2);
        
        // column count
        buffer += cstart2; blen -= cstart2;
        uint32_t n3 = internal_parse_number(buffer, blen, &cstart3);
        
        // vm is explain
        buffer += cstart3; blen -= cstart3;
        uint32_t n4 = internal_parse_number(buffer, blen, &cstart4);
        
        // tail len
        buffer += cstart4; blen -= cstart4;
        uint32_t n5 = internal_parse_number(buffer, blen, &cstart5);
         
        buffer += cstart5; blen -= cstart5;
        
        rowset->n1 = n1;
        rowset->n2 = n2;
        rowset->n3 = n3;
        rowset->n4 = n4;
        rowset->n5 = n5;
    }
    
    // header is guarantee to contains column names (1st)
    for (uint32_t i=0; i<ncols; ++i) {
        uint32_t cstart = 0;
        uint32_t len = internal_parse_number(&buffer[1], blen, &cstart);
        rowset->name[i] = buffer;
        buffer += cstart + len + 1;
        blen -= cstart + len + 1;
        if (rowset->clen[i] < len) rowset->clen[i] = len;
        if (rowset->maxlen < len) rowset->maxlen = len;
    }
    
    if (BITCHECK(flags, SQCLOUD_ROWSET_FLAG_METACOLS)) {
        rowset->decltype = (char **) mem_alloc(ncols * sizeof(char *));
        if (!rowset->decltype) return false;
        rowset->dbname = (char **) mem_alloc(ncols * sizeof(char *));
        if (!rowset->dbname) return false;
        rowset->tblname = (char **) mem_alloc(ncols * sizeof(char *));
        if (!rowset->tblname) return false;
        rowset->origname = (char **) mem_alloc(ncols * sizeof(char *));
        if (!rowset->origname) return false;
        
        // in sqlite mode header contains column declared types (2nd)
        for (uint32_t i=0; i<ncols; ++i) {
            uint32_t cstart = 0;
            uint32_t len = internal_parse_number(&buffer[1], blen, &cstart);
            rowset->decltype[i] = buffer;
            buffer += cstart + len + 1;
            blen -= cstart + len + 1;
        }
        
        // in sqlite mode header contains column database names (3rd)
        for (uint32_t i=0; i<ncols; ++i) {
            uint32_t cstart = 0;
            uint32_t len = internal_parse_number(&buffer[1], blen, &cstart);
            rowset->dbname[i] = buffer;
            buffer += cstart + len + 1;
            blen -= cstart + len + 1;
        }
        
        // in sqlite mode header contains column table names (4th)
        for (uint32_t i=0; i<ncols; ++i) {
            uint32_t cstart = 0;
            uint32_t len = internal_parse_number(&buffer[1], blen, &cstart);
            rowset->tblname[i] = buffer;
            buffer += cstart + len + 1;
            blen -= cstart + len + 1;
        }
        
        // in sqlite mode header contains column origin names (5th)
        for (uint32_t i=0; i<ncols; ++i) {
            uint32_t cstart = 0;
            uint32_t len = internal_parse_number(&buffer[1], blen, &cstart);
            rowset->origname[i] = buffer;
            buffer += cstart + len + 1;
            blen -= cstart + len + 1;
        }
    }
    
    *pbuffer = buffer;
    *pblen = blen;
    
    return true;
}

static bool internal_parse_rowset_values (SQCloudResult *rowset, char **pbuffer, uint32_t *pblen, uint32_t index, uint32_t bound, uint32_t ncols, uint32_t flags) {
    if (BITCHECK(flags, SQCLOUD_ROWSET_FLAG_HEADONLY)) return true;
    
    char *buffer = *pbuffer;
    uint32_t blen = *pblen;
    
    for (uint32_t i=index; i<bound; ++i) {
        uint32_t len = blen, cellsize;
        char *value = internal_parse_value(buffer, &len, &cellsize);
        rowset->data[i] = (value) ? buffer : NULL;
        buffer += cellsize;
        blen -= cellsize;
        ++rowset->ndata;
        if (rowset->clen[i % ncols] < len) rowset->clen[i % ncols] = len;
        if (rowset->maxlen < len) rowset->maxlen = len;
    }
    
    return true;
}

static SQCloudResult *internal_parse_rowset (SQCloudConnection *connection, char *buffer, uint32_t blen, uint32_t bstart,
                                             uint32_t nrows, uint32_t ncols, uint32_t flags) {
    SQCloudResult *rowset = (SQCloudResult *)mem_zeroalloc(sizeof(SQCloudResult));
    if (!rowset) {
        internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate memory for SQCloudResult: %d.", sizeof(SQCloudResult));
        return NULL;
    }
    
    rowset->tag = RESULT_ROWSET;
    rowset->buffer = buffer;
    rowset->rawbuffer = buffer;
    rowset->blen = blen;
    rowset->balloc = blen;
    rowset->nheader = bstart;
    rowset->flags = flags;
    
    rowset->nrows = nrows;
    rowset->ncols = ncols;
    rowset->data = (char **) mem_alloc(nrows * ncols * sizeof(char *));
    rowset->name = (char **) mem_alloc(ncols * sizeof(char *));
    rowset->clen = (uint32_t *) mem_zeroalloc(ncols * sizeof(uint32_t));
    if (!rowset->data || !rowset->name || !rowset->clen) goto abort_rowset;
    
    buffer += bstart;
    blen -= bstart;
    
    // parse rowset header
    if (!internal_parse_rowset_header(rowset, &buffer, &blen, ncols, flags)) goto abort_rowset;
    
    // parse values (buffer and blen was updated in internal_parse_rowset_header)
    if (!internal_parse_rowset_values(rowset, &buffer, &blen, 0, nrows * ncols, ncols, flags)) goto abort_rowset;
    
    return rowset;
    
abort_rowset:
    if (rowset->data) mem_free(rowset->data);
    if (rowset->name) mem_free(rowset->name);
    if (rowset->clen) mem_free(rowset->clen);
    if (rowset) mem_free(rowset);
    
    internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate internal memory for SQCloudResult.");
    return NULL;
}

static SQCloudResult *internal_parse_rowset_chunck (SQCloudConnection *connection, char *buffer, uint32_t blen, uint32_t bstart, uint32_t idx,
                                                    uint32_t nrows, uint32_t ncols, uint32_t flags) {
    SQCloudResult *rowset = connection->_chunk;
    bool first_chunk = false;
    
    // sanity check
    if (idx == 1 && connection->_chunk) {
        // something bad happened here because a first chunk is received while a saved one has not been fully processed
        // lets try to restart the whole process
        SQCloudResultFree(connection->_chunk);
        connection->_chunk = NULL;
        rowset = NULL;
    }
    
    if (!rowset) {
        // this should never happen
        if (idx != 1) return NULL;
        
        // allocate a new rowset
        rowset = (SQCloudResult *)mem_zeroalloc(sizeof(SQCloudResult));
        if (!rowset) {
            internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate memory for SQCloudResult: %d.", sizeof(SQCloudResult));
            return NULL;
        }
        first_chunk = true;
        connection->_chunk = rowset;
    }
    
    if (first_chunk) {
        rowset->tag = RESULT_ROWSET;
        rowset->flags = flags;
        rowset->ischunk = true;
        
        rowset->buffers = (char **)mem_zeroalloc((sizeof(char *) * DEFAULT_CHUCK_NBUFFERS));
        if (!rowset->buffers) goto abort_rowset;
        
        rowset->blens = (uint32_t *)mem_zeroalloc((sizeof(uint32_t) * DEFAULT_CHUCK_NBUFFERS));
        if (!rowset->blens) goto abort_rowset;
        
        rowset->nheads = (uint32_t *)mem_zeroalloc((sizeof(uint32_t) * DEFAULT_CHUCK_NBUFFERS));
        if (!rowset->nheads) goto abort_rowset;
        
        rowset->bnum = DEFAULT_CHUCK_NBUFFERS;
        rowset->buffers[0] = buffer;
        rowset->blens[0] = blen;
        rowset->nheads[0] = bstart;
        rowset->bcount = 1;
        
        rowset->brows = nrows + DEFAULT_CHUNK_MINROWS;
        rowset->nrows = nrows;
        rowset->ncols = ncols;
        rowset->data = (char **) mem_alloc(rowset->brows * ncols * sizeof(char *));
        rowset->name = (char **) mem_alloc(ncols * sizeof(char *));
        rowset->clen = (uint32_t *) mem_zeroalloc(ncols * sizeof(uint32_t));
        if (!rowset->data || !rowset->name || !rowset->clen) goto abort_rowset;
        
        buffer += bstart;
        
        // parse rowset header
        if (!internal_parse_rowset_header(rowset, &buffer, &blen, ncols, flags)) goto abort_rowset;
    }
    
    // update total buffer size
    rowset->blen += blen;
    
    // check end-chunk condition
    if (idx == 0 && nrows == 0 && ncols == 0) {
        connection->_chunk = NULL;
        if (!rowset->externalbuffer) mem_free(buffer);
        return rowset;
    }
    
    // check if a resize is needed in the array of buffers
    if (rowset->bnum <= rowset->bcount + 1) {
        uint32_t n = rowset->bnum * 2;
        char **temp = (char **)mem_realloc(rowset->buffers, (sizeof(char *) * n));
        if (!temp) goto abort_rowset;
        rowset->buffers = temp;
        
        uint32_t *temp2 = (uint32_t*)mem_realloc(rowset->blens, (sizeof(uint32_t) * n));
        if (!temp2) goto abort_rowset;
        rowset->blens = temp2;
        
        uint32_t *temp3 = (uint32_t*)mem_realloc(rowset->nheads, (sizeof(uint32_t) * n));
        if (!temp3) goto abort_rowset;
        rowset->nheads = temp3;
        
        rowset->bnum = n;
    }
    
    // check if a resize is needed in the ptr data array
    if (rowset->brows <= rowset->nrows + nrows) {
        uint32_t n = rowset->brows * 2;
        char **temp = (char **)mem_realloc(rowset->data, n * ncols * (sizeof(char *)));
        if (!temp) goto abort_rowset;
        rowset->data = temp;
        rowset->brows = n;
    }
    
    // adjust internal fields
    if (!first_chunk) {
        rowset->buffers[rowset->bcount] = buffer;
        rowset->blens[rowset->bcount] = blen;
        rowset->nheads[rowset->bcount] = bstart;
        rowset->nrows += nrows;
        buffer += bstart;
        
        // increment buffers counter
        ++rowset->bcount;
    }
    
    // parse values
    uint32_t index = rowset->ndata;
    uint32_t bound = rowset->ndata + (nrows * ncols);
    
    // parse values
    if (!internal_parse_rowset_values(rowset, &buffer, &blen, index, bound, ncols, flags)) goto abort_rowset;
    
    // this check is for internal usage only
    if (connection->fd == 0) return rowset;
    
    // normal usage
    // send ACK
    if (!internal_socket_write(connection, "OK", 2, true, true)) goto abort_rowset;
        
    // read next chunk
    return internal_socket_read (connection, true);
    
abort_rowset:
    SQCloudResultFree(rowset);
    connection->_chunk = NULL;
    return NULL;
}

static SQCloudResult *internal_parse_buffer (SQCloudConnection *connection, char *buffer, uint32_t blen, uint32_t cstart, bool isstatic, bool externalbuffer) {
    if (blen <= 1) return false;
    
    // try to check if it is a OK reply: +2 OK
    if ((blen == REPLY_OK_LEN) && (strncmp(buffer, REPLY_OK, REPLY_OK_LEN) == 0)) {
        return &SQCloudResultOK;
    }
    
    // if buffer is static (stack based allocation) then it must be duplicated
    if (buffer[0] != CMD_ERROR && isstatic) {
        char *clone = mem_alloc(blen);
        if (!clone) {
            internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate memory: %d.", blen);
            return NULL;
        }
        memcpy(clone, buffer, blen);
        buffer = clone;
        isstatic = false;
    }
    
    // check for compressed reply before the parse step
    char *zdata = NULL;
    if (buffer[0] == CMD_COMPRESSED) {
        // %TLEN CLEN ULEN *0 NROWS NCOLS DATA
        uint32_t cstart1 = 0;
        uint32_t cstart2 = 0;
        uint32_t cstart3 = 0;
        uint32_t tlen = internal_parse_number(&buffer[1], blen-1, &cstart1);
        uint32_t clen = internal_parse_number(&buffer[cstart1 + 1], blen-(cstart1 + 1), &cstart2);
        uint32_t ulen = internal_parse_number(&buffer[cstart1 + cstart2 + 1], blen-(cstart1 + cstart2 + 1), &cstart3);
        
        // start of compressed buffer
        zdata = &buffer[tlen - clen + cstart1 + 1];
        
        // start of raw uncompressed header
        char *hstart = &buffer[cstart1 + cstart2 + cstart3 + 1];
        
        // try to allocate a buffer big enough to hold uncompressed data + raw header
        uint32_t clonelen = ulen + (uint32_t)(hstart - buffer);
        char *clone = mem_alloc (clonelen);
        if (!clone) {
            internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate memory to uncompress buffer: %d.", clonelen);
            if (!isstatic && !externalbuffer) mem_free(buffer);
            return NULL;
        }
        
        // copy raw buffer
        memcpy(clone, hstart, zdata - hstart);
        
        // uncompress buffer and sanity check the result
        uint32_t rc = LZ4_decompress_safe(zdata, clone + (zdata - hstart), clen, ulen);
        if (rc <= 0 || rc != ulen) {
            internal_set_error(connection, INTERNAL_ERRCODE_GENERIC, "Unable to decompress buffer (err code: %d).", rc);
            if (!isstatic && !externalbuffer) mem_free(buffer);
            return NULL;
        }
        
        // decompression is OK so replace buffer
        if (!isstatic && !externalbuffer) mem_free(buffer);
        
        isstatic = false;
        buffer = clone;
        blen = clonelen;
        
        // at this point the buffer used in the SQCloudResult is a newly allocated one (clone)
        // so externalbuffer flag must be set to false
        externalbuffer = false;
    }
    
    // parse reply
    switch (buffer[0]) {
        case CMD_ZEROSTRING:
        case CMD_RECONNECT:
        case CMD_PUBSUB:
        case CMD_COMMAND:
        case CMD_STRING:
        case CMD_ARRAY:
        case CMD_BLOB:
        case CMD_JSON: {
            // +LEN string
            uint32_t cstart = 0;
            // parse explicit len
            uint32_t len = internal_parse_number(&buffer[1], blen-1, &cstart);
            SQCLOUD_RESULT_TYPE type = (buffer[0] == CMD_JSON) ? RESULT_JSON : RESULT_STRING;
            if (buffer[0] == CMD_ZEROSTRING) --len;
            else if (buffer[0] == CMD_COMMAND) return internal_run_command(connection, &buffer[cstart+1], len, true);
            else if (buffer[0] == CMD_PUBSUB) return internal_setup_pubsub(connection, &buffer[cstart+1], len);
            else if (buffer[0] == CMD_RECONNECT) return internal_reconnect(connection, &buffer[cstart+1], len);
            else if (buffer[0] == CMD_ARRAY) return internal_parse_array(connection, buffer, len, cstart+1);
            else if (buffer[0] == CMD_BLOB) type = RESULT_BLOB;
            SQCloudResult *res = internal_rowset_type(connection, buffer, len, cstart+1, type);
            if (res) res->externalbuffer = externalbuffer;
            return res;
        }
            
        case CMD_ERROR: {
            // -LEN ERRCODE[:EXTCODE:OFFCODE] ERRMSG
            uint32_t cstart = 0, cstart2 = 0;
            uint32_t len = internal_parse_number(&buffer[1], blen-1, &cstart);
            
            int32_t offcode = -1;
            uint32_t extcode = 0;
            uint32_t errcode = internal_parse_number_extended(&buffer[cstart + 1], blen-1, &cstart2, &extcode, &offcode);
            connection->errcode = (int)errcode;
            connection->extcode = (int)extcode;
            connection->offcode = (int)offcode;
            
            len -= cstart2;
            memcpy(connection->errmsg, &buffer[cstart + cstart2 + 1], MIN(len, sizeof(connection->errmsg)));
            connection->errmsg[len] = 0;
            
            // check free buffer
            if (!isstatic && !externalbuffer) mem_free(buffer);
            return NULL;
        }
        
        case CMD_ROWSET:
        case CMD_ROWSET_CHUNK: {
            // CMD_ROWSET:          *LEN 0:VERSION ROWS COLS DATA
            // CMD_ROWSET_CHUNK:    /LEN IDX:VERSION ROWS COLS DATA
            uint32_t cstart1 = 0, cstart2 = 0, cstart3 = 0, cstart4 = 0;
            uint32_t flags = 0;
            
            internal_parse_number(&buffer[1], blen-1, &cstart1); // parse len (already parsed in blen parameter)
            uint32_t idx = internal_parse_number_extended(&buffer[cstart1 + 1], blen-(cstart1+1), &cstart2, &flags, NULL);
            uint32_t nrows = internal_parse_number(&buffer[cstart1 + cstart2 + 1], blen-(cstart1 + cstart2 + 1), &cstart3);
            uint32_t ncols = internal_parse_number(&buffer[cstart1 + cstart2 + + cstart3 + 1], blen-(cstart1 + cstart2 + + cstart3 + 1), &cstart4);
            
            // idx is always 0 if (buffer[0] == CMD_ROWSET)
            
            uint32_t bstart = cstart1 + cstart2 + cstart3 + cstart4 + 1;
            SQCloudResult *res = NULL;
            // the externalbuffer flag can change in case of compressed rowset when the end chunk is received
            if (connection->_chunk) connection->_chunk->externalbuffer = externalbuffer;
            if (buffer[0] == CMD_ROWSET) res = internal_parse_rowset(connection, buffer, blen, bstart, nrows, ncols, flags);
            else res = internal_parse_rowset_chunck(connection, buffer, blen, bstart, idx, nrows, ncols, flags);
            if (res) res->externalbuffer = externalbuffer;
            
            // check free buffer
            if (!res && !isstatic && !externalbuffer) mem_free(buffer);
            return res;
        }
        
        case CMD_NULL:
            if (!isstatic && !externalbuffer) mem_free(buffer);
            return &SQCloudResultNULL;
            
        case CMD_INT:
        case CMD_FLOAT: {
            // NUMBER case
            internal_parse_value(buffer, &blen, NULL);
            SQCloudResult *res = internal_rowset_type(connection, buffer, blen, 1, (buffer[0] == CMD_INT) ? RESULT_INTEGER : RESULT_FLOAT);
            if (res) res->externalbuffer = externalbuffer;
            
            if (!res && !isstatic && !externalbuffer) mem_free(buffer);
            return res;
        }
            
        case CMD_RAWJSON: {
            // SHOULD NEVER REACH THIS POINT
            // handle JSON here
            // a JSON parser must process raw buffer
            return &SQCloudResultNULL;
        }
    }
    
    if (!isstatic && !externalbuffer) mem_free(buffer);
    return NULL;
}

static bool internal_socket_forward_read (SQCloudConnection *connection, bool (*forward_cb) (char *buffer, size_t blen, void *xdata, void *xdata2), void *xdata, void *xdata2) {
    char sbuffer[8129];
    uint32_t blen = sizeof(sbuffer);
    uint32_t cstart = 0;
    uint32_t tread = 0;
    uint32_t clen = 0;
    
    char *buffer = sbuffer;
    char *original = buffer;
    int fd = connection->fd;
    #ifndef SQLITECLOUD_DISABLE_TSL
    struct tls *tls = connection->tls_context;
    #endif
    
    while (1) {
        // perform read operation
        #ifndef SQLITECLOUD_DISABLE_TSL
        ssize_t nread = (tls) ? tls_read(tls, buffer, blen) : readsocket(fd, buffer, blen);
        if ((tls) && (nread == TLS_WANT_POLLIN || nread == TLS_WANT_POLLOUT)) continue;
        #else
        ssize_t nread = readsocket(fd, buffer, blen);
        #endif
        
        // sanity check read
        if (nread < 0) {
            const char *msg = "";
            #ifndef SQLITECLOUD_DISABLE_TSL
            if (tls) msg = tls_error(tls);
            #endif
            
            internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "An error occurred while reading data: %s (%s).", strerror(errno), msg);
            goto abort_read;
        }
        
        if (nread == 0) {
            const char *msg = "";
            #ifndef SQLITECLOUD_DISABLE_TSL
            if (tls) msg = tls_error(tls);
            #endif
            
            internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "Unexpected EOF found while reading data: %s (%s).", strerror(errno), msg);
            goto abort_read;
        }
        
        // forward read to callback
        bool result = forward_cb(buffer, nread, xdata, xdata2);
        if (!result) goto abort_read;
        
        // update internal counter
        tread += (uint32_t)nread;
        
        // determine command length
        if (clen == 0) {
            clen = internal_parse_number (&original[1], tread-1, &cstart);
            
            // handle special cases
            if ((original[0] == CMD_INT) || (original[0] == CMD_FLOAT) || (original[0] == CMD_NULL)) clen = 0;
            else if (clen == 0) continue;
        }
        
        // check if read is complete
        if (clen + cstart + 1 == tread) break;
    }
    
    return true;
    
abort_read:
    return false;
}

static SQCloudResult *internal_socket_read (SQCloudConnection *connection, bool mainfd) {
    // most of the time one read will be sufficient
    char header[4096];
    char *buffer = (char *)&header;
    uint32_t blen = sizeof(header);
    uint32_t tread = 0;
    
    uint32_t cstart = 0;
    uint32_t clen = 0;

    int fd = (mainfd) ? connection->fd : connection->pubsubfd;
    #ifndef SQLITECLOUD_DISABLE_TSL
    struct tls *tls = (mainfd) ? connection->tls_context : connection->tls_pubsub_context;
    #endif
    
    char *original = buffer;
    while (1) {
        #ifndef SQLITECLOUD_DISABLE_TSL
        ssize_t nread = (tls) ? tls_read(tls, buffer, blen) : readsocket(fd, buffer, blen);
        if ((tls) && (nread == TLS_WANT_POLLIN || nread == TLS_WANT_POLLOUT)) continue;
        #else
        ssize_t nread = readsocket(fd, buffer, blen);
        #endif
        
        if (nread < 0) {
            const char *msg = "";
            #ifndef SQLITECLOUD_DISABLE_TSL
            if (tls) msg = tls_error(tls);
            #endif
            
            internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "An error occurred while reading data: %s (%s).", strerror(errno), msg);
            goto abort_read;
        }
        
        if (nread == 0) {
            const char *msg = "";
            #ifndef SQLITECLOUD_DISABLE_TSL
            if (tls) msg = tls_error(tls);
            #endif
            
            internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "Unexpected EOF found while reading data: %s (%s).", strerror(errno), msg);
            goto abort_read;
        }
        
        tread += (uint32_t)nread;
        blen -= (uint32_t)nread;
        buffer += nread;
        
        if (internal_has_commandlen(original[0])) {
            // parse buffer looking for command length
            if (clen == 0) clen = internal_parse_number (&original[1], tread-1, &cstart);
            
            // check special zero-length value
            if (clen == 0) {
                if (!internal_canbe_zerolength(original[0])) continue;
            }
            
            // check if read is complete
            // clen is the lenght parsed in the buffer
            // cstart is the index of the first space
            // +1 because we skipped the first character in the internal_parse_number function
            if (clen + cstart + 1 != tread) {
                // check buffer allocation and continue reading
                if (clen + cstart - tread > blen) {
                    char *clone = mem_alloc(clen + cstart + 1);
                    if (!clone) {
                        internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate memory: %d.", clen + cstart + 1);
                        goto abort_read;
                    }
                    memcpy(clone, original, tread);
                    buffer = original = clone;
                    blen = (clen + cstart + 1) - tread;
                    buffer += tread;
                }
                continue;
            }
        } else {
            // it is a command with no explicit len
            // so make sure that the final character is a space
            if (original[tread-1] != ' ') continue;
        }
        
        // command is complete so parse it
        return internal_parse_buffer(connection, original, tread, (clen) ? cstart : 0, (original == header), false);
    }
    
abort_read:
    if (original != (char *)&header) mem_free(original);
    return NULL;
}

static bool internal_socket_raw_write (SQCloudConnection *connection, const char *buffer) {
    // this function is used only to debug possible security issues
    int fd = connection->fd;
    #ifndef SQLITECLOUD_DISABLE_TSL
    struct tls *tls = connection->tls_context;
    #endif
    
    size_t len = strlen(buffer);
    size_t written = 0;
    while (len > 0) {
        #ifndef SQLITECLOUD_DISABLE_TSL
        ssize_t nwrote = (tls) ? tls_write(tls, buffer, len) : writesocket(fd, buffer, len);
        if ((tls) && (nwrote == TLS_WANT_POLLIN || nwrote == TLS_WANT_POLLOUT)) continue;
        #else
        ssize_t nwrote = writesocket(fd, buffer, len);
        #endif
        
        if (nwrote < 0) {
            const char *msg = "";
            #ifndef SQLITECLOUD_DISABLE_TSL
            if (tls) msg = tls_error(tls);
            #endif
            return internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "An error occurred while writing data: %s (%s).", strerror(errno), msg);
        } else if (nwrote == 0) {
            return true;
        } else {
            written += nwrote;
            buffer += nwrote;
            len -= nwrote;
        }
    }
    
    return true;
}

static bool internal_socket_write (SQCloudConnection *connection, const char *buffer, size_t len, bool mainfd, bool compute_header) {
    int fd = (mainfd) ? connection->fd : connection->pubsubfd;
    #ifndef SQLITECLOUD_DISABLE_TSL
    struct tls *tls = (mainfd) ? connection->tls_context : connection->tls_pubsub_context;
    #endif
    
    size_t written = 0;
    
    // write header
    if (compute_header) {
        char header[32];
        char *p = header;
        int hlen = snprintf(header, sizeof(header), "%c%zu ", (connection->isblob) ? CMD_BLOB : CMD_STRING, len);
        int len1 = hlen;
        while (len1) {
            #ifndef SQLITECLOUD_DISABLE_TSL
            ssize_t nwrote = (tls) ? tls_write(tls, p, len1) : writesocket(fd, p, len1);
            if ((tls) && (nwrote == TLS_WANT_POLLIN || nwrote == TLS_WANT_POLLOUT)) continue;
            #else
            ssize_t nwrote = writesocket(fd, p, len1);
            #endif
            
            if ((nwrote < 0) || (nwrote == 0 && written != hlen)) {
                const char *msg = "";
                #ifndef SQLITECLOUD_DISABLE_TSL
                if (tls) msg = tls_error(tls);
                #endif
                return internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "An error occurred while writing header data: %s (%s).", strerror(errno), msg);
            } else {
                written += nwrote;
                p += nwrote;
                len1 -= nwrote;
            }
        }
    }
    
    // write buffer
    written = 0;
    while (len > 0) {
        #ifndef SQLITECLOUD_DISABLE_TSL
        ssize_t nwrote = (tls) ? tls_write(tls, buffer, len) : writesocket(fd, buffer, len);
        if ((tls) && (nwrote == TLS_WANT_POLLIN || nwrote == TLS_WANT_POLLOUT)) continue;
        #else
        ssize_t nwrote = writesocket(fd, buffer, len);
        #endif
        
        if (nwrote < 0) {
            const char *msg = "";
            #ifndef SQLITECLOUD_DISABLE_TSL
            if (tls) msg = tls_error(tls);
            #endif
            return internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "An error occurred while writing data: %s (%s).", strerror(errno), msg);
        } else if (nwrote == 0) {
            return true;
        } else {
            written += nwrote;
            buffer += nwrote;
            len -= nwrote;
        }
    }
    
    return true;
}

static void internal_socket_set_timeout (int sockfd, int timeout_secs) {
    #ifdef _WIN32
    DWORD timeout = timeout_secs * 1000;
    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof timeout);
    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, (const char*)&timeout, sizeof timeout);
    #else
    struct timeval tv;
    tv.tv_sec = timeout_secs;
    tv.tv_usec = 0;
    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof tv);
    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, (const char*)&tv, sizeof tv);
    #endif
}

static bool internal_connect_apply_config (SQCloudConnection *connection, SQCloudConfig *config) {
    if (config->timeout) {
        internal_socket_set_timeout(connection->fd, config->timeout);
    }

    char buffer[2048];
    int len = 0;
    
    if (config->username && config->password && strlen(config->username) && strlen(config->password)) {
        char *command = config->password_hashed ? "HASH" : "PASSWORD";
        len += snprintf(&buffer[len], sizeof(buffer) - len, "AUTH USER %s %s %s;", config->username,  command, config->password);
    }
    
    if (config->database && strlen(config->database)) {
        if (config->db_create && !config->db_memory) len += snprintf(&buffer[len], sizeof(buffer) - len, "CREATE DATABASE %s IF NOT EXISTS;", config->database);
        len += snprintf(&buffer[len], sizeof(buffer) - len, "USE DATABASE %s;", config->database);
    }
    
    if (config->sqlite_mode) {
        len += snprintf(&buffer[len], sizeof(buffer) - len, "SET CLIENT KEY SQLITE TO 1;");
    }
    
    if (config->compression) {
        len += snprintf(&buffer[len], sizeof(buffer) - len, "SET CLIENT KEY COMPRESSION TO 1;");
    }
    
    if (config->zero_text) {
        len += snprintf(&buffer[len], sizeof(buffer) - len, "SET CLIENT KEY ZEROTEXT TO 1;");
    }
    
    if (config->nonlinearizable) {
        len += snprintf(&buffer[len], sizeof(buffer) - len, "SET CLIENT KEY NONLINEARIZABLE TO 1;");
    }
    
    if (config->no_blob) {
        len += snprintf(&buffer[len], sizeof(buffer) - len, "SET CLIENT KEY NOBLOB TO 1;");
    }
    
    if (config->max_data > 0) {
        len += snprintf(&buffer[len], sizeof(buffer) - len, "SET CLIENT KEY MAXDATA TO %d;", config->max_data);
    }
    
    if (config->max_rows > 0) {
        len += snprintf(&buffer[len], sizeof(buffer) - len, "SET CLIENT KEY MAXROWS TO %d;", config->max_rows);
    }
    
    if (config->max_rowset > 0) {
        len += snprintf(&buffer[len], sizeof(buffer) - len, "SET CLIENT KEY MAXROWSET TO %d;", config->max_rowset);
    }
    
    if (config->callback) {
        len += config->callback(&buffer[len], sizeof(buffer) - len, config->data);
    }
    
    if (len > 0) {
        SQCloudResult *res = internal_run_command(connection, buffer, strlen(buffer), true);
        if (res != &SQCloudResultOK) return false;
    }
    
    return true;
}

static bool internal_connect (SQCloudConnection *connection, const char *hostname, int port, SQCloudConfig *config, bool mainfd) {
    // ipv4/ipv6 specific variables
    struct addrinfo hints, *addr_list = NULL, *addr;
    
    // ipv6 code from https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzab6/xip6client.htm
    memset(&hints, 0, sizeof(hints));

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    if (config && config->family) {
        if (config->family == SQCLOUD_IPv6) hints.ai_family = AF_INET6;
        if (config->family == SQCLOUD_IPANY) hints.ai_family = AF_UNSPEC;
    }
    
    // get the address information for the server using getaddrinfo()
    char port_string[256];
    snprintf(port_string, sizeof(port_string), "%d", port);
    int rc = getaddrinfo(hostname, port_string, &hints, &addr_list);
    if (rc != 0 || addr_list == NULL) {
        return internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "Error while resolving getaddrinfo (host %s not found).", hostname);
    }
    
    // begin non-blocking connection loop
    int sock_index = 0;
    int sock_current = 0;
    int sock_list[MAX_SOCK_LIST] = {0};
    for (addr = addr_list; addr != NULL; addr = addr->ai_next, ++sock_index) {
        if (sock_index >= MAX_SOCK_LIST) break;
        if ((addr->ai_family != AF_INET) && (addr->ai_family != AF_INET6)) continue;
        
        sock_current = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
        if (sock_current < 0) continue;
        
        // set socket options
        int len = 1;
        setsockopt(sock_current, SOL_SOCKET, SO_KEEPALIVE, (const char *) &len, sizeof(len));
        len = 1;
        setsockopt(sock_current, IPPROTO_TCP, TCP_NODELAY, (const char *) &len, sizeof(len));
        #ifdef SO_NOSIGPIPE
        len = 1;
        setsockopt(sock_current, SOL_SOCKET, SO_NOSIGPIPE, (const char *) &len, sizeof(len));
        #endif
        
        // by default, an IPv6 socket created on Windows Vista and later only operates over the IPv6 protocol
        // in order to make an IPv6 socket into a dual-stack socket, the setsockopt function must be called
        if (addr->ai_family == AF_INET6) {
            #ifdef _WIN32
            DWORD ipv6only = 0;
            #else
            int   ipv6only = 0;
            #endif
            setsockopt(sock_current, IPPROTO_IPV6, IPV6_V6ONLY, (void *)&ipv6only, sizeof(ipv6only));
        }
        
        // turn on non-blocking
        unsigned long ioctl_blocking = 1;    /* ~0; //TRUE; */
        ioctl(sock_current, FIONBIO, &ioctl_blocking);
        
        // initiate non-blocking connect ignoring return code
        rc = connect(sock_current, addr->ai_addr, addr->ai_addrlen);
        
        // add sock_current to internal list of trying to connect sockets
        sock_list[sock_index] = sock_current;
    }
    
    // free not more needed memory
    freeaddrinfo(addr_list);
    
    // calculate the connection timeout and reset timers
    // if timeout is <= 0 then it is set to SQCLOUD_DEFAULT_TIMEOUT for the connect phase
    int connect_timeout = (config && config->timeout > 0) ? config->timeout : SQCLOUD_DEFAULT_TIMEOUT;
    time_t start = time(NULL);
    time_t now = start;
    rc = 0;
    
    int sockfd = 0;
    fd_set write_fds;
    fd_set except_fds;
    struct timeval tv;
    
    while (rc == 0 && ((now - start) < connect_timeout)) {
        FD_ZERO(&write_fds);
        FD_ZERO(&except_fds);
        
        int nfds = 0;
        for (int i=0; i<MAX_SOCK_LIST; ++i) {
            if (sock_list[i]) {
                FD_SET(sock_list[i], &write_fds);
                FD_SET(sock_list[i], &except_fds);
                if (nfds < sock_list[i]) nfds = sock_list[i];
            }
        }
        
        tv.tv_sec = connect_timeout;
        tv.tv_usec = 0;
        rc = select(nfds + 1, NULL, &write_fds, &except_fds, &tv);
        
        if (rc == 0) break; // timeout
        else if (rc == -1) {
            if (errno == EINTR || errno == EAGAIN || errno == EINPROGRESS) continue;
            break; // handle error
        }
        
        // check for error first
        for (int i=0; i<MAX_SOCK_LIST; ++i) {
            if (sock_list[i] > 0) {
                if (FD_ISSET(sock_list[i], &except_fds)) {
                    closesocket(sock_list[i]);
                    sock_list[i] = 0;
                }
            }
        }
        
        // check which file descriptor is ready (need to check for socket error also)
        for (int i=0; i<MAX_SOCK_LIST; ++i) {
            if (sock_list[i] > 0) {
                if (FD_ISSET(sock_list[i], &write_fds)) {
                    int err = socket_geterror(sock_list[i]);
                    if (err > 0) {
                        closesocket(sock_list[i]);
                        sock_list[i] = 0;
                    } else {
                        sockfd = sock_list[i];
                        break;
                    }
                }
            }
        }
        // check if a valid descriptor has been found
        if (sockfd != 0) break;
        
        // no socket ready yet
        now = time(NULL);
        rc = 0;
    }
    
    // close still opened sockets
    for (int i=0; i<MAX_SOCK_LIST; ++i) {
        if ((sock_list[i] > 0) && (sock_list[i] != sockfd)) closesocket(sock_list[i]);
    }
    
    // bail if there was an error
    if (rc < 0) {
        return internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "An error occurred while trying to connect: %s.", strerror(errno));
    }
    
    // bail if there was a timeout
    if ((time(NULL) - start) >= connect_timeout) {
        return internal_set_error(connection, INTERNAL_ERRCODE_NETWORK, "Connection timeout while trying to connect (%d).", connect_timeout);
    }
    
    // turn off non-blocking
    int ioctl_blocking = 0;    /* ~0; //TRUE; */
    ioctl(sockfd, FIONBIO, &ioctl_blocking);
    
    // finalize connection
    if (mainfd) {
        connection->fd = sockfd;
        connection->port = port;
        connection->hostname = mem_string_dup(hostname);
        #ifndef SQLITECLOUD_DISABLE_TSL
        if (config && !config->insecure) {
            rc = tls_connect_socket(connection->tls_context, sockfd, hostname);
            if (rc < 0) printf("Error on tls_connect_socket: %s\n", tls_error(connection->tls_context));
        }
        #endif
    } else {
        connection->pubsubfd = sockfd;
        #ifndef SQLITECLOUD_DISABLE_TSL
        if (config && !config->insecure) {
            rc = tls_connect_socket(connection->tls_pubsub_context, sockfd, hostname);
            if (rc < 0) printf("Error on tls_connect_socket\n");
        }
        #endif
    }
    return true;
}

bool internal_rowset_compare(SQCloudResult *rs1, SQCloudResult *rs2) {
    if (rs1 == NULL && rs2 == NULL) return true;
    if (rs1 == NULL && rs2 != NULL) return false;
    if (rs1 != NULL && rs2 == NULL) return false;
    
    if (rs1->nrows != rs2 ->nrows) return false;
    if (rs1->ncols != rs2 ->ncols) return false;
    
    uint32_t nrows = rs1->nrows;
    uint32_t ncols = rs1->ncols;
    
    // check column names
    for (uint32_t i=0; i<ncols; ++i) {
        uint32_t len1 = internal_buffer_maxlen(rs1, rs1->name[i]);
        char *value1 = internal_parse_value(rs1->name[i], &len1, NULL);
        
        uint32_t len2 = internal_buffer_maxlen(rs2, rs2->name[i]);
        char *value2 = internal_parse_value(rs2->name[i], &len2, NULL);
        
        if (len1 != len2) return false;
        if (strncmp(value1, value2, len1) != 0) return false;
    }
    
    // check types
    for (uint32_t i=0; i<nrows; ++i) {
        for (uint32_t j=0; j<ncols; ++j) {
            SQCLOUD_VALUE_TYPE type1 = SQCloudRowsetValueType(rs1, i, j);
            SQCLOUD_VALUE_TYPE type2 = SQCloudRowsetValueType(rs2, i, j);
            if (type1 != type2) return false;
        }
    }
    
    // check values
    for (uint32_t i=0; i<nrows * ncols; ++i) {
        uint32_t len1 = internal_buffer_maxlen(rs1, rs1->data[i]);
        char *value1 = internal_parse_value(rs1->data[i], &len1, NULL);
        
        uint32_t len2 = internal_buffer_maxlen(rs2, rs2->data[i]);
        char *value2 = internal_parse_value(rs2->data[i], &len2, NULL);
        
        if (len1 != len2) return false;
        if (value1 == NULL && value2 == NULL) return true;
        if (value1 == NULL || value2 == NULL) return false;
        if (memcmp(value1, value2, len1) != 0) return false;
    }
    
    return true;
}

void internal_rowset_dump (SQCloudResult *result, uint32_t maxline, bool quiet) {
    uint32_t nrows = result->nrows;
    uint32_t ncols = result->ncols;
    
    // if user specify a maxline then do not print more than maxline characters for every column
    if (maxline > 0) {
        for (uint32_t i=0; i<ncols; ++i) {
            if (result->clen[i] > maxline) result->clen[i] = maxline;
        }
    }
    
    // print separator header
    for (uint32_t i=0; i<ncols; ++i) {
        for (uint32_t j=0; j<result->clen[i]+2; ++j) putchar('-');
        putchar('|');
    }
    printf("\n");
    
    // print column names
    for (uint32_t i=0; i<ncols; ++i) {
        uint32_t len = internal_buffer_maxlen(result, result->name[i]);
        uint32_t delta = 0;
        char *value = internal_parse_value(result->name[i], &len, NULL);
        
        // UTF-8 strings need special adjustments
        uint32_t utf8len = utf8_len(value, len);
        if (utf8len != len) delta = len - utf8len;
        printf(" %-*.*s |", result->clen[i] + delta, (maxline && len > maxline) ? maxline : len, value);
    }
    printf("\n");
    
    // print separator header
    for (uint32_t i=0; i<ncols; ++i) {
        for (uint32_t j=0; j<result->clen[i]+2; ++j) putchar('-');
        putchar('|');
    }
    printf("\n");
    
    #if 0
    // print types (just for debugging)
    printf("\n");
    for (uint32_t i=0; i<nrows; ++i) {
        for (uint32_t j=0; j<ncols; ++j) {
            SQCloudValueType type = SQCloudRowsetValueType(result, i, j);
            printf("%d ", type);
        }
        printf("\n");
    }
    printf("\n");
    #endif
    
    // print result
    for (uint32_t i=0; i<nrows * ncols; ++i) {
        uint32_t len = internal_buffer_maxlen(result, result->data[i]);
        uint32_t delta = 0;
        char *value = internal_parse_value(result->data[i], &len, NULL);

        // UTF-8 strings need special adjustments
        if (!value) {value = "NULL"; len = 4;}
        uint32_t utf8len = utf8_len(value, len);
        if (utf8len != len) delta = len - utf8len;
        printf(" %-*.*s |", (result->clen[i % ncols]) + delta, (maxline && len > maxline) ? maxline : len, value);
        
        bool newline = (((i+1) % ncols == 0) || (ncols == 1));
        if (newline) printf("\n");
    }
    
    // print footer
    for (uint32_t i=0; i<ncols; ++i) {
        for (uint32_t j=0; j<result->clen[i]+2; ++j) putchar('-');
        putchar('|');
    }
    printf("\n");
    
    printf("Rows: %d - Cols: %d - Bytes: %d", result->nrows, result->ncols, result->blen);
    if (!quiet) printf(" Time: %f secs", result->time);
    fflush( stdout );
}

bool internal_upload_database (SQCloudConnection *connection, const char *dbname, const char *key, bool isfiletransfer, uint64_t snapshotid, bool isinternaldb, void *xdata, int64_t dbsize, int (*xCallback)(void *xdata, void *buffer, uint32_t *blen, int64_t ntot, int64_t nprogress)) {
    // xCallback is mandatory
    if (!xCallback) return false;
    
    const char *keyarg = key ? "KEY " : "";
    const char *keyvalue = key ? key : "";
    
    // prepare command to execute
    char command[512]; 
    if (isfiletransfer) {
        char *internalarg = isinternaldb ? "INTERNAL" : "";
        snprintf(command, sizeof(command), "TRANSFER DATABASE '%s' %s%s SNAPSHOT %" PRIu64 " %s", dbname, keyarg, keyvalue, snapshotid, internalarg);
    } else {
        snprintf(command, sizeof(command), "UPLOAD DATABASE '%s' %s%s", dbname, keyarg, keyvalue);
    }
    
    // execute command on server side
    SQCloudResult *res = SQCloudExec(connection, command);
    bool isOK = (SQCloudResultType(res) == RESULT_OK);
    SQCloudResultFree(res);
    if (!isOK) return false;
    
    void *buffer = mem_alloc(SQCLOUD_DEFAULT_UPLOAD_SIZE);
    if (!buffer) return internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate a buffer of size %d.", SQCLOUD_DEFAULT_UPLOAD_SIZE);
    
    uint32_t blen = 0;
    int64_t nprogress = 0;
    do {
        // execute callback to read buffer
        blen = SQCLOUD_DEFAULT_UPLOAD_SIZE;
        int rc = xCallback(xdata, buffer, &blen, dbsize, nprogress);
        if (rc != 0) {
            SQCloudResult *res = SQCloudExec(connection, "UPLOAD ABORT");
            SQCloudResultFree(res);
            return false;
        }
        
        // send BLOB
        if (internal_send_blob(connection, buffer, blen) == false) return false;
        
        // update progress
        nprogress += blen;
    } while (blen > 0);
    
    return true;
}

// n is the total number of items in the array
// count is the total number of items contained in r and len
// instead of build a new text buffer +LEN TEXT
// is it easier to send +LEN in a buffer
// and TEXT in the next buffer
// that's the reason why count and n can be different
SQCloudResult *internal_array_exec (SQCloudConnection *connection, const char *r[], int64_t len[], uint32_t n, uint32_t count) {
    char header[512];
    char nitems[64];
    int64_t totsize = 0;
    
    internal_clear_error(connection);
    
    // compute total array size
    for (int i=0; i<count; ++i) totsize += len[i];
    
    // build header
    // =LEN N VALUE1 VALUE2 ... VALUEN
    
    TIME_GET(tstart);
    int nlen = snprintf(nitems, sizeof(nitems), "%d ", n);
    int hlen = snprintf(header, sizeof(header), "%c%lld %s", CMD_ARRAY, totsize+nlen, nitems);
    if (!internal_socket_write(connection, header, hlen, true, false)) return NULL;
    
    // send each individual array item
    for (int i=0; i<count; ++i) {
        if (!internal_socket_write(connection, r[i], (size_t)len[i], true, false)) return NULL;
    }
    
    // read reply
    SQCloudResult *result = internal_socket_read(connection, true);
    TIME_GET(tend);
    
    if (result) result->time = TIME_VAL(tstart, tend);
    return result;
    
abort:
    return NULL;
}

void internal_free_config (SQCloudConfig *config) {
    if (config->username) mem_free((void *)config->username);
    if (config->password) mem_free((void *)config->password);
    if (config->database) mem_free((void *)config->database);
    #ifndef SQLITECLOUD_DISABLE_TSL
    if (config->tls_root_certificate) mem_free((void *)config->tls_root_certificate);
    if (config->tls_certificate) mem_free((void *)config->tls_certificate);
    if (config->tls_certificate_key) mem_free((void *)config->tls_certificate_key);
    #endif
    mem_free(config);
}

// MARK: - URL -

static int char2hex (int c) {
    if (isdigit(c)) return (c - '0');
    c = toupper(c);
    if (c >='A' && c <='F') return (c - 'A' + 0x0A);
    return -1;
}

static int url_decode (char s[512]) {
    int i = 0;
    int j = 0;
    int len = (int)strlen(s);
    
    while (i < len) {
        int c = s[i];
        if (c == '%') {
            if (i + 2 >= len) return 0;
            c = (char2hex(s[i+1]) * 0x10) + char2hex(s[i+2]);
            if (c < 0) return 0;
            s[j] = c;
            i += 2;
        } else {
            s[j] = c;
        }
        ++i;
        ++j;
    }
    s[j] = 0;
    return j;
}

static int url_extract_username_password (const char *s, char b1[512], char b2[512]) {
    // user:pass@host.com:port/dbname?timeout=10&key2=value2&key3=value3
    
    // lookup username (if any)
    char *username = strchr(s, ':');
    if (!username) return 0;
    size_t len = username - s;
    if (len > 511) return -1;
    memcpy(b1, s, len);
    b1[len] = 0;
    if (url_decode(b1) <= 0) return 0;
    
    // lookup username (if any)
    char *password = strchr(s, '@');
    if (!password) return 0;
    len = password - username - 1;
    if (len > 511) return -1;
    memcpy(b2, username+1, len);
    b2[len] = 0;
    if (url_decode(b2) <= 0) return 0;
    
    return (int)(password - s) + 1;
}

static int url_extract_hostname_port (const char *s, char b1[512], char b2[512]) {
    // host.com:port/dbname?timeout=10&key2=value2&key3=value3
    
    // lookup hostname (if any)
    char *hostname = strchr(s, ':');
    if (!hostname) hostname = strchr(s, '/');
    if (!hostname) hostname = strchr(s, '?');
    if (!hostname) hostname = strchr(s, 0);
    if (!hostname) return -1;
    size_t len = hostname - s;
    if (len > 511) return -1;
    memcpy(b1, s, len);
    b1[len] = 0;
    if (url_decode(b1) <= 0) return 0;
    
    // lookup port (if any)
    char *port = strchr(s, ':');
    if (port) {
        char *p = port + 1;
        ++len;
        
        int i = 0;
        while (p[0]) {
            if ((p[0] == '/') || (p[0] == '?') || (p[0] == 0)) break;
            if (i+1 > 511) return -1;
            b2[i++] = p[0];
            ++len;
            ++p;
        }
        b2[len] = 0;
        if (url_decode(b2) <= 0) return 0;
    }
    
    // adjust returned len
    if (s[len] != 0) ++len;
    
    return (int)len;
}

static int url_extract_database (const char *s, char b1[512]) {
    // dbname?timeout=10&key2=value2&key3=value3
    
    // lookup database (if any)
    char *database = strchr(s, '?');
    if (database) {
        size_t len = database - s;
        if (len > 511) return -1;
        memcpy(b1, s, len);
        b1[len] = 0;
        if (url_decode(b1) <= 0) return 0;
        
        return (int)(len + 1);
    }
    
    // there is no ? separator character
    // that means that there should be
    // no key/value
    char *guard = strchr(s, '=');
    if (guard) return 0;
    
    // database name is the s string
    size_t len = strlen(s);
    if (len > 511) return -1;
    memcpy(b1, s, len);
    b1[len] = 0;
    if (url_decode(b1) <= 0) return 0;
    
    return (int)len;
}

static int url_extract_keyvalue (const char *s, char b1[512], char b2[512]) {
    // timeout=10&key2=value2&key3=value3
    
    // lookup key (if any)
    char *key = strchr(s, '=');
    if (!key) return 0;
    size_t len = key - s;
    if (len > 511) return -1;
    memcpy(b1, s, len);
    b1[len] = 0;
    if (url_decode(b1) <= 0) return 0;
    
    // lookup value (if any)
    char *value = strchr(s, '&');
    if (!value) value = strchr(s, 0);
    if (!value) return 0;
    len = value - key - 1;
    if (len > 511) return -1;
    memcpy(b2, key+1, len);
    b2[len] = 0;
    if (url_decode(b2) <= 0) return 0;
    
    return (int)(value - s) + 1;
}

// MARK: - RESERVED -

SQCloudResult *_reserved0 (SQCloudConnection *connection, const char *buffer, size_t blen, bool compute_header) {
    internal_clear_error(connection);
    
    if (!buffer || blen < CMD_MINLEN) return NULL;
    
    TIME_GET(tstart);
    if (!internal_socket_write(connection, buffer, blen, true, compute_header)) return NULL;
    SQCloudResult *result = internal_socket_read(connection, true);
    TIME_GET(tend);
    if (result) result->time = TIME_VAL(tstart, tend);
    return result;
}


bool _reserved1 (SQCloudConnection *connection, const char *command, size_t len, bool compute_header, bool (*forward_cb) (char *buffer, size_t blen, void *xdata, void *xdata2), void *xdata, void *xdata2) {
    if (!forward_cb) return false;
    if (!internal_socket_write(connection, command, len, true, compute_header)) return false;
    if (!internal_socket_forward_read(connection, forward_cb, xdata, xdata2)) return false;
    return true;
}

SQCloudResult *_reserved2 (SQCloudConnection *connection, const char *UUID) {
    char buffer[1024];
    snprintf(buffer, sizeof(buffer), "SET CLIENT KEY UUID TO %s;", UUID);
    return internal_run_command(connection, buffer, strlen(buffer), true);
}

SQCloudResult *_reserved3 (char *buffer, uint32_t blen, uint32_t cstart, SQCloudResult *chunk) {
    SQCloudConnection connection = {0};
    connection._chunk = chunk;
    SQCloudResult *res = internal_parse_buffer(&connection, buffer, blen, cstart, false, true);
    return res;
}

uint32_t _reserved4 (char *buffer, uint32_t blen, uint32_t *cstart) {
    return internal_parse_number(buffer, blen, cstart);
}

bool _reserved5 (SQCloudResult *res) {
    return res->ischunk;
}

bool _reserved6 (SQCloudConnection *connection, const char *buffer) {
    internal_clear_error(connection);
    return internal_socket_raw_write(connection, buffer);
}

SQCloudResult *_reserved7 (SQCloudConnection *connection) {
    return internal_socket_read(connection, true);
}

bool _reserved8 (SQCloudConnection *connection, const char *dbname, const char *key, uint64_t snapshotid, bool isinternaldb, void *xdata, int64_t dbsize, int (*xCallback)(void *xdata, void *buffer, uint32_t *blen, int64_t ntot, int64_t nprogress)) {
    return internal_upload_database(connection, dbname, key, true, snapshotid, isinternaldb, xdata, dbsize, xCallback);
}

int _reserved9 (char *buffer) {
    return internal_parse_type(buffer);
}

char *_reserved10 (char *buffer, uint32_t *len, uint32_t *cellsize) {
    return internal_parse_value(buffer, len, cellsize);
}

char *_reserved11 (char *buffer, uint32_t blen, uint32_t index, uint32_t *len, uint32_t *cellsize, uint32_t *pos, int *type, SQCLOUD_INTERNAL_ERRCODE *err) {
    if (err) *err = INTERNAL_ERRCODE_NONE;
    
    // =LEN N VALUE1 VALUE2 ... VALUEN
    if (buffer[0] != CMD_ARRAY) {
        if (err) *err = INTERNAL_ERRCODE_FORMAT;
        return NULL;
    }
        
    char *p = buffer;
    do {
        ++buffer;
        --blen;
    }
    while (buffer[0] != ' ');
    ++buffer; --blen;
    
    uint32_t tcellsize = 0;
    uint32_t n = internal_parse_number(buffer, blen, &tcellsize);
    if (index >= n) {
        if (err) *err = INTERNAL_ERRCODE_INDEX;
        return NULL;
    }
        
    buffer += tcellsize;
    blen -= tcellsize;
    
    uint32_t tlen = blen;
    uint32_t csize = 0;
    for (int i=0; i<=index; ++i) {
        tcellsize = 0;
        char *value = internal_parse_value(buffer, &tlen, &tcellsize);
        
        if (i == index) {
            if (type && buffer) *type = buffer[0];
            if (len) *len = tlen;
            if (cellsize) *cellsize = tcellsize;
            if (pos) *pos = (uint32_t)(value - p);
            return value;
        }
        
        buffer += tcellsize;
        csize += tcellsize;
        tlen = blen - csize;
    }
    
    return NULL;
}

int32_t _reserved12 (char *buffer, uint32_t blen) {
    return internal_array_count(buffer, blen);
}

bool _reserved13 (SQCloudConnection *connection, const char *dbname, void *xdata,
                                      int (*xCallback)(void *xdata, const void *buffer, uint32_t blen, int64_t ntot, int64_t nprogress), uint64_t *raft_index, bool ifexists) {
    // xCallback is mandatory
    if (!xCallback) return false;
    
    // prepare command to execute
    char buffer[512];
    snprintf(buffer, sizeof(buffer), "DOWNLOAD DATABASE %s%s", dbname, (ifexists) ? " IF EXISTS" : "");
    
    // execute command on server side
    SQCloudResult *res = SQCloudExec(connection, buffer);
    
    // reply must be an Array value (otherwise it is an error)
    if (SQCloudResultType(res) != RESULT_ARRAY) return false;
    
    // res is an ARRAY (database size, number of pages, raft_index)
    int64_t db_size = SQCloudArrayInt64Value(res, 0);
    int64_t rindex = SQCloudArrayInt64Value(res, 2);
    SQCloudResultFree(res);
    
    // loop to download
    int64_t progress_size = 0;
    snprintf(buffer, sizeof(buffer), "DOWNLOAD STEP");
    
    while (progress_size < db_size) {
        res = SQCloudExec(connection, buffer);
        
        // reply must be a BLOB value (otherwise it is an error)
        if (SQCloudResultType(res) != RESULT_BLOB) return false;
        
        // res is BLOB, decode it
        const void *data = (const void *)SQCloudResultBuffer(res);
        uint32_t datalen = SQCloudResultLen(res);
        
        // execute callback (with progress_size updated)
        progress_size += datalen;
        int rc = xCallback(xdata, data, datalen, db_size, progress_size);
        SQCloudResultFree(res);
        
        // check exit condition
        if (datalen == 0) break;
        
        // check if download should be cancelled
        if (rc != 0) {
            snprintf(buffer, sizeof(buffer), "DOWNLOAD ABORT");
            SQCloudExec(connection, buffer);
            return false;
        }
    }
    
    if (raft_index) *raft_index = rindex;
    return true;
}

// MARK: - PUBLIC -

SQCloudConnection *SQCloudConnect (const char *hostname, int port, SQCloudConfig *config) {
    internal_init();
    
    SQCloudConnection *connection = mem_zeroalloc(sizeof(SQCloudConnection));
    if (!connection) return NULL;
    connection->_config = config;
    
    if (!internal_setup_tls(connection, config, true)) return connection;
    
    if (internal_connect(connection, hostname, port, config, true)) {
        if (config) internal_connect_apply_config(connection, config);
    }
    
    return connection;
}

SQCloudConnection *SQCloudConnectWithString (const char *s, SQCloudConfig *pconfig) {
    // URL STRING FORMAT
    // sqlitecloud://user:pass@host.com:port/dbname?timeout=10&key2=value2&key3=value3
    
    // sanity check
    const char domain[] = "sqlitecloud://";
    int n = sizeof(domain) - 1;
    if (strncmp(s, domain, n) != 0) return NULL;
    size_t slen = strlen(s);
    
    // config struct
    SQCloudConfig *config = (SQCloudConfig *)mem_zeroalloc(sizeof(SQCloudConfig));
    if (!config) return NULL;
    
    // default IPv4
    config->family = SQCLOUD_IPv4;
    
    // lookup for optional username/password
    char username[512];
    char password[512];
    int rc = url_extract_username_password(&s[n], username, password);
    if (rc == -1) goto abort_connect;
    
    if (rc) {
        config->username = mem_string_dup(username);
        config->password = mem_string_dup(password);
    }
    
    // lookup for mandatory hostname
    n += rc;
    if (n >= slen) goto abort_connect;
    
    char hostname[512];
    char port_s[512];
    rc = url_extract_hostname_port(&s[n], hostname, port_s);
    if (rc <= 0) goto abort_connect;
        
    int port = (int)strtol(port_s, NULL, 0);
    if (port <= 0) port = SQCLOUD_DEFAULT_PORT;
    
    // lookup for optional database
    n += rc;
    if (n < slen) {
        char database[512];
        rc = url_extract_database(&s[n], database);
        if (rc == -1) goto abort_connect;
        
        if (rc > 0) {
            config->database = mem_string_dup(database);
            config->db_memory = (strcmp(database, ":memory:") == 0 || strcmp(database, ":temp:") == 0);
        }
    }
    
    // lookup for optional key(s)/value(s)
    n += rc;
    char key[512];
    char value[512];
    while ((n < slen) && (rc = url_extract_keyvalue(&s[n], key, value)) > 0) {
        if (strcasecmp(key, "timeout") == 0) {
            int timeout = (int)strtol(value, NULL, 0);
            config->timeout = (timeout > 0) ? timeout : 0;
        }
        else if (strcasecmp(key, "compression") == 0) {
            int compression = (int)strtol(value, NULL, 0);
            config->compression = (compression > 0) ? true : false;
        }
        else if (strcasecmp(key, "sqlite") == 0) {
            int sqlite_mode = (int)strtol(value, NULL, 0);
            config->sqlite_mode = (sqlite_mode > 0) ? true : false;
        }
        else if (strcasecmp(key, "zerotext") == 0) {
            int zero_text = (int)strtol(value, NULL, 0);
            config->zero_text = (zero_text > 0) ? true : false;
        }
        else if (strcasecmp(key, "memory") == 0) {
            int in_memory = (int)strtol(value, NULL, 0);
            if (in_memory) config->database = mem_string_dup(":memory:");
        }
        else if (strcasecmp(key, "create") == 0) {
            int db_create = (int)strtol(value, NULL, 0);
            if (db_create) config->db_create = (db_create > 0) ? true : false;
        }
        #ifndef SQLITECLOUD_DISABLE_TSL
        else if (strcasecmp(key, "insecure") == 0) {
            int insecure = (int)strtol(value, NULL, 0);
            config->insecure = (insecure > 0) ? true : false;
        }
        else if (strcasecmp(key, "root_certificate") == 0) {
            config->tls_root_certificate = mem_string_dup(value);
        }
        else if (strcasecmp(key, "client_certificate") == 0) {
            config->tls_certificate = mem_string_dup(value);
        }
        else if (strcasecmp(key, "client_certificate_key") == 0) {
            config->tls_certificate_key = mem_string_dup(value);
        }
        #endif
        else if (strcasecmp(key, "noblob") == 0) {
            int no_blob = (int)strtol(value, NULL, 0);
            config->no_blob = (no_blob > 0) ? true : false;
        }
        else if (strcasecmp(key, "maxdata") == 0) {
            config->max_data = (int)strtol(value, NULL, 0);
        }
        else if (strcasecmp(key, "maxrows") == 0) {
            config->max_rows = (int)strtol(value, NULL, 0);
        }
        else if (strcasecmp(key, "maxrowset") == 0) {
            config->max_rowset = (int)strtol(value, NULL, 0);
        }
        n += rc;
    }
    
    // config parameter is used to force some configuration flags
    if (pconfig) {
        if (pconfig->timeout) config->timeout = pconfig->timeout;
        if (pconfig->compression) config->compression = pconfig->compression;
        if (pconfig->sqlite_mode) config->sqlite_mode = pconfig->sqlite_mode;
        if (pconfig->zero_text) config->zero_text = pconfig->zero_text;
        if (pconfig->nonlinearizable) config->nonlinearizable = pconfig->nonlinearizable;
        if (pconfig->no_blob) config->no_blob = pconfig->no_blob;
        if (pconfig->db_create) config->db_create = pconfig->db_create;
        if (pconfig->max_data) config->max_data = pconfig->max_data;
        if (pconfig->max_rows) config->max_rows = pconfig->max_rows;
        if (pconfig->max_rowset) config->max_rowset = pconfig->max_rowset;
        if (pconfig->insecure) config->insecure = pconfig->insecure;
        if (pconfig->db_memory) {
            if (config->database) mem_free((void *)config->database);
            config->database = mem_string_dup(":memory:");
        }
    }
    
    SQCloudConnection *connection = SQCloudConnect(hostname, port, config);
    if (connection) connection->config_to_free = true;
    else goto abort_connect;
    
    return connection;
    
abort_connect:
    if (config) internal_free_config(config);
    return NULL;
}

SQCloudResult *SQCloudExec (SQCloudConnection *connection, const char *command) {
    return internal_run_command(connection, command, strlen(command), true);
}

SQCloudResult *SQCloudExecArray (SQCloudConnection *connection, const char *command, const char **values, uint32_t len[], SQCLOUD_VALUE_TYPE types[], uint32_t n) {
    if (!command) return NULL;
    if (n == 0) return SQCloudExec(connection, command);
    
    // compute the maximum number of required slots
    uint32_t ritems = n + 1; // add command
    uint32_t count = ritems * 2;
    SQCloudResult *result = NULL;
    
    // avoid dynamic memory allocation (if possible) with a 256 static array
    char s_head[ARRAY_STATIC_COUNT * ARRAY_HEADER_BUFFER_SIZE];
    const char *s_r[ARRAY_STATIC_COUNT];
    int64_t s_rlen[ARRAY_STATIC_COUNT];
    char *d_head = NULL;
    const char **d_r = NULL;
    int64_t *d_rlen = NULL;
    
    // initially set pointers to static buffers
    char *head = (char *)s_head;
    const char **r = s_r;
    int64_t *rlen = s_rlen;
    
    // check if dynamically allocated memory is required
    if (count >= ARRAY_STATIC_COUNT) {
        d_head = (char *)mem_alloc(count * ARRAY_HEADER_BUFFER_SIZE);
        d_r = (const char **)mem_alloc(count * sizeof(char *));
        d_rlen = (int64_t *)mem_alloc(count * sizeof(int64_t));
        if ((!d_head) || (!d_r) || (!d_rlen)) goto cleanup;
        
        head = d_head;
        r = d_r;
        rlen = d_rlen;
    }
    
    // 1st array item is the command
    size_t command_len = strlen(command) + 1; // +1 because string must be NULL terminated
    rlen[0] = snprintf(head, ARRAY_HEADER_BUFFER_SIZE, "%c%lu ", CMD_ZEROSTRING, command_len);
    rlen[1] = (int64_t)command_len;
    r[0] = head;
    r[1] = command;
   
    // update head ptr
    head += rlen[1] + 1;
    
    uint32_t index = 2;
    for (int i=0; i<n; ++i) {
        switch (types[i]) {
            case VALUE_INTEGER:
            case VALUE_FLOAT: {
                int c = (types[i] == VALUE_INTEGER) ? CMD_INT : CMD_FLOAT;
                rlen[index] = snprintf(head, ARRAY_HEADER_BUFFER_SIZE, "%c%s ", c, values[i]);
                r[index] = head;
                --count;
                ++index;
            } break;
                
            case VALUE_NULL: {
                rlen[index] = snprintf(head, ARRAY_HEADER_BUFFER_SIZE, "_ ");
                r[index] = head;
                --count;
                ++index;
            } break;
                
            case VALUE_TEXT:
            case VALUE_BLOB: {
                int c = (types[i] == VALUE_TEXT) ? CMD_ZEROSTRING : CMD_BLOB;
                uint32_t size = (types[i] == VALUE_TEXT) ? len[i]+1 : len[i]; // +1 because string must be NULL terminated
                rlen[index] = snprintf(head, ARRAY_HEADER_BUFFER_SIZE, "%c%u ", c, size);
                rlen[index+1] = (int64_t)size;
                r[index] = head;
                r[index+1] = values[i];
                index += 2;
            } break;
        }
        
        // update head ptr
        head += rlen[i+2] + 1;
    }

    result = internal_array_exec(connection, r, rlen, ritems, count);
    
cleanup:
    if (count >= ARRAY_STATIC_COUNT) {
        // free dynamically allocated memory
        if (d_head) mem_free(d_head);
        if (d_r) mem_free(d_r);
        if (d_rlen) mem_free(d_rlen);
    }
    
    return result;
}

void SQCloudDisconnect (SQCloudConnection *connection) {
    if (!connection) return;
    
    // free TLS
    #ifndef SQLITECLOUD_DISABLE_TSL
    if (connection->tls_context) {
        tls_close(connection->tls_context);
        tls_free(connection->tls_context);
    }
    
    if (connection->tls_pubsub_context) {
        tls_close(connection->tls_pubsub_context);
        tls_free(connection->tls_pubsub_context);
    }
    #endif
    
    // try to gracefully close connections
    if (connection->fd) {
        closesocket(connection->fd);
    }
    
    if (connection->pubsubfd) {
        closesocket(connection->pubsubfd);
    }
    
    // free memory
    if (connection->hostname) {
        mem_free(connection->hostname);
    }
    
    if (connection->uuid) {
        mem_free(connection->uuid);
    }
    
    if (connection->config_to_free) {
        internal_free_config(connection->_config);
    }
    
    mem_free(connection);
}

void SQCloudSetPubSubCallback (SQCloudConnection *connection, SQCloudPubSubCB callback, void *data) {
    connection->callback = callback;
    connection->data = data;
}

SQCloudResult *SQCloudSetPubSubOnly (SQCloudConnection *connection) {
    if (!connection->callback) {
        internal_set_error(connection, INTERNAL_ERRCODE_PUBSUB, "A PubSub callback must be set before executing a PUBSUB ONLY command.");
        return NULL;
    }
    
    const char *command = "PUBSUB ONLY";
    return internal_run_command(connection, command, strlen(command), true);
}

const char *SQCloudUUID (SQCloudConnection *connection) {
    return (const char *)connection->uuid;
}

// MARK: - ERROR -

bool SQCloudIsError (SQCloudConnection *connection) {
    return (!connection || connection->errcode);
}

bool SQCloudIsSQLiteError (SQCloudConnection *connection) {
    // https://www.sqlite.org/rescode.html
    return (connection && connection->errcode < 10000);
}

int SQCloudErrorCode (SQCloudConnection *connection) {
    return (connection) ? connection->errcode : INTERNAL_ERRCODE_GENERIC;
}

int SQCloudExtendedErrorCode (SQCloudConnection *connection) {
    return (connection) ? connection->extcode : 0;
}

int SQCloudErrorOffset (SQCloudConnection *connection) {
    return (connection) ? connection->offcode : -1;
}

const char *SQCloudErrorMsg (SQCloudConnection *connection) {
    return (connection) ? connection->errmsg : "Not enough memory to allocate a SQCloudConnection.";
}

void SQCloudErrorReset (SQCloudConnection *connection) {
    internal_clear_error(connection);
}

void SQCloudErrorSetCode (SQCloudConnection *connection, int errcode) {
    connection->errcode = errcode;
}

void SQCloudErrorSetMsg (SQCloudConnection *connection, const char *format, ...) {
    va_list arg;
    va_start (arg, format);
    vsnprintf(connection->errmsg, sizeof(connection->errmsg), format, arg);
    va_end (arg);
}

// MARK: - RESULT -

SQCLOUD_RESULT_TYPE SQCloudResultType (SQCloudResult *result) {
    return (result) ? result->tag : RESULT_ERROR;
}

bool SQCloudResultIsOK (SQCloudResult *result) {
    return (result == &SQCloudResultOK);
}

bool SQCloudResultIsError (SQCloudResult *result) {
    return (!result);
}

uint32_t SQCloudResultLen (SQCloudResult *result) {
    return (result) ? result->blen : 0;
}

char *SQCloudResultBuffer (SQCloudResult *result) {
    return (result) ? result->buffer : NULL;
}

int32_t SQCloudResultInt32 (SQCloudResult *result) {
    if ((!result) || (result->tag != RESULT_INTEGER)) return 0;
    
    char *buffer = result->buffer;
    buffer[result->blen] = 0;
    return (int32_t)strtol(buffer, NULL, 0);
}

int64_t SQCloudResultInt64 (SQCloudResult *result) {
    if ((!result) || (result->tag != RESULT_INTEGER)) return 0;
    
    char *buffer = result->buffer;
    buffer[result->blen] = 0;
    return (int64_t)strtoll(buffer, NULL, 0);
}

double SQCloudResultDouble (SQCloudResult *result) {
    if ((!result) || (result->tag != RESULT_FLOAT)) return 0.0;
    
    char *buffer = result->buffer;
    buffer[result->blen] = 0;
    return (double)strtod(buffer, NULL);
}

float SQCloudResultFloat (SQCloudResult *result) {
    if ((!result) || (result->tag != RESULT_FLOAT)) return 0.0;
    
    char *buffer = result->buffer;
    buffer[result->blen] = 0;
    return (float)strtof(buffer, NULL);
}

void SQCloudResultFree (SQCloudResult *result) {
    if (!result || (result == &SQCloudResultOK) || (result == &SQCloudResultNULL)) return;
    
    if (!result->ischunk && !result->externalbuffer) {
        mem_free(result->rawbuffer);
    }
    
    if (result->tag == RESULT_ROWSET) {
        mem_free(result->name);
        mem_free(result->data);
        mem_free(result->clen);
        if (result->decltype) mem_free(result->decltype);
        if (result->dbname) mem_free(result->dbname);
        if (result->tblname) mem_free(result->tblname);
        if (result->origname) mem_free(result->origname);
        
        if (result->ischunk && !result->externalbuffer) {
            for (uint32_t i = 0; i<result->bcount; ++i) {
                if (result->buffers[i]) mem_free(result->buffers[i]);
            }
            mem_free(result->buffers);
            mem_free(result->blens);
            mem_free(result->nheads);
        }
    }
    
    if (result->tag == RESULT_ARRAY) {
        mem_free(result->data);
    }
    
    mem_free(result);
}

void SQCloudResultDump (SQCloudConnection *connection, SQCloudResult *result) {
    // res NULL means to read error message and error code from conn
    SQCLOUD_RESULT_TYPE type = SQCloudResultType(result);
    switch (type) {
        case RESULT_OK:
            printf("OK");
            break;
            
        case RESULT_ERROR:
            printf("ERROR: %s (%d)", SQCloudErrorMsg(connection), SQCloudErrorCode(connection));
            break;
            
        case RESULT_NULL:
            printf("NULL");
            break;
            
        case RESULT_STRING:
            (SQCloudResultLen(result)) ? printf("%.*s", SQCloudResultLen(result), SQCloudResultBuffer(result)) : printf("");
            break;
            
        case RESULT_JSON:
        case RESULT_INTEGER:
        case RESULT_FLOAT:
            printf("%.*s", SQCloudResultLen(result), SQCloudResultBuffer(result));
            break;
            
        case RESULT_ARRAY:
            SQCloudArrayDump(result);
            break;
            
        case RESULT_ROWSET:
            SQCloudRowsetDump(result, 0, false);
            break;
            
        case RESULT_BLOB:
            printf("BLOB data with len: %d", SQCloudResultLen(result));
            break;
    }
    
    printf("\n\n");
}

// MARK: - ROWSET -

// https://database.guide/2-sample-databases-sqlite/
// https://embeddedartistry.com/blog/2017/07/05/printf-a-limited-number-of-characters-from-a-string/
// https://stackoverflow.com/questions/1809399/how-to-format-strings-using-printf-to-get-equal-length-in-the-output

// SET DATABASE mediastore.sqlite
// SELECT * FROM Artist LIMIT 10;

static bool SQCloudRowsetSanityCheck (SQCloudResult *result, uint32_t row, uint32_t col) {
    if (!result || result->tag != RESULT_ROWSET) return false;
    if ((row >= result->nrows) || (col >= result->ncols)) return false;
    return true;
}

SQCLOUD_VALUE_TYPE SQCloudRowsetValueType (SQCloudResult *result, uint32_t row, uint32_t col) {
    if (!SQCloudRowsetSanityCheck(result, row, col)) return VALUE_NULL;
    return internal_type(result->data[row*result->ncols+col]);
}

uint32_t SQCloudRowsetRowsMaxColumnLength (SQCloudResult *result, uint32_t col) {
    return (result) ? result->clen[ col ] : 0;
}

char *SQCloudRowsetColumnName (SQCloudResult *result, uint32_t col, uint32_t *len) {
    return internal_get_rowset_header(result, result->name, col, len);
}

char *SQCloudRowsetColumnDeclType (SQCloudResult *result, uint32_t col, uint32_t *len) {
    return internal_get_rowset_header(result, result->decltype, col, len);
}

char *SQCloudRowsetColumnDBName (SQCloudResult *result, uint32_t col, uint32_t *len) {
    return internal_get_rowset_header(result, result->dbname, col, len);
}

char *SQCloudRowsetColumnTblName (SQCloudResult *result, uint32_t col, uint32_t *len){
    return internal_get_rowset_header(result, result->tblname, col, len);
}

char *SQCloudRowsetColumnOrigName (SQCloudResult *result, uint32_t col, uint32_t *len) {
    return internal_get_rowset_header(result, result->origname, col, len);
}

uint32_t SQCloudRowsetRows (SQCloudResult *result) {
    if (!SQCloudRowsetSanityCheck(result, 0, 0)) return 0;
    return result->nrows;
}

uint32_t SQCloudRowsetCols (SQCloudResult *result) {
    if (!SQCloudRowsetSanityCheck(result, 0, 0)) return 0;
    return result->ncols;
}

uint32_t SQCloudRowsetMaxLen (SQCloudResult *result) {
    if (!SQCloudRowsetSanityCheck(result, 0, 0)) return 0;
    return result->maxlen;
}

char *SQCloudRowsetValue (SQCloudResult *result, uint32_t row, uint32_t col, uint32_t *len) {
    if (!SQCloudRowsetSanityCheck(result, row, col)) return NULL;
    
    // The *len var must contain the remaining length of the buffer pointed by
    // result->data[row*result->ncols+col]. The caller should not be aware of the
    // internal implementation of this buffer, so it must be set here.
    char *value = result->data[row*result->ncols+col];
    *len = internal_buffer_maxlen(result, value);
    return internal_parse_value(value, len, NULL);
}

uint32_t SQCloudRowsetValueLen (SQCloudResult *result, uint32_t row, uint32_t col) {
    uint32_t len = 0;
    SQCloudRowsetValue(result, row, col, &len);
    return len;
}

int32_t SQCloudRowsetInt32Value (SQCloudResult *result, uint32_t row, uint32_t col) {
    if (!SQCloudRowsetSanityCheck(result, row, col)) return 0;
    char *data = result->data[row*result->ncols+col];
    uint32_t len = internal_buffer_maxlen(result, data);
    char *value = internal_parse_value(data, &len, NULL);
    if (!value || len == 0) return 0;
    
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "%.*s", len, value);
    return (int32_t)strtol(buffer, NULL, 0);
}

int64_t SQCloudRowsetInt64Value (SQCloudResult *result, uint32_t row, uint32_t col) {
    if (!SQCloudRowsetSanityCheck(result, row, col)) return 0;
    char *data = result->data[row*result->ncols+col];
    uint32_t len = internal_buffer_maxlen(result, data);
    char *value = internal_parse_value(data, &len, NULL);
    if (!value || len == 0) return 0;
    
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "%.*s", len, value);
    return (int64_t)strtoll(buffer, NULL, 0);
}

float SQCloudRowsetFloatValue (SQCloudResult *result, uint32_t row, uint32_t col) {
    if (!SQCloudRowsetSanityCheck(result, row, col)) return 0.0;
    char *data = result->data[row*result->ncols+col];
    uint32_t len = internal_buffer_maxlen(result, data);
    char *value = internal_parse_value(data, &len, NULL);
    if (!value || len == 0) return 0.0;
    
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "%.*s", len, value);
    return (float)strtof(buffer, NULL);
}

double SQCloudRowsetDoubleValue (SQCloudResult *result, uint32_t row, uint32_t col) {
    if (!SQCloudRowsetSanityCheck(result, row, col)) return 0.0;
    char *data = result->data[row*result->ncols+col];
    uint32_t len = internal_buffer_maxlen(result, data);
    char *value = internal_parse_value(data, &len, NULL);
    if (!value || len == 0) return 0.0;
    
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "%.*s", len, value);
    return (double)strtod(buffer, NULL);
}

void SQCloudRowsetDump (SQCloudResult *result, uint32_t maxline, bool quiet) {
    internal_rowset_dump(result, maxline, quiet);
}

bool SQCloudRowsetCompare (SQCloudResult *result1, SQCloudResult *result2) {
    return internal_rowset_compare(result1, result2);
}

// MARK: - ARRAY -

static bool SQCloudArraySanityCheck (SQCloudResult *result, uint32_t index) {
    if (!result || result->tag != RESULT_ARRAY) return false;
    if (index >= result->ndata) return false;
    return true;
}

SQCLOUD_VALUE_TYPE SQCloudArrayValueType (SQCloudResult *result, uint32_t index) {
    if (!SQCloudArraySanityCheck(result, index)) return VALUE_NULL;
    return internal_type(result->data[index]);
}

uint32_t SQCloudArrayCount (SQCloudResult *result) {
    if (result->tag != RESULT_ARRAY) return 0;
    return result->ndata;
}

char *SQCloudArrayValue (SQCloudResult *result, uint32_t index, uint32_t *len) {
    if (!SQCloudArraySanityCheck(result, index)) return NULL;
    
    // The *len var must contain the remaining length of the buffer pointed by
    // result->data[index]. The caller should not be aware of the
    // internal implementation of this buffer, so it must be set here.
    char *value = result->data[index];
    *len = internal_buffer_maxlen(result, value);
    return internal_parse_value(value, len, NULL);
}

int32_t SQCloudArrayInt32Value (SQCloudResult *result, uint32_t index) {
    if (!SQCloudArraySanityCheck(result, index)) return 0;
    char *data = result->data[index];
    uint32_t len = internal_buffer_maxlen(result, data);
    char *value = internal_parse_value(data, &len, NULL);
    
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "%.*s", len, value);
    return (int32_t)strtol(buffer, NULL, 0);
}

int64_t SQCloudArrayInt64Value (SQCloudResult *result, uint32_t index) {
    if (!SQCloudArraySanityCheck(result, index)) return 0;
    char *data = result->data[index];
    uint32_t len = internal_buffer_maxlen(result, data);
    char *value = internal_parse_value(data, &len, NULL);
    
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "%.*s", len, value);
    return (int64_t)strtoll(buffer, NULL, 0);
}

float SQCloudArrayFloatValue (SQCloudResult *result, uint32_t index) {
    if (!SQCloudArraySanityCheck(result, index)) return 0.0;
    char *data = result->data[index];
    uint32_t len = internal_buffer_maxlen(result, data);
    char *value = internal_parse_value(data, &len, NULL);
    
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "%.*s", len, value);
    return (float)strtof(buffer, NULL);
}

double SQCloudArrayDoubleValue (SQCloudResult *result, uint32_t index) {
    if (!SQCloudArraySanityCheck(result, index)) return 0.0;
    char *data = result->data[index];
    uint32_t len = internal_buffer_maxlen(result, data);
    char *value = internal_parse_value(data, &len, NULL);
    
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "%.*s", len, value);
    return (double)strtod(buffer, NULL);
}

void SQCloudArrayDump (SQCloudResult *result) {
    if (result->tag != RESULT_ARRAY) return;
    
    for (uint32_t i=0; i<result->ndata; ++i) {
        uint32_t len;
        char *value = SQCloudArrayValue(result, i, &len);
        SQCLOUD_VALUE_TYPE type = SQCloudArrayValueType(result, i);
        if (!value) {value = "NULL"; len = 4;}
        if (type == VALUE_BLOB) printf("[%d] BLOB size %d\n", i, len);
        else printf("[%d] %.*s\n", i, len, value);
    }
}

// MARK: - UPLOAD/DOWNLOAD -

bool SQCloudDownloadDatabase (SQCloudConnection *connection, const char *dbname, void *xdata,
                              int (*xCallback)(void *xdata, const void *buffer, uint32_t blen, int64_t ntot, int64_t nprogress)) {
    return _reserved13(connection, dbname, xdata, xCallback, NULL, false);
}

bool SQCloudUploadDatabase (SQCloudConnection *connection, const char *dbname, const char *key, void *xdata, int64_t dbsize, int (*xCallback)(void *xdata, void *buffer, uint32_t *blen, int64_t ntot, int64_t nprogress)) {
    return internal_upload_database(connection, dbname, key, false, 0, false, xdata, dbsize, xCallback);
}

// MARK: - VM -

int32_t SQCloudRowsetResultDecode (SQCloudVM *vm, SQCloudResult *result) {
    // bind parameter count
    vm->nparams = result->n1;
    
    // vm is readonly
    vm->isreadonly = result->n2;
    
    // column count
    vm->ncolumns = result->n3;
    
    // vm is explain
    vm->isexplain = result->n4;
    
    // tail len
    return result->n5;
}

int32_t SQCloudArrayResultDecode (SQCloudVM *vm, SQCloudResult *result) {
    int type = SQCloudArrayInt32Value(result, 0);
    vm->type = type;

    if (type == ARRAY_TYPE_VM_COMPILE) {
        vm->index = (int)SQCloudArrayInt32Value(result, 1);
        vm->nparams = (int)SQCloudArrayInt32Value(result, 2);
        vm->isreadonly = (int)SQCloudArrayInt32Value(result, 3);
        vm->ncolumns = (int)SQCloudArrayInt32Value(result, 4);
        vm->isexplain = (int)SQCloudArrayInt32Value(result, 5);
        vm->finalized = (int)SQCloudArrayInt32Value(result, 7);

        // number of characters to skip to seek to the next statement
        int32_t nskip = SQCloudArrayInt32Value(result, 6);
        return nskip;
    }

    if ((type == ARRAY_TYPE_SQLITE_EXEC) || (type == ARRAY_TYPE_VM_STEP)) {
        vm->index = (int)SQCloudArrayInt32Value(result, 1);
        vm->lastrowid = SQCloudArrayInt64Value(result, 2);
        vm->changes = SQCloudArrayInt64Value(result, 3);
        vm->totalchanges = SQCloudArrayInt64Value(result, 4);
        vm->finalized = (int)SQCloudArrayInt32Value(result, 5);
        
        return 0;
    }
    
    /*
     remaning cases:
        ARRAY_TYPE_DB_STATUS
         
        ARRAY_TYPE_VM_STEP_ONE
        ARRAY_TYPE_VM_SQL
        ARRAY_TYPE_VM_STATUS
                  
        ARRAY_TYPE_BACKUP_INIT
        ARRAY_TYPE_BACKUP_STEP
        ARRAY_TYPE_BACKUP_END
     
     */
    
    return -1;
}

void SQCloudVMSetError (SQCloudVM *vm) {
    if (vm->errmsg) mem_free(vm->errmsg);
    if (vm->result) SQCloudResultFree(vm->result);
    vm->result = NULL;
    
    const char *errmsg = SQCloudErrorMsg(vm->connection);
    vm->errmsg = (errmsg) ? mem_string_dup(errmsg) : NULL;
    vm->errcode = SQCloudErrorCode(vm->connection);
    vm->xerrcode = SQCloudExtendedErrorCode(vm->connection);
}

void SQCloudVMSetResult (SQCloudVM *vm, SQCloudResult *result) {
    if (vm->result) SQCloudResultFree(vm->result);
    vm->result = result;
}

SQCloudResult *SQCloudVMResult (SQCloudVM *vm) {
    return vm->result;
}

SQCloudVM *SQCloudVMCompile (SQCloudConnection *connection, const char *sql, int32_t len, const char **tail) {
    if (len == -1) len = (int32_t)strlen(sql);
    
    const char *r[1] = {sql};
    uint32_t rlen[1] = {len};
    SQCLOUD_VALUE_TYPE types[1] = {VALUE_TEXT};
    
    SQCloudResult *result = SQCloudExecArray(connection, "VM COMPILE ?", r, rlen, types, 1);
    if (!result) return NULL;
    
    // result can be array or rowset
    SQCLOUD_RESULT_TYPE type = SQCloudResultType(result);
    
    if (type == RESULT_NULL) {
        SQCloudErrorReset(connection);
        return NULL;
    }
    
    // make sure result is an array
    if ((type != RESULT_ARRAY) && (type != RESULT_ROWSET)) {
        internal_set_error(connection, INTERNAL_ERRCODE_FORMAT, "Wrong result type received.");
        SQCloudResultFree(result);
        return NULL;
    }
    
    if ((type == RESULT_ARRAY) && (SQCloudArrayInt32Value(result, 0) != ARRAY_TYPE_VM_COMPILE)) {
        internal_set_error(connection, INTERNAL_ERRCODE_FORMAT, "Wrong array type received.");
        SQCloudResultFree(result);
        return NULL;
    }
    
    SQCloudVM *vm = (SQCloudVM *)mem_zeroalloc(sizeof(_SQCloudVM));
    if (!vm) {
        internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate space for VM.");
        SQCloudResultFree(result);
        return NULL;
    }
    
    // decode array/rowset value
    int32_t nskip = (type == RESULT_ARRAY) ? SQCloudArrayResultDecode(vm, result) : SQCloudRowsetResultDecode(vm, result);
    
    // check for error
    if (nskip == -1) {
        mem_free(vm);
        internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to properly decode value from result.");
        SQCloudResultFree(result);
        return NULL;
    }
    
    // compute tail
    if (tail) {
        if (nskip == 0) nskip = (int32_t)strlen(sql);
        *tail = sql + nskip;
    }
    
    // setup resulting VM
    vm->connection = connection;
    vm->result = result;
    
    return vm;
}

bool SQCloudVMClose (SQCloudVM *vm) {
    bool rc = true;
    
    if (!vm->finalized) {
        char sql[512];
        snprintf(sql, sizeof(sql), "VM FINALIZE %d;", vm->index);
        
        SQCloudResult *result = SQCloudExec(vm->connection, sql);
        if (SQCloudResultType(result) == RESULT_ERROR) rc = false;
        SQCloudResultFree(result);
    }
    
    if (vm->result) SQCloudResultFree(vm->result);
    if (vm->errmsg) mem_free(vm->errmsg);
    mem_free(vm);
    
    return rc;
}

SQCLOUD_RESULT_TYPE SQCloudVMStep (SQCloudVM *vm) {
    // stepping into a VM that already contains a ROWSET means increasing its internal rowindex
    if (vm->result && SQCloudResultType(vm->result) == RESULT_ROWSET) {
        if (vm->rowindex + 1 == SQCloudRowsetRows(vm->result)) return RESULT_NULL;
        ++vm->rowindex;
        return RESULT_ROWSET;
    }
    
    char sql[512];
    snprintf(sql, sizeof(sql), "VM STEP %d;", vm->index);
    
    SQCloudResult *result = SQCloudExec(vm->connection, sql);
    SQCLOUD_RESULT_TYPE type = SQCloudResultType(result);
    
    if (type == RESULT_ROWSET) {
        SQCloudVMSetResult(vm, result);
        vm->finalized = true;
        vm->rowindex = 0;
        return RESULT_ROWSET;
    }
    
    if (type == RESULT_ARRAY) {
        SQCloudVMSetResult(vm, NULL);
        SQCloudArrayResultDecode(vm, result);
        SQCloudResultFree(result);
        return RESULT_OK;
    }
    
    if (type == RESULT_ERROR) {
        SQCloudVMSetError(vm);
        return RESULT_ERROR;
    }

    // should never reach this point
    return RESULT_ERROR;
}

int64_t SQCloudVMLastRowID (SQCloudVM *vm) {
    return vm->lastrowid;
}

int64_t SQCloudVMChanges (SQCloudVM *vm) {
    return vm->changes;
}

int64_t SQCloudVMTotalChanges (SQCloudVM *vm) {
    return vm->totalchanges;
}

const char *SQCloudVMErrorMsg (SQCloudVM *vm) {
    return vm->errmsg;
}

int SQCloudVMErrorCode (SQCloudVM *vm) {
    return vm->errcode;
}

int SQCloudVMIndex (SQCloudVM *vm) {
    return vm->index;
}

bool SQCloudVMIsFinalized (SQCloudVM *vm) {
    return vm->finalized;
}

bool SQCloudVMIsReadOnly (SQCloudVM *vm) {
    return vm->isreadonly;
}

int SQCloudVMIsExplain (SQCloudVM *vm) {
    return vm->isexplain;
}

int SQCloudVMBindParameterCount (SQCloudVM *vm) {
    return vm->nparams;
}

int SQCloudVMBindParameterIndex (SQCloudVM *vm, const char *name) {
    // VM PARAMETER <vmindex> INDEX <name>
    
    char sql[512];
    snprintf(sql, sizeof(sql), "VM PARAMETER %d INDEX ?;", vm->index);
        
    const char *r[1] = {name};
    uint32_t rlen[1] = {(uint32_t)strlen(name)};
    SQCLOUD_VALUE_TYPE types[1] = {VALUE_TEXT};
    
    SQCloudResult *result = SQCloudExecArray(vm->connection, sql, r, rlen, types, 1);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        SQCloudVMSetError(vm);
        SQCloudResultFree(result);
        return 0;
    }
    
    int index = SQCloudResultInt32(result);
    SQCloudResultFree(result);
    return index;
}

const char *SQCloudVMBindParameterName (SQCloudVM *vm, int index) {
    // VM PARAMETER <vmindex> NAME <index>
    
    char sql[512];
    snprintf(sql, sizeof(sql), "VM PARAMETER %d NAME %d;", vm->index, index);
    
    SQCloudResult *result = SQCloudExec(vm->connection, sql);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        SQCloudVMSetError(vm);
        SQCloudResultFree(result);
        return NULL;
    }
    
    const char *name = NULL;
    if (SQCloudResultBuffer(result) != NULL) {
        name = mem_string_dup(SQCloudResultBuffer(result));
    }
    
    SQCloudResultFree(result);
    return name;
}


int SQCloudVMColumnCount (SQCloudVM *vm) {
    return vm->ncolumns;
}

bool SQCloudVMBindDouble (SQCloudVM *vm, int index, double value) {
    // VM BIND <vmindex> TYPE <type> COLUMN <column> VALUE <value>
    char sql[512];
    snprintf(sql, sizeof(sql), "VM BIND %d TYPE DOUBLE COLUMN %d VALUE %f;", vm->index, index, value);
    
    SQCloudResult *result = SQCloudExec(vm->connection, sql);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        SQCloudVMSetError(vm);
        return false;
    }
    
    SQCloudResultFree(result);
    return true;
}

bool SQCloudVMBindInt (SQCloudVM *vm, int index, int value) {
    // VM BIND <vmindex> TYPE <type> COLUMN <column> VALUE <value>
    char sql[512];
    snprintf(sql, sizeof(sql), "VM BIND %d TYPE INT COLUMN %d VALUE %d;", vm->index, index, value);
    
    SQCloudResult *result = SQCloudExec(vm->connection, sql);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        SQCloudVMSetError(vm);
        return false;
    }
    
    SQCloudResultFree(result);
    return true;
}

bool SQCloudVMBindInt64 (SQCloudVM *vm, int index, int64_t value) {
    // VM BIND <vmindex> TYPE <type> COLUMN <column> VALUE <value>
    char sql[512];
    snprintf(sql, sizeof(sql), "VM BIND %d TYPE INT64 COLUMN %d VALUE %lld;", vm->index, index, value);
    
    SQCloudResult *result = SQCloudExec(vm->connection, sql);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        SQCloudVMSetError(vm);
        return false;
    }
    
    SQCloudResultFree(result);
    return true;
}

bool SQCloudVMBindNull (SQCloudVM *vm, int index) {
    // VM BIND <vmindex> TYPE <type> COLUMN <column> VALUE <value>
    char sql[512];
    snprintf(sql, sizeof(sql), "VM BIND %d TYPE NULL COLUMN %d VALUE NULL;", vm->index, index);
    
    SQCloudResult *result = SQCloudExec(vm->connection, sql);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        SQCloudVMSetError(vm);
        return false;
    }
    
    SQCloudResultFree(result);
    return true;
}

bool SQCloudVMBindText (SQCloudVM *vm, int index, const char *value, int32_t len) {
    // VM BIND <vmindex> TYPE <type> COLUMN <column> VALUE <value>
    char sql[512];
    snprintf(sql, sizeof(sql), "VM BIND %d TYPE TEXT COLUMN %d VALUE ?;", vm->index, index);
    
    if (len == -1) len = (int32_t)strlen(value);
    
    const char *r[1] = {value};
    uint32_t rlen[1] = {len};
    SQCLOUD_VALUE_TYPE types[1] = {VALUE_TEXT};
    
    SQCloudResult *result = SQCloudExecArray(vm->connection, sql, r, rlen, types, 1);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        SQCloudVMSetError(vm);
        return false;
    }
    
    SQCloudResultFree(result);
    return true;
}

bool SQCloudVMBindBlob (SQCloudVM *vm, int index, void *value, int32_t len) {
    // VM BIND <vmindex> TYPE <type> COLUMN <column> VALUE <value>
    char sql[512];
    snprintf(sql, sizeof(sql), "VM BIND %d TYPE BLOB COLUMN %d VALUE ?;", vm->index, index);
    
    const char *r[1] = {value};
    uint32_t rlen[1] = {len};
    SQCLOUD_VALUE_TYPE types[1] = {VALUE_BLOB};
    
    SQCloudResult *result = SQCloudExecArray(vm->connection, sql, r, rlen, types, 1);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        SQCloudVMSetError(vm);
        return false;
    }
    
    SQCloudResultFree(result);
    return true;
}

bool SQCloudVMBindZeroBlob (SQCloudVM *vm, int index, int64_t len) {
    // VM BIND <vmindex> TYPE <type> COLUMN <column> VALUE <value>
    char sql[512];
    snprintf(sql, sizeof(sql), "VM BIND %d TYPE ZEROBLOB COLUMN %d VALUE %lld;", vm->index, index, len);
    
    SQCloudResult *result = SQCloudExec(vm->connection, sql);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        SQCloudVMSetError(vm);
        return false;
    }
    
    SQCloudResultFree(result);
    return true;
}

const void *SQCloudVMColumnBlob (SQCloudVM *vm, int index, uint32_t *len) {
    return (const void *)SQCloudRowsetValue(vm->result, vm->rowindex, index, len);
}

const char *SQCloudVMColumnText (SQCloudVM *vm, int index, uint32_t *len) {
    return (const char *)SQCloudRowsetValue(vm->result, vm->rowindex, index, len);
}

double SQCloudVMColumnDouble (SQCloudVM *vm, int index) {
    return SQCloudRowsetDoubleValue(vm->result, vm->rowindex, index);
}

int SQCloudVMColumnInt32 (SQCloudVM *vm, int index) {
    return (int)SQCloudRowsetInt32Value(vm->result, vm->rowindex, index);
}

int64_t SQCloudVMColumnInt64 (SQCloudVM *vm, int index) {
    return (int64_t)SQCloudRowsetInt64Value(vm->result, vm->rowindex, index);
}

int64_t SQCloudVMColumnLen (SQCloudVM *vm, int index) {
    return (int64_t)SQCloudRowsetValueLen(vm->result, vm->rowindex, index);
}

SQCLOUD_VALUE_TYPE SQCloudVMColumnType (SQCloudVM *vm, int index) {
    return SQCloudRowsetValueType(vm->result, vm->rowindex, index);
}

// MARK: - BLOB -

SQCloudBlob *SQCloudBlobOpen (SQCloudConnection *connection, const char *dbname, const char *tablename, const char *colname, int64_t rowid, bool wrflag) {
    // BLOB OPEN <database_name> TABLE <table_name> COLUMN <column_name> ROWID <rowid> RWFLAG <rwflag>
    char sql[512];
    snprintf(sql, sizeof(sql), "BLOB OPEN ? TABLE ? COLUMN ? ROWID %lld RWFLAG %d;", rowid, wrflag);
    
    if (!dbname) dbname = "main";
    const char *r[3] = {dbname, tablename, colname};
    uint32_t rlen[3] = {(uint32_t)strlen(dbname), (uint32_t)strlen(tablename), (uint32_t)strlen(colname)};
    SQCLOUD_VALUE_TYPE types[3] = {VALUE_TEXT, VALUE_TEXT, VALUE_TEXT};
    
    SQCloudResult *result = SQCloudExecArray(connection, sql, r, rlen, types, 3);
    if (SQCloudResultIsError(result)) {
        SQCloudResultFree(result);
        return NULL;
    }
    
    int index = (SQCloudResultType(result) == RESULT_INTEGER) ? SQCloudResultInt32(result) : -1;
    SQCloudResultFree(result);
    if (index == -1) return NULL; // errcode/errmsg should be already stored in connection
    
    SQCloudBlob *blob = (SQCloudBlob *)mem_zeroalloc(sizeof(_SQCloudBlob));
    if (!blob) {
        internal_set_error(connection, INTERNAL_ERRCODE_MEMORY, "Unable to allocate space for BLOB.");
        return NULL;
    }
    
    blob->connection = connection;
    blob->index = index;
    blob->bytes = -1;
    
    return blob;
}

bool SQCloudBlobReOpen (SQCloudBlob *blob, int64_t rowid) {
    if (blob->rc != 0) return false;
    
    // BLOB REOPEN <index> ROWID <rowid>
    char sql[512];
    snprintf(sql, sizeof(sql), "BLOB REOPEN %d ROWID %lld;", blob->index, rowid);
    
    SQCloudResult *result = SQCloudExec(blob->connection, sql);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        blob->rc = SQCloudErrorCode(blob->connection);
    }
    
    SQCloudResultFree(result);
    return (blob->rc == 0);
}

bool SQCloudBlobClose (SQCloudBlob *blob) {
    if (!blob) return true;
    
    // BLOB CLOSE <index>
    char sql[512];
    snprintf(sql, sizeof(sql), "BLOB CLOSE %d;", blob->index);
    
    SQCloudResult *result = SQCloudExec(blob->connection, sql);
    bool rc = (SQCloudResultIsOK(result));
    
    SQCloudResultFree(result);
    return rc;
}

int SQCloudBlobBytes (SQCloudBlob *blob) {
    if (blob->rc != 0) return 0;
    if (blob->bytes != -1) return (int)blob->bytes;
    
    // BLOB BYTES <index>
    char sql[512];
    snprintf(sql, sizeof(sql), "BLOB BYTES %d;", blob->index);
    
    int rc = -1;
    SQCloudResult *result = SQCloudExec(blob->connection, sql);
    if (SQCloudResultType(result) == RESULT_INTEGER) {
        rc = (int)SQCloudResultInt32(result);
        blob->bytes = rc;
    }
    
    SQCloudResultFree(result);
    return rc;
}

int SQCloudBlobRead (SQCloudBlob *blob, void *zbuffer, int n, int offset) {
    if (blob->rc != 0) return -1;
    
    // BLOB READ <index> SIZE <size> OFFSET <offset>
    char sql[512];
    snprintf(sql, sizeof(sql), "BLOB READ %d SIZE %d OFFSET %d;", blob->index, n, offset);
    
    int rc = -1;
    SQCloudResult *result = SQCloudExec(blob->connection, sql);
    if (SQCloudResultType(result) == RESULT_BLOB) {
        char *buffer = SQCloudResultBuffer(result);
        int len = SQCloudResultLen(result);
        // len should be <= n
        memcpy(zbuffer, buffer, (len <= n) ? len : n);
        rc = len;
    }
    
    SQCloudResultFree(result);
    return rc;
}

int SQCloudBlobWrite (SQCloudBlob *blob, const void *buffer, int blen, int offset) {
    if (blob->rc != 0) return -1;
    
    // BLOB WRITE <index> OFFSET <offset> DATA <data>
    char sql[512];
    snprintf(sql, sizeof(sql), "BLOB WRITE %d OFFSET %d DATA ?;", blob->index, offset);
    
    const char *r[1] = {buffer};
    uint32_t rlen[1] = {blen};
    SQCLOUD_VALUE_TYPE types[1] = {VALUE_BLOB};
    
    int rc = 0;
    SQCloudResult *result = SQCloudExecArray(blob->connection, sql, r, rlen, types, 1);
    if (SQCloudResultType(result) == RESULT_ERROR) {
        rc = -1;
    }
    
    SQCloudResultFree(result);
    return (rc == 0);
}

// MARK: - BACKUP -

SQCloudBackup *SQCloudBackupInit (SQCloudConnection *connection, const char *dest_name, const char *source_name) {
    // BACKUP INIT [<dest_name>] [SOURCE <source_name>]
    if (!dest_name) dest_name = "main";
    if (!source_name) source_name = "main";
    
    char sql[512];
    snprintf(sql, sizeof(sql), "BACKUP INIT ? SOURCE ?");
    
    const char *r[2] = {dest_name, source_name};
    uint32_t rlen[2] = {(uint32_t)strlen(dest_name), (uint32_t)strlen(source_name)};
    SQCLOUD_VALUE_TYPE types[2] = {VALUE_TEXT, VALUE_TEXT};
    
    SQCloudBackup *backup = NULL;
    SQCloudResult *result = SQCloudExecArray(connection, sql, r, rlen, types, 2);
    if ((SQCloudResultType(result) == RESULT_ARRAY) && (SQCloudArrayInt32Value(result, 0) == ARRAY_TYPE_BACKUP_INIT)) {
        backup = (SQCloudBackup *)mem_zeroalloc(sizeof(_SQCloudBackup));
        backup->connection = connection;
        backup->page_size = (int)SQCloudArrayInt32Value(result, 2);
        backup->page_total = (int)SQCloudArrayInt32Value(result, 3);
    }
    
    SQCloudResultFree(result);
    return backup;
}

int SQCloudBackupStep (SQCloudBackup *backup, int n, SQCloudBackupOnDataCB on_data) {
    if (n <= 0) n = 0;
    
    // BACKUP STEP <index> PAGES <npages>
    char sql[512];
    snprintf(sql, sizeof(sql), "BACKUP STEP %d PAGES %d;", backup->index, n);
    
    int rc = -1;
    SQCloudResult *result = SQCloudExec(backup->connection, sql);
    if ((SQCloudResultType(result) == RESULT_ARRAY) && (SQCloudArrayInt32Value(result, 0) == ARRAY_TYPE_BACKUP_STEP)) {
        rc = (int)SQCloudArrayInt32Value(result, 2);
        backup->page_total = (int)SQCloudArrayInt32Value(result, 3);
        backup->page_remaining = (int)SQCloudArrayInt32Value(result, 4);
        backup->counter = (int)SQCloudArrayInt32Value(result, 5);
        
        // retrieve BLOB
        uint32_t blen = 0;
        char *buffer = SQCloudArrayValue(result, 6, &blen);
        if (on_data) on_data(backup, buffer, blen, backup->page_size, backup->counter);
    }
    
    SQCloudResultFree(result);
    return rc;
}

bool SQCloudBackupFinish (SQCloudBackup *backup) {
    bool rc = true;
    if (backup->connection) {
        // BACKUP FINISH <index>
        char sql[512];
        snprintf(sql, sizeof(sql), "BACKUP FINISH %d;", backup->index);
        
        SQCloudResult *result = SQCloudExec(backup->connection, sql);
        rc = (SQCloudResultIsOK(result));
        
        SQCloudResultFree(result);
    }
    mem_free(backup);
    return rc;
}

int SQCloudBackupPageRemaining (SQCloudBackup *backup) {
    // BACKUP REMAINING <index>
    return backup->page_remaining;
}

int SQCloudBackupPageCount (SQCloudBackup *backup) {
    // BACKUP PAGECOUNT <index>
    return backup->page_total;
}

void *SQCloudBackupSetData (SQCloudBackup *backup, void *data) {
    void *rc = backup->data;
    backup->data = data;
    return rc;
}

void *SQCloudBackupData (SQCloudBackup *backup) {
    return backup->data;
}

SQCloudConnection *SQCloudBackupConnection (SQCloudBackup *backup) {
    return backup->connection;
}

     
//
// END FILE: sqcloud.c
// ----------------------------------------------------------------------------



// ----------------------------------------------------------------------------
// BEGIN FILE: sqlite3_api.c
//


//
//  sqlite3_api.c
//  SQLite3 API compatibility layer
//
//  Created by SQLite Cloud, Inc.
//  Latest revision: SQLite 3.40.0 (2022-12-01)
//

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
// (AMALGAMATED) #include "sqlite3.h"
// (AMALGAMATED) #include "sqlite3cloud_api.h"
// (AMALGAMATED) #include "sqlite3_internals.h"

// Internal macros used only by sqlite3transform
#define SQLITECLOUD_NOT_IMPLEMENTED
#define SQLITECLOUD_NOT_NEEDED

// MARK: - PRIVATE -

/*
** Check to make sure we have a valid db pointer.  This test is not
** foolproof but it does provide some measure of protection against
** misuse of the interface such as passing in db pointers that are
** NULL or which have been previously closed.  If this routine returns
** 1 it means that the db pointer is valid and 0 if it should not be
** dereferenced for any reason.  The calling function should invoke
** SQLITE_MISUSE immediately.
**
** sqlite3SafetyCheckOk() requires that the db pointer be valid for
** use.  sqlite3SafetyCheckSickOrOk() allows a db pointer that failed to
** open properly and is not fit for general use but which can be
** used as an argument to sqlite3_errmsg() or sqlite3_close().
*/
static int sqlite3SafetyCheckSickOrOk(sqlite3 *db) {
    /*
    int eOpenState = db->eOpenState;
    if (eOpenState!=SQLITE_STATE_SICK &&
        eOpenState!=SQLITE_STATE_OPEN &&
        eOpenState!=SQLITE_STATE_BUSY) {
      //logBadConnection("invalid");
      return 0;
    } else {
      return 1;
    }
     */
    return 1;
}

static int sqlite3SafetyCheckOk (sqlite3 *db) {
    if (db == NULL) return 0;
    
    /*
    int eOpenState = db->eOpenState;
    if (eOpenState != SQLITE_STATE_OPEN) {
      if (sqlite3SafetyCheckSickOrOk(db)) {
          ;
      }
      return 0;
    } else {
      return 1;
    }
     */
    return 1;
}

/*
** Check on a Vdbe to make sure it has not been finalized.  Log
** an error and return true if it has been finalized (or is otherwise
** invalid).  Return false if it is ok.
*/
static int vdbeSafety(sqlite3_stmt *p){
  if (p->db == NULL) {
    //sqlite3_log(SQLITE_MISUSE, "API called with finalized prepared statement");
    return 1;
  } else {
    return 0;
  }
}
static int vdbeSafetyNotNull(sqlite3_stmt *p){
  if (p == NULL) {
    // sqlite3_log(SQLITE_MISUSE, "API called with NULL prepared statement");
    return 1;
  } else {
    return vdbeSafety(p);
  }
}

// MARK: - SQLite3 API -

SQLITE_API const char sqlite3_version[] = SQLITE_VERSION;
SQLITE_API char *sqlite3_temp_directory = NULL;
SQLITE_API char *sqlite3_data_directory = NULL;

SQLITE_API const char *sqlite3_libversion(void) {
    return sqlite3_version;
}

SQLITE_API const char *sqlite3_sourceid(void) {
    return SQLITE_SOURCE_ID;
}

SQLITE_API int sqlite3_libversion_number(void) {
    return SQLITE_VERSION_NUMBER;
}

SQLITE_API int sqlite3_compileoption_used(const char *zOptName) {
    return sqlite3cloud_compileoption_used(zOptName);
}

SQLITE_API const char *sqlite3_compileoption_get(int N) {
    return sqlite3cloud_compileoption_get(N);
}

SQLITE_API int sqlite3_threadsafe(void) {
    return 1;
}

SQLITE_API int sqlite3_close(sqlite3 *db) {
    if (!db) return SQLITE_OK;
    if (!sqlite3SafetyCheckSickOrOk(db)) return SQLITE_MISUSE;
    return sqlite3cloud_close(db);
}

SQLITE_API int sqlite3_close_v2(sqlite3 *db) {
    if (!db) return SQLITE_OK;
    if (!sqlite3SafetyCheckSickOrOk(db)) return SQLITE_MISUSE;
    return sqlite3cloud_close(db);
}

SQLITE_API int sqlite3_exec(
  sqlite3 *db,                /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  sqlite3_callback xCallback, /* Invoke this callback routine */
  void *pArg,                 /* First argument to xCallback() */
  char **pzErrMsg             /* Write error messages here */
) {
    if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE;
    return sqlite3cloud_exec(db, zSql, xCallback, pArg, pzErrMsg);
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_initialize(void) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_shutdown(void) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_os_init(void) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_os_end(void) {
    return 0;
}

SQLITE_API int sqlite3_config(int op, ...) {
    return SQLITE_OK;
}

SQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...) {
    return SQLITE_OK;
}

SQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff) {
    db->exterrcodes = onoff;
    return SQLITE_OK;
}

SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3 *db) {
    return sqlite3cloud_lastrowid(db);
}

SQLITE_API void sqlite3_set_last_insert_rowid(sqlite3 *db, sqlite3_int64 iRowid) {
    sqlite3cloud_setlastrowid(db, iRowid);
}

SQLITE_API int sqlite3_changes(sqlite3 *db) {
    return (int)sqlite3cloud_changes(db);
}

SQLITE_API sqlite3_int64 sqlite3_changes64(sqlite3 *db) {
    return sqlite3cloud_changes(db);
}

SQLITE_API int sqlite3_total_changes(sqlite3 *db) {
    return (int)sqlite3cloud_totalchanges(db);
}

SQLITE_API sqlite3_int64 sqlite3_total_changes64(sqlite3 *db) {
    return sqlite3cloud_totalchanges(db);
}

SQLITE_API void sqlite3_interrupt(sqlite3 *db) {
    sqlite3cloud_interrupt(db);
}

SQLITE_API int sqlite3_is_interrupted(sqlite3 *db) {
    return sqlite3cloud_is_interrupted(db);
}

SQLITE_API int sqlite3_complete16(const void *zSql) {
    return sqlite3_complete((const char *)zSql);
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_busy_handler(
  sqlite3 *db,
  int (*xBusy)(void*,int),
  void *pArg
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_busy_timeout(sqlite3 *db, int ms) {
    return 0;
}

SQLITE_API int sqlite3_get_table(
  sqlite3 *db,                /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  char ***pazResult,          /* Write the result table here */
  int *pnRow,                 /* Write the number of rows in the result here */
  int *pnColumn,              /* Write the number of columns of result here */
  char **pzErrMsg             /* Write error messages here */
) {
    return sqlite3cloud_gettable(db, zSql, pazResult, pnRow, pnColumn, pzErrMsg);
}

SQLITE_API void sqlite3_free_table(
  char **azResult            /* Result returned from sqlite3_get_table() */
) {
    sqlite3cloud_freetable(azResult);
}

SQLITE_API void *sqlite3_malloc(int n) {
    return sqlite3cloud_malloc(n);
}

SQLITE_API void *sqlite3_malloc64(sqlite3_uint64 n) {
    return sqlite3cloud_malloc(n);
}

SQLITE_API void *sqlite3_realloc(void *pOld, int n) {
    return sqlite3cloud_realloc(pOld, n);
}

SQLITE_API void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n) {
    return sqlite3cloud_realloc(pOld, n);
}

SQLITE_API void sqlite3_free(void *p) {
    sqlite3cloud_free(p);
}

SQLITE_API sqlite3_uint64 sqlite3_msize(void *p) {
    return (p) ? sqlite3cloud_msize(p) : 0;
}

SQLITE_API sqlite3_int64 sqlite3_memory_used(void) {
    return sqlite3cloud_totmem();
}

SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag) {
    return sqlite3cloud_memory_highwater(resetFlag);
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_set_authorizer(
  sqlite3 *db,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pArg
) {
    return 0;
}

SQLITE_API SQLITE_DEPRECATED void *sqlite3_trace(sqlite3 *db, void(*xTrace)(void*,const char*), void *pArg) {
    return NULL;
}

SQLITE_API SQLITE_DEPRECATED void *sqlite3_profile(
  sqlite3 *db,
  void (*xProfile)(void*,const char*,sqlite_uint64),
  void *pArg
) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_trace_v2(
  sqlite3 *db,                               /* Trace this connection */
  unsigned mTrace,                           /* Mask of events to be traced */
  int(*xTrace)(unsigned,void*,void*,void*),  /* Callback to invoke */
  void *pArg                                 /* Context */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_progress_handler(
  sqlite3 *db,
  int nOps,
  int (*xProgress)(void*),
  void *pArg
) {
    return ;
}

SQLITE_API void sqlite3_randomness(int N, void *pBuf) {
    static bool init = false;
    if (!init) {
        srand(time(NULL));
        init = true;
    }
    unsigned char *zBuf = (unsigned char *)pBuf;
    while (N--) {
        unsigned char nextByte = rand() % 255;
        zBuf[N] = nextByte;
    }
}

SQLITE_API int sqlite3_open(
  const char *zFilename,
  sqlite3 **ppDb
) {
    return sqlite3cloud_open(zFilename, ppDb, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);
}

SQLITE_API int sqlite3_open16(
  const void *zFilename,
  sqlite3 **ppDb
) {
    return sqlite3cloud_open(zFilename, ppDb, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);
}

SQLITE_API int sqlite3_open_v2(
  const char *filename,   /* Database filename (UTF-8) */
  sqlite3 **ppDb,         /* OUT: SQLite db handle */
  int flags,              /* Flags */
  const char *zVfs        /* Name of VFS module to use */
) {
    return sqlite3cloud_open(filename, ppDb, flags);
}

SQLITE_API SQLITECLOUD_NOT_NEEDED const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_uri_boolean(const char *zFilename, const char *zParam, int bDflt) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED sqlite3_int64 sqlite3_uri_int64(
  const char *zFilename,    /* Filename as passed to xOpen */
  const char *zParam,       /* URI parameter sought */
  sqlite3_int64 bDflt       /* return if parameter is missing */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED const char *sqlite3_uri_key(const char *zFilename, int N) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED const char *sqlite3_filename_database(const char *zFilename) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED const char *sqlite3_filename_journal(const char *zFilename) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED const char *sqlite3_filename_wal(const char *zFilename) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED sqlite3_file *sqlite3_database_file_object(const char *zName) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED sqlite3_filename sqlite3_create_filename(
  const char *zDatabase,
  const char *zJournal,
  const char *zWal,
  int nParam,
  const char **azParam
) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_free_filename(sqlite3_filename p) {
    return;
}

SQLITE_API int sqlite3_errcode(sqlite3 *db){
    if (db && !sqlite3SafetyCheckSickOrOk(db)) return SQLITE_MISUSE;
    if (!db) return SQLITE_NOMEM;
    return (db->exterrcodes) ? sqlite3cloud_extended_errcode(db) : sqlite3cloud_errcode(db);
}

SQLITE_API int sqlite3_system_errno(sqlite3 *db){
    return (db) ? sqlite3cloud_system_errno(db) : 0;
}

SQLITE_API int sqlite3_extended_errcode(sqlite3 *db){
    if (db && !sqlite3SafetyCheckSickOrOk(db)) return SQLITE_MISUSE;
    if (!db) return SQLITE_NOMEM;
    return sqlite3cloud_extended_errcode(db);
}

SQLITE_API const char *sqlite3_errmsg(sqlite3 *db){
    if (!db) return sqlite3_errstr(SQLITE_NOMEM);
    if (!sqlite3SafetyCheckSickOrOk(db)) return sqlite3_errstr(SQLITE_MISUSE);
    return sqlite3cloud_errmsg(db);
}

SQLITE_API const void *sqlite3_errmsg16(sqlite3 *db){
    if (!db) return sqlite3_errstr(SQLITE_NOMEM);
    if (!sqlite3SafetyCheckSickOrOk(db)) return sqlite3_errstr(SQLITE_MISUSE);
    return sqlite3cloud_errmsg(db);
}

SQLITE_API int sqlite3_error_offset(sqlite3 *db){
    int offset = -1;
    int errcode = sqlite3_extended_errcode(db);
    if (db && sqlite3SafetyCheckSickOrOk(db) && errcode) offset = sqlite3cloud_error_offset(db);
    return offset;
}

SQLITE_API int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){
    if (limitId <0 || limitId >= SQLITE_N_LIMIT) return -1;
    return sqlite3cloud_limit(db, limitId, newLimit);
}

SQLITE_API int sqlite3_prepare(
  sqlite3 *db,              /* Database handle. */
  const char *zSql,         /* UTF-8 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const char **pzTail       /* OUT: End of parsed string */
) {
    *ppStmt = NULL;
    if (!sqlite3SafetyCheckOk(db) || zSql == NULL) return SQLITE_MISUSE;
    return sqlite3cloud_prepare(db, zSql, nBytes, 0, ppStmt, pzTail);
}

SQLITE_API int sqlite3_prepare_v2(
  sqlite3 *db,              /* Database handle. */
  const char *zSql,         /* UTF-8 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const char **pzTail       /* OUT: End of parsed string */
) {
    *ppStmt = NULL;
    if (!sqlite3SafetyCheckOk(db) || zSql == NULL) return SQLITE_MISUSE;
    return sqlite3cloud_prepare(db, zSql, nBytes, 0, ppStmt, pzTail);
}

SQLITE_API int sqlite3_prepare_v3(
  sqlite3 *db,              /* Database handle. */
  const char *zSql,         /* UTF-8 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const char **pzTail       /* OUT: End of parsed string */
) {
    *ppStmt = NULL;
    if (!sqlite3SafetyCheckOk(db) || zSql == NULL) return SQLITE_MISUSE;
    return sqlite3cloud_prepare(db, zSql, nBytes, prepFlags, ppStmt, pzTail);
}

SQLITE_API int sqlite3_prepare16(
  sqlite3 *db,              /* Database handle. */
  const void *zSql,         /* UTF-16 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const void **pzTail       /* OUT: End of parsed string */
) {
    *ppStmt = NULL;
    if (!sqlite3SafetyCheckOk(db) || zSql == NULL) return SQLITE_MISUSE;
    return sqlite3cloud_prepare(db, zSql, nBytes, 0, ppStmt, (const char **)pzTail);
}

SQLITE_API int sqlite3_prepare16_v2(
  sqlite3 *db,              /* Database handle. */
  const void *zSql,         /* UTF-16 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const void **pzTail       /* OUT: End of parsed string */
) {
    *ppStmt = NULL;
    if (!sqlite3SafetyCheckOk(db) || zSql == NULL) return SQLITE_MISUSE;
    return sqlite3cloud_prepare(db, zSql, nBytes, 0, ppStmt, (const char **)pzTail);
}

SQLITE_API int sqlite3_prepare16_v3(
  sqlite3 *db,              /* Database handle. */
  const void *zSql,         /* UTF-16 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const void **pzTail       /* OUT: End of parsed string */
) {
    *ppStmt = NULL;
    if (!sqlite3SafetyCheckOk(db) || zSql == NULL) return SQLITE_MISUSE;
    return sqlite3cloud_prepare(db, zSql, nBytes, prepFlags, ppStmt, (const char **)pzTail);
}

SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt) {
    if (!pStmt) return NULL;
    if (!pStmt->sql) sqlite3cloud_retrieve_sql(pStmt);
    uint32_t len = 0;
    return SQCloudArrayValue(pStmt->sql, 2, &len);
}

SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt) {
    if (!pStmt) return NULL;
    if (!pStmt->sql) sqlite3cloud_retrieve_sql(pStmt);
    uint32_t len = 0;
    return SQCloudArrayValue(pStmt->sql, 3, &len);
}

SQLITE_API const char *sqlite3_normalized_sql(sqlite3_stmt *pStmt) {
    if (!pStmt) return NULL;
    if (!pStmt->sql) sqlite3cloud_retrieve_sql(pStmt);
    uint32_t len = 0;
    return SQCloudArrayValue(pStmt->sql, 4, &len);
}

SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){
    return (pStmt) ? sqlite3cloud_stmt_readonly(pStmt) : 1;
}

SQLITE_API int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt){
    return (pStmt) ? sqlite3cloud_stmt_isexplain(pStmt) : 0;
}

SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt *pStmt){
    return (pStmt) ? sqlite3cloud_stmt_busy(pStmt) : 0;
}

SQLITE_API int sqlite3_bind_blob(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  int nData,
  void (*xDel)(void*)
) {
    return sqlite3cloud_bind_blob(pStmt, i, zData, nData, xDel);
}

SQLITE_API int sqlite3_bind_blob64(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  sqlite3_uint64 nData,
  void (*xDel)(void*)
) {
    return sqlite3cloud_bind_blob(pStmt, i, zData, nData, xDel);
}

SQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue) {
    return sqlite3cloud_bind_double(pStmt, i, rValue);
}

SQLITE_API int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue) {
    return sqlite3cloud_bind_int(p, i, iValue);
}

SQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue) {
    return sqlite3cloud_bind_int64(pStmt, i, iValue);
}

SQLITE_API int sqlite3_bind_null(sqlite3_stmt *pStmt, int i) {
    return sqlite3cloud_bind_null(pStmt, i);
}

SQLITE_API int sqlite3_bind_text(
  sqlite3_stmt *pStmt,
  int i,
  const char *zData,
  int nData,
  void (*xDel)(void*)
) {
    return sqlite3cloud_bind_text(pStmt, i, zData, nData, xDel, SQLITE_UTF8);
}

SQLITE_API int sqlite3_bind_text16(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  int nData,
  void (*xDel)(void*)
) {
    return sqlite3cloud_bind_text(pStmt, i, zData, nData, xDel, SQLITE_UTF8);
}

SQLITE_API int sqlite3_bind_text64(
  sqlite3_stmt *pStmt,
  int i,
  const char *zData,
  sqlite3_uint64 nData,
  void (*xDel)(void*),
  unsigned char enc
) {
    return sqlite3cloud_bind_text(pStmt, i, zData, nData, xDel, enc);
}

SQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue) {
    return sqlite3cloud_bind_value(pStmt, i, pValue);
}

SQLITE_API int sqlite3_bind_pointer(
  sqlite3_stmt *pStmt,
  int i,
  void *pPtr,
  const char *zPTtype,
  void (*xDestructor)(void*)
) {
    return sqlite3cloud_bind_pointer(pStmt, i, pPtr, zPTtype, xDestructor);
}

SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n) {
    return sqlite3cloud_bind_zeroblob(pStmt, i, n);
}

SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n) {
    return sqlite3cloud_bind_zeroblob(pStmt, i, n);
}

SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt) {
    return (pStmt) ? sqlite3cloud_bind_parameter_count(pStmt) : 0;
}

SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i) {
    return (pStmt) ? sqlite3cloud_bind_parameter_name(pStmt, i) : NULL;
}

SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName) {
    return (pStmt) ? sqlite3cloud_bind_parameter_index(pStmt, zName) : 0;
}

SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt) {
    return sqlite3cloud_clear_bindings(pStmt);
}

SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt) {
    return (pStmt) ? sqlite3cloud_column_count(pStmt) : 0;
}

SQLITE_API const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N) {
    return (pStmt) ? sqlite3cloud_column_name(pStmt, N) : NULL;
}

SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N) {
    return (pStmt) ? (const void *)sqlite3cloud_column_name(pStmt, N) : NULL;
}

SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N) {
    return (pStmt) ? sqlite3cloud_column_database_name(pStmt, N) : NULL;
}

SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N) {
    return (pStmt) ? (const void *)sqlite3cloud_column_database_name(pStmt, N) : NULL;
}

SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N) {
    return (pStmt) ? sqlite3cloud_column_table_name(pStmt, N) : NULL;
}

SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N) {
    return (pStmt) ? (const void *)sqlite3cloud_column_table_name(pStmt, N) : NULL;
}

SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N) {
    return (pStmt) ? sqlite3cloud_column_origin_name(pStmt, N) : NULL;
}

SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N) {
    return (pStmt) ? (const void *)sqlite3cloud_column_origin_name(pStmt, N) : NULL;
}

SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N) {
    return (pStmt) ? sqlite3cloud_column_decltype(pStmt, N) : NULL;
}

SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N) {
    return (pStmt) ? (const void *) sqlite3cloud_column_decltype(pStmt, N) : NULL;
}

SQLITE_API int sqlite3_step(sqlite3_stmt *pStmt) {
    if (vdbeSafetyNotNull(pStmt)) return SQLITE_MISUSE;
    return sqlite3cloud_step(pStmt);
}

SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt) {
    return sqlite3cloud_data_count(pStmt);
}

SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i) {
    return sqlite3cloud_column_blob(pStmt, i);
}

SQLITE_API double sqlite3_column_double(sqlite3_stmt *pStmt, int i) {
    return sqlite3cloud_column_double(pStmt, i);
}

SQLITE_API int sqlite3_column_int(sqlite3_stmt *pStmt, int i) {
    return sqlite3cloud_column_int(pStmt, i);
}

SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i) {
    return sqlite3cloud_column_int64(pStmt, i);
}

SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i) {
    return sqlite3cloud_column_text(pStmt, i);
}

SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i) {
    return (const void *)sqlite3cloud_column_text(pStmt, i);
}

SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i) {
    return sqlite3cloud_column_value(pStmt, i);
}

SQLITE_API int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i) {
    return sqlite3cloud_column_bytes(pStmt, i);
}

SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i) {
    return sqlite3cloud_column_bytes(pStmt, i);
}

SQLITE_API int sqlite3_column_type(sqlite3_stmt *pStmt, int i) {
    return sqlite3cloud_column_type(pStmt, i);
}

SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt) {
    return (pStmt) ? sqlite3cloud_finalize(pStmt) : SQLITE_OK;
}

SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt) {
    return (pStmt) ? sqlite3cloud_reset(pStmt) : SQLITE_OK;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_create_function(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*)
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_create_function16(
  sqlite3 *db,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_create_function_v2(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*),
  void (*xDestroy)(void *)
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_create_window_function(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*),
  void (*xValue)(sqlite3_context*),
  void (*xInverse)(sqlite3_context*,int,sqlite3_value **),
  void (*xDestroy)(void *)
) {
    return 0;
}

SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context *p) {
    return 0;
}

SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt *pStmt) {
    return 0;
}

SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt) {
    return 0;
}

SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void) {
    return 0;
}

SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void) {
    return ;
}

SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(
  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),
  void *pArg,
  sqlite3_int64 iThreshold
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED const void *sqlite3_value_blob(sqlite3_value *pVal) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED double sqlite3_value_double(sqlite3_value *pVal) {
    return 0.0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_value_int(sqlite3_value *pVal) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED sqlite3_int64 sqlite3_value_int64(sqlite3_value *pVal) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void *sqlite3_value_pointer(sqlite3_value *pVal, const char *zPType) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED const unsigned char *sqlite3_value_text(sqlite3_value *pVal) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED const void *sqlite3_value_text16(sqlite3_value* pVal) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED const void *sqlite3_value_text16le(sqlite3_value *pVal) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED const void *sqlite3_value_text16be(sqlite3_value *pVal) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_value_bytes(sqlite3_value *pVal) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_value_bytes16(sqlite3_value *pVal) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_value_type(sqlite3_value* pVal) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_value_numeric_type(sqlite3_value *pVal) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_value_nochange(sqlite3_value *pVal) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_value_frombind(sqlite3_value *pVal) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED unsigned int sqlite3_value_subtype(sqlite3_value *pVal) {
    return 0;
}

SQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value *pOrig) {
    if (pOrig == NULL) return NULL;
    return sqlite3cloud_value_dup(pOrig);
}

SQLITE_API void sqlite3_value_free(sqlite3_value *pOld) {
    sqlite3cloud_free(pOld);
}

SQLITE_API int sqlite3_value_encoding(sqlite3_value *pVal) {
    return SQLITE_UTF8;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void *sqlite3_aggregate_context(sqlite3_context *p, int nByte) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void *sqlite3_user_data(sqlite3_context *p) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED sqlite3 *sqlite3_context_db_handle(sqlite3_context *p) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_set_auxdata(
  sqlite3_context *pCtx,
  int iArg,
  void *pAux,
  void (*xDelete)(void*)
) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_blob(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_blob64(
  sqlite3_context *pCtx,
  const void *z,
  sqlite3_uint64 n,
  void (*xDel)(void *)
) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_double(sqlite3_context *pCtx, double rVal) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_error_toobig(sqlite3_context *pCtx) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_error_nomem(sqlite3_context *pCtx) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_int(sqlite3_context *pCtx, int iVal) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_null(sqlite3_context *pCtx) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_text(
  sqlite3_context *pCtx,
  const char *z,
  int n,
  void (*xDel)(void *)
) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_text64(
  sqlite3_context *pCtx,
  const char *z,
  sqlite3_uint64 n,
  void (*xDel)(void *),
  unsigned char enc
) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_text16(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_text16le(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_text16be(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_pointer(
  sqlite3_context *pCtx,
  void *pPtr,
  const char *zPType,
  void (*xDestructor)(void*)
) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_result_zeroblob64(sqlite3_context *pCtx, u64 n) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_create_collation(
  sqlite3* db,
  const char *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*)
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_create_collation_v2(
  sqlite3* db,
  const char *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDel)(void*)
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_create_collation16(
  sqlite3* db,
  const void *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*)
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_collation_needed(
  sqlite3 *db,
  void *pCollNeededArg,
  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*)
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_collation_needed16(
  sqlite3 *db,
  void *pCollNeededArg,
  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*)
) {
    return 0;
}

SQLITE_API int sqlite3_sleep(int ms) {
    return sqlite3cloud_sleep(ms);
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_win32_set_directory(
  unsigned long type, /* Identifier for directory being set or reset */
  void *zValue        /* New value for directory being set or reset */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_win32_set_directory8(
  unsigned long type, /* Identifier for directory being set or reset */
  const char *zValue  /* New value for directory being set or reset */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_win32_set_directory16(
  unsigned long type, /* Identifier for directory being set or reset */
  const void *zValue  /* New value for directory being set or reset */
) {
    return 0;
}

SQLITE_API int sqlite3_get_autocommit(sqlite3 *db) {
    return 1;
}

SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt) {
    return (pStmt) ? pStmt->db : NULL;
}

SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName) {
    return sqlite3cloud_db_filename(db, zDbName);
}

SQLITE_API const char *sqlite3_db_name(sqlite3 *db, int N) {
    return (db) ? sqlite3cloud_db_name(db, N) : NULL;
}

SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName) {
    return (db) ? sqlite3cloud_db_readonly(db, zDbName) : -1;
}

SQLITE_API int sqlite3_txn_state(sqlite3 *db, const char *zSchema) {
    return (db) ? sqlite3cloud_txn_state(db, zSchema) : -1;
}

SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt) {
    return sqlite3cloud_next_stmt(pDb, pStmt);
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void *sqlite3_commit_hook(
  sqlite3 *db,              /* Attach the hook to this database */
  int (*xCallback)(void*),  /* Function to invoke on each commit */
  void *pArg                /* Argument to the function */
) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void *sqlite3_rollback_hook(
  sqlite3 *db,              /* Attach the hook to this database */
  void (*xCallback)(void*), /* Callback function */
  void *pArg                /* Argument to the function */
) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_autovacuum_pages(
  sqlite3 *db,                 /* Attach the hook to this database */
  unsigned int (*xCallback)(void*,const char*,u32,u32,u32),
  void *pArg,                  /* Argument to the function */
  void (*xDestructor)(void*)   /* Destructor for pArg */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void *sqlite3_update_hook(
  sqlite3 *db,              /* Attach the hook to this database */
  void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),
  void *pArg                /* Argument to the function */
) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_enable_shared_cache(int enable) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_release_memory(int n) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_db_release_memory(sqlite3 *db) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED sqlite3_int64 sqlite3_hard_heap_limit64(sqlite3_int64 n) {
    return 0;
}

SQLITE_API SQLITE_DEPRECATED SQLITECLOUD_NOT_NEEDED void sqlite3_soft_heap_limit(int n) {
    return ;
}

SQLITE_API int sqlite3_table_column_metadata(
  sqlite3 *db,                /* Connection handle */
  const char *zDbName,        /* Database name or NULL */
  const char *zTableName,     /* Table name */
  const char *zColumnName,    /* Column name */
  char const **pzDataType,    /* OUTPUT: Declared data type */
  char const **pzCollSeq,     /* OUTPUT: Collation sequence name */
  int *pNotNull,              /* OUTPUT: True if NOT NULL constraint exists */
  int *pPrimaryKey,           /* OUTPUT: True if column part of PK */
  int *pAutoinc               /* OUTPUT: True if column is auto-increment */
) {
    return sqlite3cloud_table_column_metadata(db, zDbName, zTableName, zColumnName, pzDataType, pzCollSeq, pNotNull, pPrimaryKey, pAutoinc);
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_load_extension(
  sqlite3 *db,          /* Load the extension into this database connection */
  const char *zFile,    /* Name of the shared library containing extension */
  const char *zProc,    /* Entry point.  Use "sqlite3_extension_init" if 0 */
  char **pzErrMsg       /* Put error message here if not 0 */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_enable_load_extension(sqlite3 *db, int onoff) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_auto_extension(
  void (*xInit)(void)
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_cancel_auto_extension(
  void (*xInit)(void)
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3_reset_auto_extension(void) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_create_module(
  sqlite3 *db,                    /* Database in which module is registered */
  const char *zName,              /* Name assigned to this module */
  const sqlite3_module *pModule,  /* The definition of the module */
  void *pAux                      /* Context pointer for xCreate/xConnect */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_create_module_v2(
  sqlite3 *db,                    /* Database in which module is registered */
  const char *zName,              /* Name assigned to this module */
  const sqlite3_module *pModule,  /* The definition of the module */
  void *pAux,                     /* Context pointer for xCreate/xConnect */
  void (*xDestroy)(void *)        /* Module destructor function */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_drop_modules(sqlite3 *db, const char** azNames) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_overload_function(
  sqlite3 *db,
  const char *zName,
  int nArg
) {
    return 0;
}

SQLITE_API int sqlite3_blob_open(
  sqlite3* db,            /* The database connection */
  const char *zDb,        /* The attached database containing the blob */
  const char *zTable,     /* The table containing the blob */
  const char *zColumn,    /* The column containing the blob */
  sqlite_int64 iRow,      /* The row containing the glob */
  int wrFlag,             /* True -> read/write access, false -> read-only */
  sqlite3_blob **ppBlob   /* Handle for accessing the blob returned here */
) {
    return sqlite3cloud_blob_open(db, zDb, zTable, zColumn, iRow, wrFlag, ppBlob);
}

SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow) {
    return (pBlob) ? sqlite3cloud_blob_reopen(pBlob, iRow) : SQLITE_MISUSE;
}

SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob) {
    return (pBlob) ? sqlite3cloud_blob_close(pBlob) : SQLITE_OK;
}

SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *pBlob) {
    return (pBlob) ? sqlite3cloud_blob_bytes(pBlob) : 0;
}

SQLITE_API int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset) {
    return (pBlob) ? sqlite3cloud_blob_read(pBlob, z, n, iOffset) : SQLITE_MISUSE;
}

SQLITE_API int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset) {
    return (pBlob) ? sqlite3cloud_blob_write(pBlob, z, n, iOffset) : SQLITE_MISUSE;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED sqlite3_vfs *sqlite3_vfs_find(const char *zVfs) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_vfs_unregister(sqlite3_vfs *pVfs) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_IMPLEMENTED sqlite3_mutex *sqlite3_mutex_alloc(int id) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_IMPLEMENTED void sqlite3_mutex_free(sqlite3_mutex *p) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_IMPLEMENTED void sqlite3_mutex_enter(sqlite3_mutex *p) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_IMPLEMENTED int sqlite3_mutex_try(sqlite3_mutex *p) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_IMPLEMENTED void sqlite3_mutex_leave(sqlite3_mutex *p) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_IMPLEMENTED int sqlite3_mutex_held(sqlite3_mutex *p) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_IMPLEMENTED int sqlite3_mutex_notheld(sqlite3_mutex *p) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_IMPLEMENTED sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_test_control(int op, ...) {
    return 0;
}

SQLITE_API int sqlite3_keyword_count(void) {
    return sqlite3cloud_keyword_count();
}

SQLITE_API int sqlite3_keyword_name(int i,const char **pzName,int *pnName) {
    return sqlite3cloud_keyword_name(i, pzName, pnName);
}

SQLITE_API int sqlite3_keyword_check(const char *zName, int nName) {
    return sqlite3cloud_keyword_check(zName, nName);
}

SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){
    return sqlite3cloud_status(op, (sqlite3_int64 *)pCurrent, (sqlite3_int64 *)pHighwater, resetFlag);
}

SQLITE_API int sqlite3_status64(
  int op,
  sqlite3_int64 *pCurrent,
  sqlite3_int64 *pHighwater,
  int resetFlag
) {
    return (int)sqlite3cloud_status(op, pCurrent, pHighwater, resetFlag);
}

SQLITE_API int sqlite3_db_status(
  sqlite3 *db,          /* The database connection whose status is desired */
  int op,               /* Status verb */
  int *pCurrent,        /* Write current value here */
  int *pHighwater,      /* Write high-water mark here */
  int resetFlag         /* Reset high-water mark if true */
) {
    return sqlite3cloud_db_status(db, op, pCurrent, pHighwater, resetFlag);
}

SQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag) {
    return (pStmt) ? sqlite3cloud_stmt_status(pStmt, op, resetFlag) : SQLITE_MISUSE;
}

SQLITE_API sqlite3_backup *sqlite3_backup_init(
  sqlite3* pDestDb,                     /* Database to write to */
  const char *zDestDb,                  /* Name of database within pDestDb */
  sqlite3* pSrcDb,                      /* Database connection to read from */
  const char *zSrcDb                    /* Name of database within pSrcDb */
) {
    return sqlite3cloud_backup_init(pDestDb, zDestDb, pSrcDb, zSrcDb);
}

SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage) {
    return (p) ? sqlite3cloud_backup_step(p, nPage) : SQLITE_MISUSE;
}

SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p) {
    return (p) ? sqlite3cloud_backup_finish(p) : SQLITE_OK;
}

SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p) {
    return (p) ? sqlite3cloud_backup_remaining(p) : 0;
}

SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p) {
    return (p) ? sqlite3cloud_backup_pagecount(p) : 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_unlock_notify(
  sqlite3 *db,
  void (*xNotify)(void **, int),
  void *pArg
) {
    return 0;
}

SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...) {
    va_list args;
    va_start(args, zFormat);
    sqlite3cloud_log(iErrCode, zFormat, args);
    va_end(args);
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void *sqlite3_wal_hook(
  sqlite3 *db,                    /* Attach the hook to this db handle */
  int(*xCallback)(void *, sqlite3*, const char*, int),
  void *pArg                      /* First argument passed to xCallback() */
) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_wal_checkpoint_v2(
  sqlite3 *db,                    /* Database handle */
  const char *zDb,                /* Name of attached database (or NULL) */
  int eMode,                      /* SQLITE_CHECKPOINT_* value */
  int *pnLog,                     /* OUT: Size of WAL log in frames */
  int *pnCkpt                     /* OUT: Total number of frames checkpointed */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_vtab_config(sqlite3 *db, int op, ...) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_vtab_on_conflict(sqlite3 *db) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_vtab_nochange(sqlite3_context *p) {
    return 0;
}

SQLITE_API SQLITE_EXPERIMENTAL SQLITECLOUD_NOT_NEEDED const char *sqlite3_vtab_collation(sqlite3_index_info *pIdxInfo, int iCons) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_vtab_distinct(sqlite3_index_info *pIdxInfo) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_vtab_in(sqlite3_index_info *pIdxInfo, int iCons, int bHandle) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_vtab_in_first(sqlite3_value *pVal, sqlite3_value **ppOut) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_vtab_in_next(sqlite3_value *pVal, sqlite3_value **ppOut) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_vtab_rhs_value(
  sqlite3_index_info *pIdxInfo,   /* Copy of first argument to xBestIndex */
  int iCons,                      /* Constraint for which RHS is wanted */
  sqlite3_value **ppVal           /* Write value extracted here */
) {
    return 0;
}

SQLITE_API int sqlite3_stmt_scanstatus(
  sqlite3_stmt *pStmt,            /* Prepared statement being queried */
  int idx,                        /* Index of loop to report on */
  int iScanStatusOp,              /* Which metric to return */
  void *pOut                      /* OUT: Write the answer here */
) {
    return sqlite3cloud_stmt_scanstatus(pStmt, idx, iScanStatusOp, 0, pOut);
}

SQLITE_API int sqlite3_stmt_scanstatus_v2(
  sqlite3_stmt *pStmt,      /* Prepared statement for which info desired */
  int idx,                  /* Index of loop to report on */
  int iScanStatusOp,        /* Information desired.  SQLITE_SCANSTAT_* */
  int flags,                /* Mask of flags defined below */
  void *pOut                /* Result written here */
) {
    return sqlite3cloud_stmt_scanstatus(pStmt, idx, iScanStatusOp, flags, pOut);
}

SQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt) {
    sqlite3cloud_stmt_scanstatus_reset(pStmt);
}

SQLITE_API int sqlite3_db_cacheflush(sqlite3 *db) {
    return sqlite3cloud_db_cacheflush(db);
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void *sqlite3_preupdate_hook(
  sqlite3 *db,              /* Attach the hook to this database */
  void(*xCallback)(         /* Callback function */
  void*,sqlite3*,int,char const*,char const*,sqlite3_int64,sqlite3_int64),
  void *pArg                /* First callback argument */
) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_preupdate_old(sqlite3 *db, int iIdx, sqlite3_value **ppValue) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_preupdate_count(sqlite3 *db) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_preupdate_depth(sqlite3 *db) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_preupdate_new(sqlite3 *db, int iIdx, sqlite3_value **ppValue) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_preupdate_blobwrite(sqlite3 *db) {
    return 0;
}

SQLITE_API SQLITE_EXPERIMENTAL SQLITECLOUD_NOT_NEEDED int sqlite3_snapshot_get(
  sqlite3 *db,
  const char *zDb,
  sqlite3_snapshot **ppSnapshot
) {
    return 0;
}

SQLITE_API SQLITE_EXPERIMENTAL SQLITECLOUD_NOT_NEEDED int sqlite3_snapshot_open(
  sqlite3 *db,
  const char *zDb,
  sqlite3_snapshot *pSnapshot
) {
    return 0;
}

SQLITE_API SQLITE_EXPERIMENTAL SQLITECLOUD_NOT_NEEDED void sqlite3_snapshot_free(sqlite3_snapshot *pSnapshot) {
    return ;
}

SQLITE_API SQLITE_EXPERIMENTAL SQLITECLOUD_NOT_NEEDED int sqlite3_snapshot_cmp(sqlite3_snapshot *p1, sqlite3_snapshot *p2) {
    return 0;
}

SQLITE_API SQLITE_EXPERIMENTAL SQLITECLOUD_NOT_NEEDED int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED unsigned char *sqlite3_serialize(
  sqlite3 *db,              /* The database connection */
  const char *zSchema,      /* Which database within the connection */
  sqlite3_int64 *piSize,    /* Write size here, if not NULL */
  unsigned int mFlags       /* Maybe SQLITE_SERIALIZE_NOCOPY */
) {
    return NULL;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_deserialize(
  sqlite3 *db,            /* The database connection */
  const char *zSchema,    /* Which DB to reopen with the deserialization */
  unsigned char *pData,   /* The serialized database content */
  sqlite3_int64 szDb,     /* Number bytes in the deserialization */
  sqlite3_int64 szBuf,    /* Total size of buffer pData[] */
  unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_rtree_geometry_callback(
  sqlite3 *db,                  /* Register SQL function on this connection */
  const char *zGeom,            /* Name of the new SQL function */
  int (*xGeom)(sqlite3_rtree_geometry*,int,RtreeDValue*,int*), /* Callback */
  void *pContext                /* Extra data associated with the callback */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3_rtree_query_callback(
  sqlite3 *db,                 /* Register SQL function on this connection */
  const char *zQueryFunc,      /* Name of new SQL function */
  int (*xQueryFunc)(sqlite3_rtree_query_info*), /* Callback */
  void *pContext,              /* Extra data passed into the callback */
  void (*xDestructor)(void*)   /* Destructor for the extra data */
) {
    return 0;
}

// MARK: - Session -

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_create(
  sqlite3 *db,                    /* Database handle */
  const char *zDb,                /* Name of db (e.g. "main") */
  sqlite3_session **ppSession     /* OUT: New session object */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3session_delete(sqlite3_session *pSession) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_object_config(sqlite3_session *pSession, int op, void *pArg) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_enable(sqlite3_session *pSession, int bEnable) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_indirect(sqlite3_session *pSession, int bIndirect) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_attach(
  sqlite3_session *pSession,      /* Session object */
  const char *zName               /* Table name */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3session_table_filter(
  sqlite3_session *pSession,
  int(*xFilter)(void*, const char*),
  void *pCtx                      /* First argument passed to xFilter */
) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_changeset(
  sqlite3_session *pSession,      /* Session object */
  int *pnChangeset,               /* OUT: Size of buffer at *ppChangeset */
  void **ppChangeset              /* OUT: Buffer containing changeset */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED sqlite3_int64 sqlite3session_changeset_size(sqlite3_session *pSession) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_diff(
  sqlite3_session *pSession,
  const char *zFrom,
  const char *zTbl,
  char **pzErrMsg
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_patchset(
  sqlite3_session *pSession,      /* Session object */
  int *pnPatchset,                /* OUT: Size of buffer at *ppChangeset */
  void **ppPatchset               /* OUT: Buffer containing changeset */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_isempty(sqlite3_session *pSession) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED sqlite3_int64 sqlite3session_memory_used(sqlite3_session *pSession) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_config(int op, void *pArg){
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_changeset_strm(
  sqlite3_session *pSession,
  int (*xOutput)(void *pOut, const void *pData, int nData),
  void *pOut
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3session_patchset_strm(
  sqlite3_session *pSession,
  int (*xOutput)(void *pOut, const void *pData, int nData),
  void *pOut
) {
    return 0;
}

// MARK: - Changeset -

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_start(
  sqlite3_changeset_iter **pp,    /* OUT: Changeset iterator handle */
  int nChangeset,                 /* Size of buffer pChangeset in bytes */
  void *pChangeset                /* Pointer to buffer containing changeset */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_start_v2(
  sqlite3_changeset_iter **pp,    /* OUT: Changeset iterator handle */
  int nChangeset,                 /* Size of buffer pChangeset in bytes */
  void *pChangeset,               /* Pointer to buffer containing changeset */
  int flags
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_next(sqlite3_changeset_iter *p) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_op(
  sqlite3_changeset_iter *pIter,  /* Iterator handle */
  const char **pzTab,             /* OUT: Pointer to table name */
  int *pnCol,                     /* OUT: Number of columns in table */
  int *pOp,                       /* OUT: SQLITE_INSERT, DELETE or UPDATE */
  int *pbIndirect                 /* OUT: True if change is indirect */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_pk(
  sqlite3_changeset_iter *pIter,  /* Iterator object */
  unsigned char **pabPK,          /* OUT: Array of boolean - true for PK cols */
  int *pnCol                      /* OUT: Number of entries in output array */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_old(
  sqlite3_changeset_iter *pIter,  /* Changeset iterator */
  int iVal,                       /* Index of old.* value to retrieve */
  sqlite3_value **ppValue         /* OUT: Old value (or NULL pointer) */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_new(
  sqlite3_changeset_iter *pIter,  /* Changeset iterator */
  int iVal,                       /* Index of new.* value to retrieve */
  sqlite3_value **ppValue         /* OUT: New value (or NULL pointer) */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_conflict(
  sqlite3_changeset_iter *pIter,  /* Changeset iterator */
  int iVal,                       /* Index of conflict record value to fetch */
  sqlite3_value **ppValue         /* OUT: Value from conflicting row */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_fk_conflicts(
  sqlite3_changeset_iter *pIter,  /* Changeset iterator */
  int *pnOut                      /* OUT: Number of FK violations */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_finalize(sqlite3_changeset_iter *p) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_invert(
  int nChangeset,                 /* Number of bytes in input */
  const void *pChangeset,         /* Input changeset */
  int *pnInverted,                /* OUT: Number of bytes in output changeset */
  void **ppInverted               /* OUT: Inverse of pChangeset */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_concat(
  int nLeft,                      /* Number of bytes in lhs input */
  void *pLeft,                    /* Lhs input changeset */
  int nRight                      /* Number of bytes in rhs input */,
  void *pRight,                   /* Rhs input changeset */
  int *pnOut,                     /* OUT: Number of bytes in output changeset */
  void **ppOut                    /* OUT: changeset (left <concat> right) */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changegroup_new(sqlite3_changegroup **pp) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changegroup_add(sqlite3_changegroup *pGrp, int nData, void *pData) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changegroup_output(
    sqlite3_changegroup *pGrp,
    int *pnData,
    void **ppData
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3changegroup_delete(sqlite3_changegroup *pGrp) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_apply(
  sqlite3 *db,                    /* Apply change to "main" db of this handle */
  int nChangeset,                 /* Size of changeset in bytes */
  void *pChangeset,               /* Changeset blob */
  int(*xFilter)(
    void *pCtx,                   /* Copy of sixth arg to _apply() */
    const char *zTab              /* Table name */
  ),
  int(*xConflict)(
    void *pCtx,                   /* Copy of fifth arg to _apply() */
    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
    sqlite3_changeset_iter *p     /* Handle describing change and conflict */
  ),
  void *pCtx                      /* First argument passed to xConflict */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_apply_v2(
  sqlite3 *db,                    /* Apply change to "main" db of this handle */
  int nChangeset,                 /* Size of changeset in bytes */
  void *pChangeset,               /* Changeset blob */
  int(*xFilter)(
    void *pCtx,                   /* Copy of sixth arg to _apply() */
    const char *zTab              /* Table name */
  ),
  int(*xConflict)(
    void *pCtx,                   /* Copy of sixth arg to _apply() */
    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
    sqlite3_changeset_iter *p     /* Handle describing change and conflict */
  ),
  void *pCtx,                     /* First argument passed to xConflict */
  void **ppRebase, int *pnRebase,
  int flags
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_apply_strm(
  sqlite3 *db,                    /* Apply change to "main" db of this handle */
  int (*xInput)(void *pIn, void *pData, int *pnData), /* Input function */
  void *pIn,                                          /* First arg for xInput */
  int(*xFilter)(
    void *pCtx,                   /* Copy of sixth arg to _apply() */
    const char *zTab              /* Table name */
  ),
  int(*xConflict)(
    void *pCtx,                   /* Copy of sixth arg to _apply() */
    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
    sqlite3_changeset_iter *p     /* Handle describing change and conflict */
  ),
  void *pCtx                      /* First argument passed to xConflict */
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_apply_v2_strm(
  sqlite3 *db,                    /* Apply change to "main" db of this handle */
  int (*xInput)(void *pIn, void *pData, int *pnData), /* Input function */
  void *pIn,                                          /* First arg for xInput */
  int(*xFilter)(
    void *pCtx,                   /* Copy of sixth arg to _apply() */
    const char *zTab              /* Table name */
  ),
  int(*xConflict)(
    void *pCtx,                   /* Copy of sixth arg to _apply() */
    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
    sqlite3_changeset_iter *p     /* Handle describing change and conflict */
  ),
  void *pCtx,                     /* First argument passed to xConflict */
  void **ppRebase, int *pnRebase,
  int flags
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_concat_strm(
  int (*xInputA)(void *pIn, void *pData, int *pnData),
  void *pInA,
  int (*xInputB)(void *pIn, void *pData, int *pnData),
  void *pInB,
  int (*xOutput)(void *pOut, const void *pData, int nData),
  void *pOut
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_invert_strm(
  int (*xInput)(void *pIn, void *pData, int *pnData),
  void *pIn,
  int (*xOutput)(void *pOut, const void *pData, int nData),
  void *pOut
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_start_strm(
  sqlite3_changeset_iter **pp,    /* OUT: Changeset iterator handle */
  int (*xInput)(void *pIn, void *pData, int *pnData),
  void *pIn
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changeset_start_v2_strm(
  sqlite3_changeset_iter **pp,    /* OUT: Changeset iterator handle */
  int (*xInput)(void *pIn, void *pData, int *pnData),
  void *pIn,
  int flags
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changegroup_add_strm(
  sqlite3_changegroup *pGrp,
  int (*xInput)(void *pIn, void *pData, int *pnData),
  void *pIn
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3changegroup_output_strm(
  sqlite3_changegroup *pGrp,
  int (*xOutput)(void *pOut, const void *pData, int nData),
  void *pOut
) {
    return 0;
}

// MARK: - Rebaser -

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3rebaser_create(sqlite3_rebaser **ppNew) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3rebaser_configure(
  sqlite3_rebaser *p,
  int nRebase, const void *pRebase
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3rebaser_rebase(
  sqlite3_rebaser *p,
  int nIn, const void *pIn,
  int *pnOut, void **ppOut
) {
    return 0;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED void sqlite3rebaser_delete(sqlite3_rebaser *p) {
    return ;
}

SQLITE_API SQLITECLOUD_NOT_NEEDED int sqlite3rebaser_rebase_strm(
  sqlite3_rebaser *p,
  int (*xInput)(void *pIn, void *pData, int *pnData),
  void *pIn,
  int (*xOutput)(void *pOut, const void *pData, int nData),
  void *pOut
) {
    return 0;
}


     
//
// END FILE: sqlite3_api.c
// ----------------------------------------------------------------------------



// ----------------------------------------------------------------------------
// BEGIN FILE: sqlite3copy_api.c
//


/* DO NOT EDIT!
**
** This file is automatically generated by the sqlite3transform utility.
** This file containes the public and private SQLite API that need to be
** copied as-is.
**
** This code was generated on Mon Apr  3 04:00:32 2023
** Using sqlite3transform version 1.0.0
**
*/
// (AMALGAMATED) #include "sqlite3.h"
// (AMALGAMATED) #include "sqlite3_internals.h"
// (AMALGAMATED) #include "sqlite3cloud_api.h"

#include <ctype.h>
#include <assert.h>
#include <string.h>

SQLITE_PRIVATE u32 sqlite3Utf8Read(const unsigned char **pz);
static SQLITE_NOINLINE char *strAccumFinishRealloc(StrAccum *p);
SQLITE_PRIVATE void sqlite3StrAccumSetError(StrAccum *p, u8 eError);


SQLITE_PRIVATE const char *sqlite3ErrStr(int rc){
  static const char* const aMsg[] = {
    /* SQLITE_OK          */ "not an error",
    /* SQLITE_ERROR       */ "SQL logic error",
    /* SQLITE_INTERNAL    */ 0,
    /* SQLITE_PERM        */ "access permission denied",
    /* SQLITE_ABORT       */ "query aborted",
    /* SQLITE_BUSY        */ "database is locked",
    /* SQLITE_LOCKED      */ "database table is locked",
    /* SQLITE_NOMEM       */ "out of memory",
    /* SQLITE_READONLY    */ "attempt to write a readonly database",
    /* SQLITE_INTERRUPT   */ "interrupted",
    /* SQLITE_IOERR       */ "disk I/O error",
    /* SQLITE_CORRUPT     */ "database disk image is malformed",
    /* SQLITE_NOTFOUND    */ "unknown operation",
    /* SQLITE_FULL        */ "database or disk is full",
    /* SQLITE_CANTOPEN    */ "unable to open database file",
    /* SQLITE_PROTOCOL    */ "locking protocol",
    /* SQLITE_EMPTY       */ 0,
    /* SQLITE_SCHEMA      */ "database schema has changed",
    /* SQLITE_TOOBIG      */ "string or blob too big",
    /* SQLITE_CONSTRAINT  */ "constraint failed",
    /* SQLITE_MISMATCH    */ "datatype mismatch",
    /* SQLITE_MISUSE      */ "bad parameter or other API misuse",
#ifdef SQLITE_DISABLE_LFS
    /* SQLITE_NOLFS       */ "large file support is disabled",
#else
    /* SQLITE_NOLFS       */ 0,
#endif
    /* SQLITE_AUTH        */ "authorization denied",
    /* SQLITE_FORMAT      */ 0,
    /* SQLITE_RANGE       */ "column index out of range",
    /* SQLITE_NOTADB      */ "file is not a database",
    /* SQLITE_NOTICE      */ "notification message",
    /* SQLITE_WARNING     */ "warning message",
  };
  const char *zErr = "unknown error";
  switch( rc ){
    case SQLITE_ABORT_ROLLBACK: {
      zErr = "abort due to ROLLBACK";
      break;
    }
    case SQLITE_ROW: {
      zErr = "another row available";
      break;
    }
    case SQLITE_DONE: {
      zErr = "no more rows available";
      break;
    }
    default: {
      rc &= 0xff;
      if( ALWAYS(rc>=0) && rc<ArraySize(aMsg) && aMsg[rc]!=0 ){
        zErr = aMsg[rc];
      }
      break;
    }
  }
  return zErr;
}

static int patternCompare(
  const u8 *zPattern,              /* The glob pattern */
  const u8 *zString,               /* The string to compare against the glob */
  const struct compareInfo *pInfo, /* Information about how to do the compare */
  u32 matchOther                   /* The escape char (LIKE) or '[' (GLOB) */
){
  u32 c, c2;                       /* Next pattern and input string chars */
  u32 matchOne = pInfo->matchOne;  /* "?" or "_" */
  u32 matchAll = pInfo->matchAll;  /* "*" or "%" */
  u8 noCase = pInfo->noCase;       /* True if uppercase==lowercase */
  const u8 *zEscaped = 0;          /* One past the last escaped input char */

  while( (c = Utf8Read(zPattern))!=0 ){
    if( c==matchAll ){  /* Match "*" */
      /* Skip over multiple "*" characters in the pattern.  If there
      ** are also "?" characters, skip those as well, but consume a
      ** single character of the input string for each "?" skipped */
      while( (c=Utf8Read(zPattern)) == matchAll
             || (c == matchOne && matchOne!=0) ){
        if( c==matchOne && sqlite3Utf8Read(&zString)==0 ){
          return SQLITE_NOWILDCARDMATCH;
        }
      }
      if( c==0 ){
        return SQLITE_MATCH;   /* "*" at the end of the pattern matches */
      }else if( c==matchOther ){
        if( pInfo->matchSet==0 ){
          c = sqlite3Utf8Read(&zPattern);
          if( c==0 ) return SQLITE_NOWILDCARDMATCH;
        }else{
          /* "[...]" immediately follows the "*".  We have to do a slow
          ** recursive search in this case, but it is an unusual case. */
          assert( matchOther<0x80 );  /* '[' is a single-byte character */
          while( *zString ){
            int bMatch = patternCompare(&zPattern[-1],zString,pInfo,matchOther);
            if( bMatch!=SQLITE_NOMATCH ) return bMatch;
            SQLITE_SKIP_UTF8(zString);
          }
          return SQLITE_NOWILDCARDMATCH;
        }
      }

      /* At this point variable c contains the first character of the
      ** pattern string past the "*".  Search in the input string for the
      ** first matching character and recursively continue the match from
      ** that point.
      **
      ** For a case-insensitive search, set variable cx to be the same as
      ** c but in the other case and search the input string for either
      ** c or cx.
      */
      if( c<0x80 ){
        char zStop[3];
        int bMatch;
        if( noCase ){
          zStop[0] = sqlite3Toupper(c);
          zStop[1] = sqlite3Tolower(c);
          zStop[2] = 0;
        }else{
          zStop[0] = c;
          zStop[1] = 0;
        }
        while(1){
          zString += strcspn((const char*)zString, zStop);
          if( zString[0]==0 ) break;
          zString++;
          bMatch = patternCompare(zPattern,zString,pInfo,matchOther);
          if( bMatch!=SQLITE_NOMATCH ) return bMatch;
        }
      }else{
        int bMatch;
        while( (c2 = Utf8Read(zString))!=0 ){
          if( c2!=c ) continue;
          bMatch = patternCompare(zPattern,zString,pInfo,matchOther);
          if( bMatch!=SQLITE_NOMATCH ) return bMatch;
        }
      }
      return SQLITE_NOWILDCARDMATCH;
    }
    if( c==matchOther ){
      if( pInfo->matchSet==0 ){
        c = sqlite3Utf8Read(&zPattern);
        if( c==0 ) return SQLITE_NOMATCH;
        zEscaped = zPattern;
      }else{
        u32 prior_c = 0;
        int seen = 0;
        int invert = 0;
        c = sqlite3Utf8Read(&zString);
        if( c==0 ) return SQLITE_NOMATCH;
        c2 = sqlite3Utf8Read(&zPattern);
        if( c2=='^' ){
          invert = 1;
          c2 = sqlite3Utf8Read(&zPattern);
        }
        if( c2==']' ){
          if( c==']' ) seen = 1;
          c2 = sqlite3Utf8Read(&zPattern);
        }
        while( c2 && c2!=']' ){
          if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){
            c2 = sqlite3Utf8Read(&zPattern);
            if( c>=prior_c && c<=c2 ) seen = 1;
            prior_c = 0;
          }else{
            if( c==c2 ){
              seen = 1;
            }
            prior_c = c2;
          }
          c2 = sqlite3Utf8Read(&zPattern);
        }
        if( c2==0 || (seen ^ invert)==0 ){
          return SQLITE_NOMATCH;
        }
        continue;
      }
    }
    c2 = Utf8Read(zString);
    if( c==c2 ) continue;
    if( noCase  && sqlite3Tolower(c)==sqlite3Tolower(c2) && c<0x80 && c2<0x80 ){
      continue;
    }
    if( c==matchOne && zPattern!=zEscaped && c2!=0 ) continue;
    return SQLITE_NOMATCH;
  }
  return *zString==0 ? SQLITE_MATCH : SQLITE_NOMATCH;
}

SQLITE_PRIVATE u32 sqlite3Utf8Read(
  const unsigned char **pz    /* Pointer to string from which to read char */
){
  unsigned int c;

  /* Same as READ_UTF8() above but without the zTerm parameter.
  ** For this routine, we assume the UTF8 string is always zero-terminated.
  */
  c = *((*pz)++);
  if( c>=0xc0 ){
    c = sqlite3Utf8Trans1[c-0xc0];
    while( (*(*pz) & 0xc0)==0x80 ){
      c = (c<<6) + (0x3f & *((*pz)++));
    }
    if( c<0x80
        || (c&0xFFFFF800)==0xD800
        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }
  }
  return c;
}

SQLITE_PRIVATE int sqlite3StrICmp(const char *zLeft, const char *zRight){
  unsigned char *a, *b;
  int c, x;
  a = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  for(;;){
    c = *a;
    x = *b;
    if( c==x ){
      if( c==0 ) break;
    }else{
      c = (int)UpperToLower[c] - (int)UpperToLower[x];
      if( c ) break;
    }
    a++;
    b++;
  }
  return c;
}

SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx){
  p->zText = zBase;
  p->db = db;
  p->nAlloc = n;
  p->mxAlloc = mx;
  p->nChar = 0;
  p->accError = 0;
  p->printfFlags = 0;
}

SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum *p){
  if( p->zText ){
    p->zText[p->nChar] = 0;
    if( p->mxAlloc>0 && !isMalloced(p) ){
      return strAccumFinishRealloc(p);
    }
  }
  return p->zText;
}

static SQLITE_NOINLINE char *strAccumFinishRealloc(StrAccum *p){
  char *zText;
  assert( p->mxAlloc>0 && !isMalloced(p) );
  zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );
  if( zText ){
    memcpy(zText, p->zText, p->nChar+1);
    p->printfFlags |= SQLITE_PRINTF_MALLOCED;
  }else{
    sqlite3StrAccumSetError(p, SQLITE_NOMEM);
  }
  p->zText = zText;
  return zText;
}

SQLITE_PRIVATE void sqlite3StrAccumSetError(StrAccum *p, u8 eError){
  assert( eError==SQLITE_NOMEM || eError==SQLITE_TOOBIG );
  p->accError = eError;
  if( p->mxAlloc ) sqlite3_str_reset(p);
  if( eError==SQLITE_TOOBIG ) sqlite3ErrorToParser(p->db, eError);
}

SQLITE_PRIVATE int sqlite3StrAccumEnlarge(StrAccum *p, i64 N){
  char *zNew;
  assert( p->nChar+N >= p->nAlloc ); /* Only called if really needed */
  if( p->accError ){
    testcase(p->accError==SQLITE_TOOBIG);
    testcase(p->accError==SQLITE_NOMEM);
    return 0;
  }
  if( p->mxAlloc==0 ){
    sqlite3StrAccumSetError(p, SQLITE_TOOBIG);
    return p->nAlloc - p->nChar - 1;
  }else{
    char *zOld = isMalloced(p) ? p->zText : 0;
    i64 szNew = p->nChar + N + 1;
    if( szNew+p->nChar<=p->mxAlloc ){
      /* Force exponential buffer size growth as long as it does not overflow,
      ** to avoid having to call this routine too often */
      szNew += p->nChar;
    }
    if( szNew > p->mxAlloc ){
      sqlite3_str_reset(p);
      sqlite3StrAccumSetError(p, SQLITE_TOOBIG);
      return 0;
    }else{
      p->nAlloc = (int)szNew;
    }
    if( p->db ){
      zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);
    }else{
      zNew = sqlite3Realloc(zOld, p->nAlloc);
    }
    if( zNew ){
      assert( p->zText!=0 || p->nChar==0 );
      if( !isMalloced(p) && p->nChar>0 ) memcpy(zNew, p->zText, p->nChar);
      p->zText = zNew;
      p->nAlloc = sqlite3DbMallocSize(p->db, zNew);
      p->printfFlags |= SQLITE_PRINTF_MALLOCED;
    }else{
      sqlite3_str_reset(p);
      sqlite3StrAccumSetError(p, SQLITE_NOMEM);
      return 0;
    }
  }
  assert( N>=0 && N<=0x7fffffff );
  return (int)N;
}

static void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N){
  N = sqlite3StrAccumEnlarge(p, N);
  if( N>0 ){
    memcpy(&p->zText[p->nChar], z, N);
    p->nChar += N;
  }
}

SQLITE_PRIVATE int sqlite3Strlen30(const char *z){
  if( z==0 ) return 0;
  return 0x3fffffff & (int)strlen(z);
}

static sqlite3_int64 getIntArg(PrintfArguments *p){
  if( p->nArg<=p->nUsed ) return 0;
  return sqlite3_value_int64(p->apArg[p->nUsed++]);
}

static double getDoubleArg(PrintfArguments *p){
  if( p->nArg<=p->nUsed ) return 0.0;
  return sqlite3_value_double(p->apArg[p->nUsed++]);
}

static char *getTextArg(PrintfArguments *p){
  if( p->nArg<=p->nUsed ) return 0;
  return (char*)sqlite3_value_text(p->apArg[p->nUsed++]);
}

static char *printfTempBuf(sqlite3_str *pAccum, sqlite3_int64 n){
  char *z;
  if( pAccum->accError ) return 0;
  if( n>pAccum->nAlloc && n>pAccum->mxAlloc ){
    sqlite3StrAccumSetError(pAccum, SQLITE_TOOBIG);
    return 0;
  }
  z = sqlite3DbMallocRaw(pAccum->db, n);
  if( z==0 ){
    sqlite3StrAccumSetError(pAccum, SQLITE_NOMEM);
  }
  return z;
}

static char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){
  int digit;
  LONGDOUBLE_TYPE d;
  if( (*cnt)<=0 ) return '0';
  (*cnt)--;
  digit = (int)*val;
  d = digit;
  digit += '0';
  *val = (*val - d)*10.0;
  return (char)digit;
}

SQLITE_PRIVATE int sqlite3IsNaN(double x){
  int rc;   /* The value return */
#if !SQLITE_HAVE_ISNAN && !HAVE_ISNAN
  u64 y;
  memcpy(&y,&x,sizeof(y));
  rc = IsNaN(y);
#else
  rc = isnan(x);
#endif /* HAVE_ISNAN */
  testcase( rc );
  return rc;
}

SQLITE_PRIVATE int sqlite3ErrorToParser(sqlite3 *db, int errCode){
	return errCode;
}

//MARK: -
SQLITE_API const char *sqlite3_errstr(int rc){
  return sqlite3ErrStr(rc);
}

SQLITE_API int sqlite3_strglob(const char *zGlobPattern, const char *zString){
  if( zString==0 ){
    return zGlobPattern!=0;
  }else if( zGlobPattern==0 ){
    return 1;
  }else {
    return patternCompare((u8*)zGlobPattern, (u8*)zString, &globInfo, '[');
  }
}

SQLITE_API int sqlite3_strlike(const char *zPattern, const char *zStr, unsigned int esc){
  if( zStr==0 ){
    return zPattern!=0;
  }else if( zPattern==0 ){
    return 1;
  }else{
    return patternCompare((u8*)zPattern, (u8*)zStr, &likeInfoNorm, esc);
  }
}

SQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight){
  if( zLeft==0 ){
    return zRight ? -1 : 0;
  }else if( zRight==0 ){
    return 1;
  }
  return sqlite3StrICmp(zLeft, zRight);
}

SQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){
  register unsigned char *a, *b;
  if( zLeft==0 ){
    return zRight ? -1 : 0;
  }else if( zRight==0 ){
    return 1;
  }
  a = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  while( N-- > 0 && *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; }
  return N<0 ? 0 : UpperToLower[*a] - UpperToLower[*b];
}

SQLITE_API sqlite3_str *sqlite3_str_new(sqlite3 *db){
  sqlite3_str *p = sqlite3_malloc64(sizeof(*p));
  if( p ){
    sqlite3StrAccumInit(p, 0, 0, 0,
            db ? db->aLimit[SQLITE_LIMIT_LENGTH] : SQLITE_MAX_LENGTH);
  }else{
    p = &sqlite3OomStr;
  }
  return p;
}

SQLITE_API char *sqlite3_str_finish(sqlite3_str *p){
  char *z;
  if( p!=0 && p!=&sqlite3OomStr ){
    z = sqlite3StrAccumFinish(p);
    sqlite3_free(p);
  }else{
    z = 0;
  }
  return z;
}

SQLITE_API void sqlite3_str_appendchar(sqlite3_str *p, int N, char c){
  testcase( p->nChar + (i64)N > 0x7fffffff );
  if( p->nChar+(i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ){
    return;
  }
  while( (N--)>0 ) p->zText[p->nChar++] = c;
}

SQLITE_API void sqlite3_str_append(sqlite3_str *p, const char *z, int N){
  assert( z!=0 || N==0 );
  assert( p->zText!=0 || p->nChar==0 || p->accError );
  assert( N>=0 );
  assert( p->accError==0 || p->nAlloc==0 || p->mxAlloc==0 );
  if( p->nChar+N >= p->nAlloc ){
    enlargeAndAppend(p,z,N);
  }else if( N ){
    assert( p->zText );
    p->nChar += N;
    memcpy(&p->zText[p->nChar-N], z, N);
  }
}

SQLITE_API void sqlite3_str_appendall(sqlite3_str *p, const char *z){
  sqlite3_str_append(p, z, sqlite3Strlen30(z));
}

SQLITE_API void sqlite3_str_appendf(StrAccum *p, const char *zFormat, ...){
  va_list ap;
  va_start(ap,zFormat);
  sqlite3_str_vappendf(p, zFormat, ap);
  va_end(ap);
}

SQLITE_API void sqlite3_str_vappendf(
  sqlite3_str *pAccum,       /* Accumulate results here */
  const char *fmt,           /* Format string */
  va_list ap                 /* arguments */
){
  int c;                     /* Next character in the format string */
  char *bufpt;               /* Pointer to the conversion buffer */
  int precision;             /* Precision of the current field */
  int length;                /* Length of the field */
  int idx;                   /* A general purpose loop counter */
  int width;                 /* Width of the current field */
  etByte flag_leftjustify;   /* True if "-" flag is present */
  etByte flag_prefix;        /* '+' or ' ' or 0 for prefix */
  etByte flag_alternateform; /* True if "#" flag is present */
  etByte flag_altform2;      /* True if "!" flag is present */
  etByte flag_zeropad;       /* True if field width constant starts with zero */
  etByte flag_long;          /* 1 for the "l" flag, 2 for "ll", 0 by default */
  etByte done;               /* Loop termination flag */
  etByte cThousand;          /* Thousands separator for %d and %u */
  etByte xtype = etINVALID;  /* Conversion paradigm */
  u8 bArgList;               /* True for SQLITE_PRINTF_SQLFUNC */
  char prefix;               /* Prefix character.  "+" or "-" or " " or '\0'. */
  sqlite_uint64 longvalue;   /* Value for integer types */
  LONGDOUBLE_TYPE realvalue; /* Value for real types */
  const et_info *infop;      /* Pointer to the appropriate info structure */
  char *zOut;                /* Rendering buffer */
  int nOut;                  /* Size of the rendering buffer */
  char *zExtra = 0;          /* Malloced memory used by some conversion */
#ifndef SQLITE_OMIT_FLOATING_POINT
  int  exp, e2;              /* exponent of real numbers */
  int nsd;                   /* Number of significant digits returned */
  double rounder;            /* Used for rounding floating point values */
  etByte flag_dp;            /* True if decimal point should be shown */
  etByte flag_rtz;           /* True if trailing zeros should be removed */
#endif
  PrintfArguments *pArgList = 0; /* Arguments for SQLITE_PRINTF_SQLFUNC */
  char buf[etBUFSIZE];       /* Conversion buffer */

  /* pAccum never starts out with an empty buffer that was obtained from
  ** malloc().  This precondition is required by the mprintf("%z...")
  ** optimization. */
  assert( pAccum->nChar>0 || (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );

  bufpt = 0;
  if( (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)!=0 ){
    pArgList = va_arg(ap, PrintfArguments*);
    bArgList = 1;
  }else{
    bArgList = 0;
  }
  for(; (c=(*fmt))!=0; ++fmt){
    if( c!='%' ){
      bufpt = (char *)fmt;
#if HAVE_STRCHRNUL
      fmt = strchrnul(fmt, '%');
#else
      do{ fmt++; }while( *fmt && *fmt != '%' );
#endif
      sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));
      if( *fmt==0 ) break;
    }
    if( (c=(*++fmt))==0 ){
      sqlite3_str_append(pAccum, "%", 1);
      break;
    }
    /* Find out what flags are present */
    flag_leftjustify = flag_prefix = cThousand =
     flag_alternateform = flag_altform2 = flag_zeropad = 0;
    done = 0;
    width = 0;
    flag_long = 0;
    precision = -1;
    do{
      switch( c ){
        case '-':   flag_leftjustify = 1;     break;
        case '+':   flag_prefix = '+';        break;
        case ' ':   flag_prefix = ' ';        break;
        case '#':   flag_alternateform = 1;   break;
        case '!':   flag_altform2 = 1;        break;
        case '0':   flag_zeropad = 1;         break;
        case ',':   cThousand = ',';          break;
        default:    done = 1;                 break;
        case 'l': {
          flag_long = 1;
          c = *++fmt;
          if( c=='l' ){
            c = *++fmt;
            flag_long = 2;
          }
          done = 1;
          break;
        }
        case '1': case '2': case '3': case '4': case '5':
        case '6': case '7': case '8': case '9': {
          unsigned wx = c - '0';
          while( (c = *++fmt)>='0' && c<='9' ){
            wx = wx*10 + c - '0';
          }
          testcase( wx>0x7fffffff );
          width = wx & 0x7fffffff;
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
          if( width>SQLITE_PRINTF_PRECISION_LIMIT ){
            width = SQLITE_PRINTF_PRECISION_LIMIT;
          }
#endif
          if( c!='.' && c!='l' ){
            done = 1;
          }else{
            fmt--;
          }
          break;
        }
        case '*': {
          if( bArgList ){
            width = (int)getIntArg(pArgList);
          }else{
            width = va_arg(ap,int);
          }
          if( width<0 ){
            flag_leftjustify = 1;
            width = width >= -2147483647 ? -width : 0;
          }
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
          if( width>SQLITE_PRINTF_PRECISION_LIMIT ){
            width = SQLITE_PRINTF_PRECISION_LIMIT;
          }
#endif
          if( (c = fmt[1])!='.' && c!='l' ){
            c = *++fmt;
            done = 1;
          }
          break;
        }
        case '.': {
          c = *++fmt;
          if( c=='*' ){
            if( bArgList ){
              precision = (int)getIntArg(pArgList);
            }else{
              precision = va_arg(ap,int);
            }
            if( precision<0 ){
              precision = precision >= -2147483647 ? -precision : -1;
            }
            c = *++fmt;
          }else{
            unsigned px = 0;
            while( c>='0' && c<='9' ){
              px = px*10 + c - '0';
              c = *++fmt;
            }
            testcase( px>0x7fffffff );
            precision = px & 0x7fffffff;
          }
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
          if( precision>SQLITE_PRINTF_PRECISION_LIMIT ){
            precision = SQLITE_PRINTF_PRECISION_LIMIT;
          }
#endif
          if( c=='l' ){
            --fmt;
          }else{
            done = 1;
          }
          break;
        }
      }
    }while( !done && (c=(*++fmt))!=0 );

    /* Fetch the info entry for the field */
    infop = &fmtinfo[0];
    xtype = etINVALID;
    for(idx=0; idx<ArraySize(fmtinfo); idx++){
      if( c==fmtinfo[idx].fmttype ){
        infop = &fmtinfo[idx];
        xtype = infop->type;
        break;
      }
    }

    /*
    ** At this point, variables are initialized as follows:
    **
    **   flag_alternateform          TRUE if a '#' is present.
    **   flag_altform2               TRUE if a '!' is present.
    **   flag_prefix                 '+' or ' ' or zero
    **   flag_leftjustify            TRUE if a '-' is present or if the
    **                               field width was negative.
    **   flag_zeropad                TRUE if the width began with 0.
    **   flag_long                   1 for "l", 2 for "ll"
    **   width                       The specified field width.  This is
    **                               always non-negative.  Zero is the default.
    **   precision                   The specified precision.  The default
    **                               is -1.
    **   xtype                       The class of the conversion.
    **   infop                       Pointer to the appropriate info struct.
    */
    assert( width>=0 );
    assert( precision>=(-1) );
    switch( xtype ){
      case etPOINTER:
        flag_long = sizeof(char*)==sizeof(i64) ? 2 :
                     sizeof(char*)==sizeof(long int) ? 1 : 0;
        /* no break */ deliberate_fall_through
      case etORDINAL:
      case etRADIX:
        cThousand = 0;
        /* no break */ deliberate_fall_through
      case etDECIMAL:
        if( infop->flags & FLAG_SIGNED ){
          i64 v;
          if( bArgList ){
            v = getIntArg(pArgList);
          }else if( flag_long ){
            if( flag_long==2 ){
              v = va_arg(ap,i64) ;
            }else{
              v = va_arg(ap,long int);
            }
          }else{
            v = va_arg(ap,int);
          }
          if( v<0 ){
            testcase( v==SMALLEST_INT64 );
            testcase( v==(-1) );
            longvalue = ~v;
            longvalue++;
            prefix = '-';
          }else{
            longvalue = v;
            prefix = flag_prefix;
          }
        }else{
          if( bArgList ){
            longvalue = (u64)getIntArg(pArgList);
          }else if( flag_long ){
            if( flag_long==2 ){
              longvalue = va_arg(ap,u64);
            }else{
              longvalue = va_arg(ap,unsigned long int);
            }
          }else{
            longvalue = va_arg(ap,unsigned int);
          }
          prefix = 0;
        }
        if( longvalue==0 ) flag_alternateform = 0;
        if( flag_zeropad && precision<width-(prefix!=0) ){
          precision = width-(prefix!=0);
        }
        if( precision<etBUFSIZE-10-etBUFSIZE/3 ){
          nOut = etBUFSIZE;
          zOut = buf;
        }else{
          u64 n;
          n = (u64)precision + 10;
          if( cThousand ) n += precision/3;
          zOut = zExtra = printfTempBuf(pAccum, n);
          if( zOut==0 ) return;
          nOut = (int)n;
        }
        bufpt = &zOut[nOut-1];
        if( xtype==etORDINAL ){
          static const char zOrd[] = "thstndrd";
          int x = (int)(longvalue % 10);
          if( x>=4 || (longvalue/10)%10==1 ){
            x = 0;
          }
          *(--bufpt) = zOrd[x*2+1];
          *(--bufpt) = zOrd[x*2];
        }
        {
          const char *cset = &aDigits[infop->charset];
          u8 base = infop->base;
          do{                                           /* Convert to ascii */
            *(--bufpt) = cset[longvalue%base];
            longvalue = longvalue/base;
          }while( longvalue>0 );
        }
        length = (int)(&zOut[nOut-1]-bufpt);
        while( precision>length ){
          *(--bufpt) = '0';                             /* Zero pad */
          length++;
        }
        if( cThousand ){
          int nn = (length - 1)/3;  /* Number of "," to insert */
          int ix = (length - 1)%3 + 1;
          bufpt -= nn;
          for(idx=0; nn>0; idx++){
            bufpt[idx] = bufpt[idx+nn];
            ix--;
            if( ix==0 ){
              bufpt[++idx] = cThousand;
              nn--;
              ix = 3;
            }
          }
        }
        if( prefix ) *(--bufpt) = prefix;               /* Add sign */
        if( flag_alternateform && infop->prefix ){      /* Add "0" or "0x" */
          const char *pre;
          char x;
          pre = &aPrefix[infop->prefix];
          for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;
        }
        length = (int)(&zOut[nOut-1]-bufpt);
        break;
      case etFLOAT:
      case etEXP:
      case etGENERIC:
        if( bArgList ){
          realvalue = getDoubleArg(pArgList);
        }else{
          realvalue = va_arg(ap,double);
        }
#ifdef SQLITE_OMIT_FLOATING_POINT
        length = 0;
#else
        if( precision<0 ) precision = 6;         /* Set default precision */
#ifdef SQLITE_FP_PRECISION_LIMIT
        if( precision>SQLITE_FP_PRECISION_LIMIT ){
          precision = SQLITE_FP_PRECISION_LIMIT;
        }
#endif
        if( realvalue<0.0 ){
          realvalue = -realvalue;
          prefix = '-';
        }else{
          prefix = flag_prefix;
        }
        if( xtype==etGENERIC && precision>0 ) precision--;
        testcase( precision>0xfff );
        idx = precision & 0xfff;
        rounder = arRound[idx%10];
        while( idx>=10 ){ rounder *= 1.0e-10; idx -= 10; }
        if( xtype==etFLOAT ){
          double rx = (double)realvalue;
          sqlite3_uint64 u;
          int ex;
          memcpy(&u, &rx, sizeof(u));
          ex = -1023 + (int)((u>>52)&0x7ff);
          if( precision+(ex/3) < 15 ) rounder += realvalue*3e-16;
          realvalue += rounder;
        }
        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */
        exp = 0;
        if( sqlite3IsNaN((double)realvalue) ){
          bufpt = "NaN";
          length = 3;
          break;
        }
        if( realvalue>0.0 ){
          LONGDOUBLE_TYPE scale = 1.0;
          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}
          while( realvalue>=1e10*scale && exp<=350 ){ scale *= 1e10; exp+=10; }
          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }
          realvalue /= scale;
          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }
          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }
          if( exp>350 ){
            bufpt = buf;
            buf[0] = prefix;
            memcpy(buf+(prefix!=0),"Inf",4);
            length = 3+(prefix!=0);
            break;
          }
        }
        bufpt = buf;
        /*
        ** If the field type is etGENERIC, then convert to either etEXP
        ** or etFLOAT, as appropriate.
        */
        if( xtype!=etFLOAT ){
          realvalue += rounder;
          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }
        }
        if( xtype==etGENERIC ){
          flag_rtz = !flag_alternateform;
          if( exp<-4 || exp>precision ){
            xtype = etEXP;
          }else{
            precision = precision - exp;
            xtype = etFLOAT;
          }
        }else{
          flag_rtz = flag_altform2;
        }
        if( xtype==etEXP ){
          e2 = 0;
        }else{
          e2 = exp;
        }
        {
          i64 szBufNeeded;           /* Size of a temporary buffer needed */
          szBufNeeded = MAX(e2,0)+(i64)precision+(i64)width+15;
          if( szBufNeeded > etBUFSIZE ){
            bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);
            if( bufpt==0 ) return;
          }
        }
        zOut = bufpt;
        nsd = 16 + flag_altform2*10;
        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;
        /* The sign in front of the number */
        if( prefix ){
          *(bufpt++) = prefix;
        }
        /* Digits prior to the decimal point */
        if( e2<0 ){
          *(bufpt++) = '0';
        }else{
          for(; e2>=0; e2--){
            *(bufpt++) = et_getdigit(&realvalue,&nsd);
          }
        }
        /* The decimal point */
        if( flag_dp ){
          *(bufpt++) = '.';
        }
        /* "0" digits after the decimal point but before the first
        ** significant digit of the number */
        for(e2++; e2<0; precision--, e2++){
          assert( precision>0 );
          *(bufpt++) = '0';
        }
        /* Significant digits after the decimal point */
        while( (precision--)>0 ){
          *(bufpt++) = et_getdigit(&realvalue,&nsd);
        }
        /* Remove trailing zeros and the "." if no digits follow the "." */
        if( flag_rtz && flag_dp ){
          while( bufpt[-1]=='0' ) *(--bufpt) = 0;
          assert( bufpt>zOut );
          if( bufpt[-1]=='.' ){
            if( flag_altform2 ){
              *(bufpt++) = '0';
            }else{
              *(--bufpt) = 0;
            }
          }
        }
        /* Add the "eNNN" suffix */
        if( xtype==etEXP ){
          *(bufpt++) = aDigits[infop->charset];
          if( exp<0 ){
            *(bufpt++) = '-'; exp = -exp;
          }else{
            *(bufpt++) = '+';
          }
          if( exp>=100 ){
            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */
            exp %= 100;
          }
          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */
          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */
        }
        *bufpt = 0;

        /* The converted number is in buf[] and zero terminated. Output it.
        ** Note that the number is in the usual order, not reversed as with
        ** integer conversions. */
        length = (int)(bufpt-zOut);
        bufpt = zOut;

        /* Special case:  Add leading zeros if the flag_zeropad flag is
        ** set and we are not left justified */
        if( flag_zeropad && !flag_leftjustify && length < width){
          int i;
          int nPad = width - length;
          for(i=width; i>=nPad; i--){
            bufpt[i] = bufpt[i-nPad];
          }
          i = prefix!=0;
          while( nPad-- ) bufpt[i++] = '0';
          length = width;
        }
#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */
        break;
      case etSIZE:
        if( !bArgList ){
          *(va_arg(ap,int*)) = pAccum->nChar;
        }
        length = width = 0;
        break;
      case etPERCENT:
        buf[0] = '%';
        bufpt = buf;
        length = 1;
        break;
      case etCHARX:
        if( bArgList ){
          bufpt = getTextArg(pArgList);
          length = 1;
          if( bufpt ){
            buf[0] = c = *(bufpt++);
            if( (c&0xc0)==0xc0 ){
              while( length<4 && (bufpt[0]&0xc0)==0x80 ){
                buf[length++] = *(bufpt++);
              }
            }
          }else{
            buf[0] = 0;
          }
        }else{
          unsigned int ch = va_arg(ap,unsigned int);
          if( ch<0x00080 ){
            buf[0] = ch & 0xff;
            length = 1;
          }else if( ch<0x00800 ){
            buf[0] = 0xc0 + (u8)((ch>>6)&0x1f);
            buf[1] = 0x80 + (u8)(ch & 0x3f);
            length = 2;
          }else if( ch<0x10000 ){
            buf[0] = 0xe0 + (u8)((ch>>12)&0x0f);
            buf[1] = 0x80 + (u8)((ch>>6) & 0x3f);
            buf[2] = 0x80 + (u8)(ch & 0x3f);
            length = 3;
          }else{
            buf[0] = 0xf0 + (u8)((ch>>18) & 0x07);
            buf[1] = 0x80 + (u8)((ch>>12) & 0x3f);
            buf[2] = 0x80 + (u8)((ch>>6) & 0x3f);
            buf[3] = 0x80 + (u8)(ch & 0x3f);
            length = 4;
          }
        }
        if( precision>1 ){
          i64 nPrior = 1;
          width -= precision-1;
          if( width>1 && !flag_leftjustify ){
            sqlite3_str_appendchar(pAccum, width-1, ' ');
            width = 0;
          }
          sqlite3_str_append(pAccum, buf, length);
          precision--;
          while( precision > 1 ){
            i64 nCopyBytes;
            if( nPrior > precision-1 ) nPrior = precision - 1;
            nCopyBytes = length*nPrior;
            if( nCopyBytes + pAccum->nChar >= pAccum->nAlloc ){
              sqlite3StrAccumEnlarge(pAccum, nCopyBytes);
            }
            if( pAccum->accError ) break;
            sqlite3_str_append(pAccum,
                 &pAccum->zText[pAccum->nChar-nCopyBytes], nCopyBytes);
            precision -= nPrior;
            nPrior *= 2;
          }
        }
        bufpt = buf;
        flag_altform2 = 1;
        goto adjust_width_for_utf8;
      case etSTRING:
      case etDYNSTRING:
        if( bArgList ){
          bufpt = getTextArg(pArgList);
          xtype = etSTRING;
        }else{
          bufpt = va_arg(ap,char*);
        }
        if( bufpt==0 ){
          bufpt = "";
        }else if( xtype==etDYNSTRING ){
          if( pAccum->nChar==0
           && pAccum->mxAlloc
           && width==0
           && precision<0
           && pAccum->accError==0
          ){
            /* Special optimization for sqlite3_mprintf("%z..."):
            ** Extend an existing memory allocation rather than creating
            ** a new one. */
            assert( (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );
            pAccum->zText = bufpt;
            pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);
            pAccum->nChar = 0x7fffffff & (int)strlen(bufpt);
            pAccum->printfFlags |= SQLITE_PRINTF_MALLOCED;
            length = 0;
            break;
          }
          zExtra = bufpt;
        }
        if( precision>=0 ){
          if( flag_altform2 ){
            /* Set length to the number of bytes needed in order to display
            ** precision characters */
            unsigned char *z = (unsigned char*)bufpt;
            while( precision-- > 0 && z[0] ){
              SQLITE_SKIP_UTF8(z);
            }
            length = (int)(z - (unsigned char*)bufpt);
          }else{
            for(length=0; length<precision && bufpt[length]; length++){}
          }
        }else{
          length = 0x7fffffff & (int)strlen(bufpt);
        }
      adjust_width_for_utf8:
        if( flag_altform2 && width>0 ){
          /* Adjust width to account for extra bytes in UTF-8 characters */
          int ii = length - 1;
          while( ii>=0 ) if( (bufpt[ii--] & 0xc0)==0x80 ) width++;
        }
        break;
      case etSQLESCAPE:           /* %q: Escape ' characters */
      case etSQLESCAPE2:          /* %Q: Escape ' and enclose in '...' */
      case etSQLESCAPE3: {        /* %w: Escape " characters */
        i64 i, j, k, n;
        int needQuote, isnull;
        char ch;
        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */
        char *escarg;

        if( bArgList ){
          escarg = getTextArg(pArgList);
        }else{
          escarg = va_arg(ap,char*);
        }
        isnull = escarg==0;
        if( isnull ) escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");
        /* For %q, %Q, and %w, the precision is the number of bytes (or
        ** characters if the ! flags is present) to use from the input.
        ** Because of the extra quoting characters inserted, the number
        ** of output characters may be larger than the precision.
        */
        k = precision;
        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){
          if( ch==q )  n++;
          if( flag_altform2 && (ch&0xc0)==0xc0 ){
            while( (escarg[i+1]&0xc0)==0x80 ){ i++; }
          }
        }
        needQuote = !isnull && xtype==etSQLESCAPE2;
        n += i + 3;
        if( n>etBUFSIZE ){
          bufpt = zExtra = printfTempBuf(pAccum, n);
          if( bufpt==0 ) return;
        }else{
          bufpt = buf;
        }
        j = 0;
        if( needQuote ) bufpt[j++] = q;
        k = i;
        for(i=0; i<k; i++){
          bufpt[j++] = ch = escarg[i];
          if( ch==q ) bufpt[j++] = ch;
        }
        if( needQuote ) bufpt[j++] = q;
        bufpt[j] = 0;
        length = j;
        goto adjust_width_for_utf8;
      }
      case etTOKEN: {
        if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;
        if( flag_alternateform ){
          /* %#T means an Expr pointer that uses Expr.u.zToken */
          Expr *pExpr = va_arg(ap,Expr*);
          if( ALWAYS(pExpr) && ALWAYS(!ExprHasProperty(pExpr,EP_IntValue)) ){
            sqlite3_str_appendall(pAccum, (const char*)pExpr->u.zToken);
            sqlite3RecordErrorOffsetOfExpr(pAccum->db, pExpr);
          }
        }else{
          /* %T means a Token pointer */
          Token *pToken = va_arg(ap, Token*);
          assert( bArgList==0 );
          if( pToken && pToken->n ){
            sqlite3_str_append(pAccum, (const char*)pToken->z, pToken->n);
            sqlite3RecordErrorByteOffset(pAccum->db, pToken->z);
          }
        }
        length = width = 0;
        break;
      }
      case etSRCITEM: {
        SrcItem *pItem;
        if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;
        pItem = va_arg(ap, SrcItem*);
        assert( bArgList==0 );
        if( pItem->zAlias && !flag_altform2 ){
          sqlite3_str_appendall(pAccum, pItem->zAlias);
        }else if( pItem->zName ){
          if( pItem->zDatabase ){
            sqlite3_str_appendall(pAccum, pItem->zDatabase);
            sqlite3_str_append(pAccum, ".", 1);
          }
          sqlite3_str_appendall(pAccum, pItem->zName);
        }else if( pItem->zAlias ){
          sqlite3_str_appendall(pAccum, pItem->zAlias);
        }else{
          Select *pSel = pItem->pSelect;
          assert( pSel!=0 );
          if( pSel->selFlags & SF_NestedFrom ){
            sqlite3_str_appendf(pAccum, "(join-%u)", pSel->selId);
          }else{
            sqlite3_str_appendf(pAccum, "(subquery-%u)", pSel->selId);
          }
        }
        length = width = 0;
        break;
      }
      default: {
        assert( xtype==etINVALID );
        return;
      }
    }/* End switch over the format type */
    /*
    ** The text of the conversion is pointed to by "bufpt" and is
    ** "length" characters long.  The field width is "width".  Do
    ** the output.  Both length and width are in bytes, not characters,
    ** at this point.  If the "!" flag was present on string conversions
    ** indicating that width and precision should be expressed in characters,
    ** then the values have been translated prior to reaching this point.
    */
    width -= length;
    if( width>0 ){
      if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');
      sqlite3_str_append(pAccum, bufpt, length);
      if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');
    }else{
      sqlite3_str_append(pAccum, bufpt, length);
    }

    if( zExtra ){
      sqlite3DbFree(pAccum->db, zExtra);
      zExtra = 0;
    }
  }/* End for loop over the format string */
} /* End of function */

SQLITE_API void sqlite3_str_reset(StrAccum *p){
  if( isMalloced(p) ){
    sqlite3DbFree(p->db, p->zText);
    p->printfFlags &= ~SQLITE_PRINTF_MALLOCED;
  }
  p->nAlloc = 0;
  p->nChar = 0;
  p->zText = 0;
}

SQLITE_API int sqlite3_str_errcode(sqlite3_str *p){
  return p ? p->accError : SQLITE_NOMEM;
}

SQLITE_API int sqlite3_str_length(sqlite3_str *p){
  return p ? p->nChar : 0;
}

SQLITE_API char *sqlite3_str_value(sqlite3_str *p){
  if( p==0 || p->nChar==0 ) return 0;
  p->zText[p->nChar] = 0;
  return p->zText;
}

SQLITE_API char *sqlite3_mprintf(const char *zFormat, ...){
  va_list ap;
  char *z;
#ifndef SQLITE_OMIT_AUTOINIT
  if( sqlite3_initialize() ) return 0;
#endif
  va_start(ap, zFormat);
  z = sqlite3_vmprintf(zFormat, ap);
  va_end(ap);
  return z;
}

SQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){
  char *z;
  char zBase[SQLITE_PRINT_BUF_SIZE];
  StrAccum acc;

#ifdef SQLITE_ENABLE_API_ARMOR
  if( zFormat==0 ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
#ifndef SQLITE_OMIT_AUTOINIT
  if( sqlite3_initialize() ) return 0;
#endif
  sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);
  sqlite3_str_vappendf(&acc, zFormat, ap);
  z = sqlite3StrAccumFinish(&acc);
  return z;
}

SQLITE_API char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){
  char *z;
  va_list ap;
  va_start(ap,zFormat);
  z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);
  va_end(ap);
  return z;
}

SQLITE_API char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){
  StrAccum acc;
  if( n<=0 ) return zBuf;
#ifdef SQLITE_ENABLE_API_ARMOR
  if( zBuf==0 || zFormat==0 ) {
    (void)SQLITE_MISUSE_BKPT;
    if( zBuf ) zBuf[0] = 0;
    return zBuf;
  }
#endif
  sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);
  sqlite3_str_vappendf(&acc, zFormat, ap);
  zBuf[acc.nChar] = 0;
  return zBuf;
}

SQLITE_API int sqlite3_complete(const char *zSql){
  u8 state = 0;   /* Current state, using numbers defined in header comment */
  u8 token;       /* Value of the next token */

#ifndef SQLITE_OMIT_TRIGGER
  /* A complex statement machine used to detect the end of a CREATE TRIGGER
  ** statement.  This is the normal case.
  */
  static const u8 trans[8][8] = {
                     /* Token:                                                */
     /* State:       **  SEMI  WS  OTHER  EXPLAIN  CREATE  TEMP  TRIGGER  END */
     /* 0 INVALID: */ {    1,  0,     2,       3,      4,    2,       2,   2, },
     /* 1   START: */ {    1,  1,     2,       3,      4,    2,       2,   2, },
     /* 2  NORMAL: */ {    1,  2,     2,       2,      2,    2,       2,   2, },
     /* 3 EXPLAIN: */ {    1,  3,     3,       2,      4,    2,       2,   2, },
     /* 4  CREATE: */ {    1,  4,     2,       2,      2,    4,       5,   2, },
     /* 5 TRIGGER: */ {    6,  5,     5,       5,      5,    5,       5,   5, },
     /* 6    SEMI: */ {    6,  6,     5,       5,      5,    5,       5,   7, },
     /* 7     END: */ {    1,  7,     5,       5,      5,    5,       5,   5, },
  };
#else
  /* If triggers are not supported by this compile then the statement machine
  ** used to detect the end of a statement is much simpler
  */
  static const u8 trans[3][3] = {
                     /* Token:           */
     /* State:       **  SEMI  WS  OTHER */
     /* 0 INVALID: */ {    1,  0,     2, },
     /* 1   START: */ {    1,  1,     2, },
     /* 2  NORMAL: */ {    1,  2,     2, },
  };
#endif /* SQLITE_OMIT_TRIGGER */

#ifdef SQLITE_ENABLE_API_ARMOR
  if( zSql==0 ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif

  while( *zSql ){
    switch( *zSql ){
      case ';': {  /* A semicolon */
        token = tkSEMI;
        break;
      }
      case ' ':
      case '\r':
      case '\t':
      case '\n':
      case '\f': {  /* White space is ignored */
        token = tkWS;
        break;
      }
      case '/': {   /* C-style comments */
        if( zSql[1]!='*' ){
          token = tkOTHER;
          break;
        }
        zSql += 2;
        while( zSql[0] && (zSql[0]!='*' || zSql[1]!='/') ){ zSql++; }
        if( zSql[0]==0 ) return 0;
        zSql++;
        token = tkWS;
        break;
      }
      case '-': {   /* SQL-style comments from "--" to end of line */
        if( zSql[1]!='-' ){
          token = tkOTHER;
          break;
        }
        while( *zSql && *zSql!='\n' ){ zSql++; }
        if( *zSql==0 ) return state==1;
        token = tkWS;
        break;
      }
      case '[': {   /* Microsoft-style identifiers in [...] */
        zSql++;
        while( *zSql && *zSql!=']' ){ zSql++; }
        if( *zSql==0 ) return 0;
        token = tkOTHER;
        break;
      }
      case '`':     /* Grave-accent quoted symbols used by MySQL */
      case '"':     /* single- and double-quoted strings */
      case '\'': {
        int c = *zSql;
        zSql++;
        while( *zSql && *zSql!=c ){ zSql++; }
        if( *zSql==0 ) return 0;
        token = tkOTHER;
        break;
      }
      default: {
#ifdef SQLITE_EBCDIC
        unsigned char c;
#endif
        if( IdChar((u8)*zSql) ){
          /* Keywords and unquoted identifiers */
          int nId;
          for(nId=1; IdChar(zSql[nId]); nId++){}
#ifdef SQLITE_OMIT_TRIGGER
          token = tkOTHER;
#else
          switch( *zSql ){
            case 'c': case 'C': {
              if( nId==6 && sqlite3StrNICmp(zSql, "create", 6)==0 ){
                token = tkCREATE;
              }else{
                token = tkOTHER;
              }
              break;
            }
            case 't': case 'T': {
              if( nId==7 && sqlite3StrNICmp(zSql, "trigger", 7)==0 ){
                token = tkTRIGGER;
              }else if( nId==4 && sqlite3StrNICmp(zSql, "temp", 4)==0 ){
                token = tkTEMP;
              }else if( nId==9 && sqlite3StrNICmp(zSql, "temporary", 9)==0 ){
                token = tkTEMP;
              }else{
                token = tkOTHER;
              }
              break;
            }
            case 'e':  case 'E': {
              if( nId==3 && sqlite3StrNICmp(zSql, "end", 3)==0 ){
                token = tkEND;
              }else
#ifndef SQLITE_OMIT_EXPLAIN
              if( nId==7 && sqlite3StrNICmp(zSql, "explain", 7)==0 ){
                token = tkEXPLAIN;
              }else
#endif
              {
                token = tkOTHER;
              }
              break;
            }
            default: {
              token = tkOTHER;
              break;
            }
          }
#endif /* SQLITE_OMIT_TRIGGER */
          zSql += nId-1;
        }else{
          /* Operators and special symbols */
          token = tkOTHER;
        }
        break;
      }
    }
    state = trans[state][token];
    zSql++;
  }
  return state==1;
}


     
//
// END FILE: sqlite3copy_api.c
// ----------------------------------------------------------------------------



// ----------------------------------------------------------------------------
// BEGIN FILE: sqlite3cloud_api.c
//


//
//  sqlite3cloud_api.c
//  sqlite3cloud_test
//
//  Created by Marco Bambini on 20/10/22.
//

#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <ctype.h>

// (AMALGAMATED) #include "sqlite3cloud_api.h"

#ifndef htonll
#if __BIG_ENDIAN__
#define htonll(x)       (x)
#define ntohll(x)       (x)
#else
#define htonll(x)       htobe64(x)
#define ntohll(x)       be64toh(x)
#endif
#endif

// used in sqlite3_memory API
static sqlite3_int64 memory_used = 0;
static sqlite3_int64 memory_highwater = 0;

// used in sqlite3_keywords API
static SQCloudConnection *gconnection = NULL;
static SQCloudResult *gkeywords = NULL;
static SQCloudResult *gcompileopts = NULL;
static SQCloudResult *gtemp = NULL;

// used in sqlite3_db_filename/sqlite3_db_name API
static char *gfilename = NULL;
static char *gdbname = NULL;

// MARK: Private -

static void rowset_to_values (SQCloudResult *result, char **values, uint32_t row) {
    uint32_t ncols = SQCloudRowsetCols(result);
    uint32_t len = 0;
    
    char *blob_value = NULL;
    uint32_t blob_len = 0;
    
    for (uint32_t i=0; i<ncols; ++i) {
        SQCLOUD_VALUE_TYPE type = SQCloudRowsetValueType(result, row, i);
        char *value = SQCloudRowsetValue(result, row, i, &len);
        values[i] = value;
        
        // check if there is an un-terminated BLOB before processing the next one
        if (blob_value) {
            blob_value[blob_len] = 0;
            blob_value = NULL;
            blob_len = 0;
        }
        
        if ((type == VALUE_INTEGER) || (type == VALUE_FLOAT)) {
            // no-problem to add a zero because there is always a space after the number
            value[len] = 0;
        } else if ((type == VALUE_NULL) || (value == NULL)) {
            values[i] = NULL;
        } else if (type == VALUE_BLOB) {
            // blob can be zero-terminated ONLY after processing the next-one
            blob_value = value;
            blob_len = len;
        } else {
            ; // do nothing if VALUE_TEXT because it is already zero-terminated
        }
        
        // char *value = SQCloudRowsetValue(result, row, i, &len);
        // if (value) value[len] = 0; // strings are NULL-terminated but numbers are NOT
        // values[i] = value;
    }
    
    // check if there is an un-terminated BLOB before exit
    if (blob_value) blob_value[blob_len] = 0;
}

static void rowset_to_names (SQCloudResult *result, char **names) {
    uint32_t ncols = SQCloudRowsetCols(result);
    uint32_t len = 0;
    
    for (uint32_t i=0; i<ncols; ++i) {
        names[i] = SQCloudRowsetColumnName(result, i, &len);
    }
}

static char *vm_memory_check (sqlite3_stmt *vm, sqlite3_uint64 requested_size) {
    sqlite3_uint64 msize = (vm->buffer) ? sqlite3cloud_msize(vm->buffer) : 0;
    if (msize >= requested_size) return vm->buffer;
    
    if (vm->buffer) sqlite3cloud_free(vm->buffer);
    vm->buffer = sqlite3cloud_malloc(requested_size);
    return vm->buffer;
}

static int get_table_callback (void *pArg, int nCol, char **argv, char **colv) {
    TabResult *p = (TabResult*)pArg;  /* Result accumulator */
    int need;                         /* Slots needed in p->azResult[] */
    int i;                            /* Loop counter */
    char *z;                          /* A single column of result */
    
    /* Make sure there is enough space in p->azResult to hold everything
     ** we need to remember from this invocation of the callback.
     */
    if( p->nRow==0 && argv!=0 ){
        need = nCol*2;
    }else{
        need = nCol;
    }
    if( p->nData + need > p->nAlloc ){
        char **azNew;
        p->nAlloc = p->nAlloc*2 + need;
        azNew = sqlite3cloud_realloc( p->azResult, sizeof(char*)*p->nAlloc );
        if(azNew == NULL) goto malloc_failed;
        p->azResult = azNew;
    }
    
    /* If this is the first row, then generate an extra row containing
     ** the names of all columns.
     */
    if( p->nRow==0 ){
        p->nColumn = nCol;
        for(i=0; i<nCol; i++){
            z = sqlite3cloud_strdup(colv[i]);
            if( z==0 ) goto malloc_failed;
            p->azResult[p->nData++] = z;
        }
    }else if( (int)p->nColumn!=nCol ){
        sqlite3_free(p->zErrMsg);
        p->zErrMsg = sqlite3cloud_strdup("sqlite3_get_table() called with two or more incompatible queries");
        p->rc = SQLITE_ERROR;
        return 1;
    }
    
    /* Copy over the row data
     */
    if( argv!=0 ){
        for(i=0; i<nCol; i++){
            if( argv[i]==0 ){
                z = 0;
            }else{
                int n = (int)strlen(argv[i])+1;
                z = sqlite3cloud_malloc (n);
                if (z == 0) goto malloc_failed;
                memcpy(z, argv[i], n);
            }
            p->azResult[p->nData++] = z;
        }
        p->nRow++;
    }
    return 0;
    
malloc_failed:
    p->rc = SQLITE_NOMEM;
    return 1;
}

// MARK: - Database -

int sqlite3cloud_open(const char *filename, sqlite3 **db, int flags) {
    // sqlitecloud://localhost/dbname?sqlite=1
    
    *db = NULL;
    sqlite3 *_db = sqlite3cloud_zeroalloc(sizeof(sqlite3));
    if (!_db) return SQLITE_NOMEM;
    
    SQCloudConfig config = {0};
    config.sqlite_mode = true;
    if (flags & SQLITE_OPEN_CREATE) config.db_create = true;
    if (flags & SQLITE_OPEN_MEMORY) config.db_memory = true;
    
    SQCloudConnection *connection = SQCloudConnectWithString(filename, &config);
    if (!connection) {
        sqlite3cloud_free(_db);
        return SQLITE_CANTOPEN;
    }
    
    _db->connection = connection;
    *db = _db;
    
    if (SQCloudIsError(connection)) return SQLITE_ERROR;
    
    // we need a shared connection to use the keywords related API
    if (gconnection == NULL) gconnection = connection;
    
    return SQLITE_OK;
}

int sqlite3cloud_close(sqlite3 *db) {
    if (!db) return SQLITE_OK;
    
    if (db->traceFlags & SQLITE_TRACE_CLOSE) {
        db->trace(SQLITE_TRACE_CLOSE, db->traceData, db, 0);
    }
    
    // check if global shared connection must be reset
    if (gconnection == db->connection) gconnection = NULL;
    
    SQCloudDisconnect(db->connection);
    sqlite3cloud_free(db);
    
    return SQLITE_OK;
}

int sqlite3cloud_exec(
  sqlite3 *db,                /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  sqlite3_callback xCallback, /* Invoke this callback routine */
  void *pArg,                 /* First argument to xCallback() */
  char **pzErrMsg             /* Write error messages here */
) {
    int rc = SQLITE_OK;
    const char *tail;
    sqlite3_stmt *stmt = NULL;
    char **names = NULL;
    int callbackIsInit;
    
    SQCloudErrorReset(db->connection);
    if (zSql == NULL) return SQLITE_OK;
    
    if (xCallback == NULL) {
        // the no callback case can be optimized
        SQCloudResult *result = SQCloudExec(db->connection, zSql);
        if (SQCloudResultIsError(result)) rc = SQCloudErrorCode(db->connection);
        SQCloudResultFree(result);
        return rc;
    }
    
    while (rc == SQLITE_OK && zSql[0]) {
        int ncols = 0;
        char **values = NULL;
        stmt = NULL;
        
        rc = sqlite3_prepare_v2(db, zSql, -1, &stmt, &tail);
        if (rc != SQLITE_OK) continue;
        
        // this happens for a comment or white-space
        if (!stmt) {zSql = tail; continue;}
        
        callbackIsInit = 0;
        while (1) {
            rc = sqlite3_step(stmt);
            
            SQCloudResult *result = SQCloudVMResult(stmt->vm);
            if (xCallback && SQCloudResultType(result) == RESULT_ROWSET) {
                if (!callbackIsInit) {
                    ncols = (int)SQCloudRowsetCols(result);
                    names = (char **)sqlite3cloud_zeroalloc((2*ncols+1) * sizeof(char *));
                    rc = SQLITE_NOMEM;
                    if (!names) goto abort_exec;
                    rowset_to_names(result, names);
                    callbackIsInit = 1;
                }
                
                values = &names[ncols];
                uint32_t nrows = SQCloudRowsetRows(result);
                for (uint32_t i=0; i<nrows; ++i) {
                    rowset_to_values(result, values, i);
                    values[ncols] = 0;
                    
                    // if callback returns a non-zero value then abort
                    if (xCallback(pArg, ncols, values, names)) {
                        rc = SQLITE_ABORT;
                        sqlite3_finalize(stmt);
                        stmt = NULL;
                        goto abort_exec;
                    }
                }
                rc = SQLITE_DONE;
            }
            
            if (rc != SQLITE_ROW) {
                rc = sqlite3_finalize(stmt);
                stmt = NULL;
                zSql = tail;
                while (isspace(zSql[0])) zSql++;
                break;
            }
        }
        
        if (names) sqlite3cloud_free(names);
        names = NULL;
    }
    
abort_exec:
    if (stmt) sqlite3_finalize(stmt);
    if (names) sqlite3cloud_free(names);
    if (rc != SQLITE_OK && pzErrMsg) {
        char *s = (rc == SQLITE_ABORT) ? "query aborted" : (char *)SQCloudErrorMsg(db->connection);
        *pzErrMsg = sqlite3cloud_strdup(s);
    } else if (pzErrMsg) {
        *pzErrMsg = NULL;
    }
    
    return rc;
}

int sqlite3cloud_gettable(
  sqlite3 *db,                /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  char ***pazResult,          /* Write the result table here */
  int *pnRow,                 /* Write the number of rows in the result here */
  int *pnColumn,              /* Write the number of columns of result here */
  char **pzErrMsg             /* Write error messages here */
) {
    int rc;
    TabResult res;
    
    *pazResult = 0;
    if (pnColumn) *pnColumn = 0;
    if (pnRow) *pnRow = 0;
    if (pzErrMsg) *pzErrMsg = 0;
    res.zErrMsg = 0;
    res.nRow = 0;
    res.nColumn = 0;
    res.nData = 1;
    res.nAlloc = 20;
    res.rc = SQLITE_OK;
    
    res.azResult = sqlite3cloud_malloc(sizeof(char*)*res.nAlloc);
    if(res.azResult == 0) {
        SQCloudErrorSetCode(db->connection, SQLITE_NOMEM);
        return SQLITE_NOMEM;
    }
    res.azResult[0] = 0;
    
    rc = sqlite3_exec(db, zSql, get_table_callback, &res, pzErrMsg);
    res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
    
    if ((rc & 0xff) == SQLITE_ABORT) {
        sqlite3_free_table(&res.azResult[1]);
        if (res.zErrMsg) {
            if (pzErrMsg) {
                sqlite3_free(*pzErrMsg);
                *pzErrMsg = sqlite3cloud_strdup(res.zErrMsg);
            }
            sqlite3_free(res.zErrMsg);
        }
        SQCloudErrorSetCode(db->connection, res.rc);
        return res.rc;
    }
    sqlite3_free(res.zErrMsg);
    
    if (rc != SQLITE_OK) {
        sqlite3_free_table(&res.azResult[1]);
        return rc;
    }
    
    if (res.nAlloc > res.nData) {
        char **azNew;
        azNew = sqlite3cloud_realloc(res.azResult, sizeof(char*)*res.nData);
        if(azNew == 0) {
            sqlite3_free_table(&res.azResult[1]);
            SQCloudErrorSetCode(db->connection, SQLITE_NOMEM);
            return SQLITE_NOMEM;
        }
        res.azResult = azNew;
    }
    
    *pazResult = &res.azResult[1];
    if (pnColumn) *pnColumn = res.nColumn;
    if (pnRow) *pnRow = res.nRow;
    
    return rc;
}

void sqlite3cloud_freetable(char **azResult) {
    if (azResult) {
        --azResult;
        int n = SQLITE_PTR_TO_INT(azResult[0]);
        for (int i=1; i<n; i++) {
            if (azResult[i]) sqlite3cloud_free(azResult[i]);
        }
        sqlite3cloud_free(azResult);
    }
}

int sqlite3cloud_table_column_metadata(
  sqlite3 *db,                /* Connection handle */
  const char *zDbName,        /* Database name or NULL */
  const char *zTableName,     /* Table name */
  const char *zColumnName,    /* Column name */
  char const **pzDataType,    /* OUTPUT: Declared data type */
  char const **pzCollSeq,     /* OUTPUT: Collation sequence name */
  int *pNotNull,              /* OUTPUT: True if NOT NULL constraint exists */
  int *pPrimaryKey,           /* OUTPUT: True if column part of PK */
  int *pAutoinc               /* OUTPUT: True if column is auto-increment */
) {
    // https://www.sqlite.org/c3ref/table_column_metadata.html
    
    // LIST METADATA [<database_name>] TABLE <table_name> [COLUMN <column_name>]
    if (!zDbName) zDbName = "main";
    char command[512];
    
    int n = 3;
    if (zColumnName) snprintf(command, sizeof(command), "LIST METADATA ? TABLE ? COLUMN ?");
    else {snprintf(command, sizeof(command), "LIST METADATA ? TABLE ?"); --n;}
    
    const char *values[3] = {zDbName, zTableName, zColumnName};
    uint32_t len[3] = {(uint32_t)strlen(zDbName), (uint32_t)strlen(zTableName), (zColumnName) ? (uint32_t)strlen(zColumnName) : 0};
    SQCLOUD_VALUE_TYPE types[3] = {VALUE_TEXT, VALUE_TEXT, VALUE_TEXT};
    
    int rc = SQLITE_OK;
    SQCloudResult *result = SQCloudExecArray(db->connection, command, values, len, types, n);
    if ((SQCloudResultType(result) != RESULT_ARRAY) || (SQCloudArrayInt32Value(result, 0) != ARRAY_TYPE_METADATA)) {
        rc = SQCloudErrorCode(db->connection);
        SQCloudResultFree(result);
        return rc;
    }
    
    // decode array
    uint32_t vlen = 0;
    if (pzDataType) *pzDataType = SQCloudArrayValue(result, 1, &vlen);
    if (pzCollSeq) *pzCollSeq = SQCloudArrayValue(result, 2, &vlen);
    if (pNotNull) *pNotNull = (int)SQCloudArrayInt32Value(result, 3);
    if (pPrimaryKey) *pPrimaryKey = (int)SQCloudArrayInt32Value(result, 4);
    if (pAutoinc) *pAutoinc = (int)SQCloudArrayInt32Value(result, 5);
    
    // save temporary buffer
    if (gtemp) SQCloudResultFree(gtemp);
    gtemp = result;
    
    return SQLITE_OK;
}

sqlite3_int64 sqlite3cloud_lastrowid(sqlite3 *db) {
    return db->lastrowid;
}

void sqlite3cloud_setlastrowid(sqlite3 *db, sqlite3_int64 iRowid) {
    // sqlite3_setlastrowid does not modify the database
    db->lastrowid = iRowid;
}

sqlite3_int64 sqlite3cloud_changes(sqlite3 *db) {
    return db->changes;
}

sqlite3_int64 sqlite3cloud_totalchanges(sqlite3 *db) {
    return db->totalchanges;
}

void sqlite3cloud_interrupt(sqlite3 *db) {
    // We could interrupt the socket read operation but I am not sure it worths
    return;
}

int sqlite3cloud_is_interrupted(sqlite3 *db) {
    return 1;
}

int sqlite3cloud_errcode(sqlite3 *db) {
    SQCloudConnection *connection = db->connection;
    return SQCloudErrorCode(connection);
}

int sqlite3cloud_extended_errcode(sqlite3 *db) {
    SQCloudConnection *connection = db->connection;
    return SQCloudExtendedErrorCode(connection);
}

int sqlite3cloud_error_offset(sqlite3 *db){
    SQCloudConnection *connection = db->connection;
    return SQCloudErrorOffset(connection);
}

const char *sqlite3cloud_errmsg(sqlite3 *db) {
    SQCloudConnection *connection = db->connection;
    const char *err = SQCloudErrorMsg(connection);
    #if SQLITE3CLOUD_ERRSTR_DEFINED
    if (err[0] == 0) return sqlite3_errstr(SQCloudErrorCode(connection));
    #endif
    return err;
}

int sqlite3cloud_limit(sqlite3 *db, int limitId, int newLimit) {
    char sql[512];
    
    if (newLimit < 0) snprintf(sql, sizeof(sql), "DATABASE LIMIT %d;", limitId);
    else snprintf(sql, sizeof(sql), "DATABASE LIMIT %d VALUE %d;", limitId, newLimit);
        
    int rc = 0;
    SQCloudResult *result = SQCloudExec(db->connection, sql);
    if (SQCloudResultType(result) == RESULT_INTEGER) rc = SQCloudResultInt32(result);
    
    SQCloudResultFree(result);
    return rc;
}

const char *sqlite3cloud_db_filename(sqlite3 *db, const char *zDbName) {
    const char *command = "DATABASE FILENAME ?";
    const char *values[] = {zDbName};
    uint32_t len[] = {(uint32_t)strlen(zDbName)};
    SQCLOUD_VALUE_TYPE types[] = {VALUE_TEXT};
    
    SQCloudResult *result = SQCloudExecArray(db->connection, command, values, len, types, 1);
    bool is_string = (SQCloudResultType(result) == RESULT_STRING);
    if (is_string) {
        if (gfilename) sqlite3cloud_free(gfilename);
        
        uint32_t len = SQCloudResultLen(result);
        char *value = SQCloudResultBuffer(result);
        
        gfilename = sqlite3cloud_strndup(value, (size_t)len);
    }
    
    SQCloudResultFree(result);
    return (is_string) ? gfilename : NULL;
}

const char *sqlite3cloud_db_name(sqlite3 *db, int N) {
    char command[1024];
    snprintf(command, sizeof(command), "DATABASE NAME %d", N);
    
    SQCloudResult *result = SQCloudExec(db->connection, command);
    bool is_string = (SQCloudResultType(result) == RESULT_STRING);
    if (is_string) {
        if (gdbname) sqlite3cloud_free(gdbname);
        
        uint32_t len = SQCloudResultLen(result);
        char *value = SQCloudResultBuffer(result);
        
        gdbname = sqlite3cloud_strndup(value, (size_t)len);
    }
    
    SQCloudResultFree(result);
    return (is_string) ? gdbname : NULL;
}

int sqlite3cloud_db_readonly(sqlite3 *db, const char *zDbName) {
    const char *command = "DATABASE READONLY ?";
    const char *values[] = {zDbName};
    uint32_t len[] = {(uint32_t)strlen(zDbName)};
    SQCLOUD_VALUE_TYPE types[] = {VALUE_TEXT};
    
    int rc = 0;
    SQCloudResult *result = SQCloudExecArray(db->connection, command, values, len, types, 1);
    if (SQCloudResultType(result) == RESULT_INTEGER) rc = (int)SQCloudResultInt32(result);
    
    SQCloudResultFree(result);
    return rc;
}

int sqlite3cloud_db_status(sqlite3 *db, int op, int *pCur, int *pHiwtr, int resetFlag) {
    char command[1024];
    snprintf(command, sizeof(command), "DATABASE STATUS %d RESET %d", op, resetFlag);
    
    int rc = SQLITE_OK;
    SQCloudResult *result = SQCloudExec(db->connection, command);
    if (SQCloudResultType(result) == RESULT_ARRAY && SQCloudArrayInt32Value(result, 0) == ARRAY_TYPE_DB_STATUS) {
        if (*pCur) *pCur = (int)SQCloudArrayInt32Value(result, 1);
        if (*pHiwtr) *pHiwtr = (int)SQCloudArrayInt32Value(result, 2);
    } else {
        rc = SQCloudErrorCode(db->connection);
    }
    
    SQCloudResultFree(result);
    return rc;
}

int sqlite3cloud_db_cacheflush(sqlite3 *db) {
    int rc = SQLITE_OK;
    SQCloudResult *result = SQCloudExec(db->connection, "DATABASE CACHEFLUSH");
    if (SQCloudResultIsError(result)) rc = SQCloudErrorCode(db->connection);
    
    SQCloudResultFree(result);
    return rc;
}

int sqlite3cloud_system_errno(sqlite3 *db) {
    int rc = 0;
    SQCloudResult *result = SQCloudExec(db->connection, "DATABASE ERRNO");
    if (SQCloudResultType(result) == RESULT_INTEGER) rc = (int)SQCloudResultInt32(result);
    
    SQCloudResultFree(result);
    return rc;
}

int sqlite3cloud_txn_state(sqlite3 *db, const char *zSchema) {
    SQCloudResult *result = NULL;
    int rc = -1;
    
    if (zSchema) {
        const char *command = "DATABASE TXNSTATE ?";
        const char *values[] = {zSchema};
        uint32_t len[] = {(uint32_t)strlen(zSchema)};
        SQCLOUD_VALUE_TYPE types[] = {VALUE_TEXT};
        result = SQCloudExecArray(db->connection, command, values, len, types, 1);
    } else {
        result = SQCloudExec(db->connection, "DATABASE TXNSTATE");
    }
        
    if (SQCloudResultType(result) == RESULT_INTEGER) rc = (int)SQCloudResultInt32(result);
    
    SQCloudResultFree(result);
    return rc;
}

// MARK: - Virtual Machine -

int sqlite3cloud_prepare(
    sqlite3 *db,              /* Database handle. */
    const char *zSql,         /* UTF-8 encoded SQL statement. */
    int nBytes,               /* Length of zSql in bytes. */
    unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */
    sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
    const char **pzTail       /* OUT: End of parsed string */
) {
    // perform command
    SQCloudVM *vm = SQCloudVMCompile(db->connection, zSql, nBytes, pzTail);
    if (!vm) {
        // compiling a comment returns NO error and a NULL vm
        if (SQCloudErrorCode(db->connection) == INTERNAL_ERRCODE_NONE) return SQLITE_OK;
        return SQLITE_ERROR;
    }
    
    // allocate vm struct
    sqlite3_stmt *stmt = (sqlite3_stmt *)sqlite3cloud_zeroalloc(sizeof(sqlite3_stmt));
    if (!stmt) return SQLITE_NOMEM;
    
    stmt->db = db;
    stmt->vm = vm;
    
    // check for error
    /*
    if (SQCloudResultIsError(result)) {
        vm->finalized = 1;
        return SQCloudErrorCode(db->connection);
    }
     */
  
    *ppStmt = stmt;
    return SQLITE_OK;
}

int sqlite3cloud_step(sqlite3_stmt *pStmt) {
    SQCloudVM *vm = pStmt->vm;
    SQCLOUD_RESULT_TYPE rc = SQCloudVMStep(vm);
    if (rc == RESULT_ROWSET) return SQLITE_ROW;
    if (rc == RESULT_NULL) return SQLITE_DONE;
    if (rc == RESULT_OK) {
        // update database too
        pStmt->db->lastrowid = (sqlite3_int64)SQCloudVMLastRowID(vm);
        pStmt->db->changes = (sqlite3_int64)SQCloudVMChanges(vm);
        pStmt->db->totalchanges = (sqlite3_int64)SQCloudVMTotalChanges(vm);
        return SQLITE_DONE;
    }
    return SQCloudVMErrorCode(vm);
}

int sqlite3cloud_stmt_readonly(sqlite3_stmt *pStmt) {
    return SQCloudVMIsReadOnly(pStmt->vm);
}

int sqlite3cloud_stmt_isexplain(sqlite3_stmt *pStmt) {
    return SQCloudVMIsExplain(pStmt->vm);
}

int sqlite3cloud_stmt_busy(sqlite3_stmt *pStmt) {
    // must be always 0
    return 0;
}

int sqlite3cloud_bind_double(sqlite3_stmt *pStmt, int i, double rValue) {
    if (SQCloudVMBindDouble(pStmt->vm, i, rValue) == true) return SQLITE_OK;
    return SQCloudVMErrorCode(pStmt->vm);
}

int sqlite3cloud_bind_int(sqlite3_stmt *pStmt, int i, int iValue) {
    if (SQCloudVMBindInt(pStmt->vm, i, iValue) == true) return SQLITE_OK;
    return SQCloudVMErrorCode(pStmt->vm);
}

int sqlite3cloud_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue) {
    if (SQCloudVMBindInt64(pStmt->vm, i, iValue) == true) return SQLITE_OK;
    return SQCloudVMErrorCode(pStmt->vm);
}

int sqlite3cloud_bind_null(sqlite3_stmt *pStmt, int i) {
    if (SQCloudVMBindNull(pStmt->vm, i) == true) return SQLITE_OK;
    return SQCloudVMErrorCode(pStmt->vm);
}

int sqlite3cloud_bind_blob(
                             sqlite3_stmt *pStmt,
                             int i,
                             const void *zData,
                             sqlite3_uint64 nData,
                             void (*xDel)(void*)
                           ) {
    if (SQCloudVMBindBlob(pStmt->vm, i, (void *)zData, (int32_t)nData) == true) return SQLITE_OK;
    return SQCloudVMErrorCode(pStmt->vm);
}

int sqlite3cloud_bind_text(
  sqlite3_stmt *pStmt,
  int i,
  const char *zData,
  sqlite3_uint64 nData,
  void (*xDel)(void*),
  unsigned char enc
) {
    if (SQCloudVMBindText(pStmt->vm, i, zData, (int32_t)nData) == true) return SQLITE_OK;
    return SQCloudVMErrorCode(pStmt->vm);
}

int sqlite3cloud_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue) {
    switch (pValue->tag) {
        case 0: return sqlite3cloud_bind_int(pStmt, i, (int)pValue->ivalue);
        case 1: return sqlite3cloud_bind_int64(pStmt, i, pValue->ivalue);
        case 2: return sqlite3cloud_bind_double(pStmt, i, pValue->dvalue);
        case 3: return sqlite3cloud_bind_text(pStmt, i, (const char *)pValue->ptrvalue, pValue->len, NULL, 0);
        case 4: return sqlite3cloud_bind_blob(pStmt, i, (const void *)pValue->ptrvalue, pValue->len, NULL);
        case 5: return sqlite3cloud_bind_null(pStmt, i);
    }
    return SQLITE_MISUSE;
}

int sqlite3cloud_bind_pointer(
  sqlite3_stmt *pStmt,
  int i,
  void *pPtr,
  const char *zPTtype,
  void (*xDestructor)(void*)
) {
    return 0;
}

int sqlite3cloud_bind_zeroblob(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n) {
    if (SQCloudVMBindZeroBlob(pStmt->vm, i, (int64_t)n) == true) return SQLITE_OK;
    return SQCloudVMErrorCode(pStmt->vm);
}

int sqlite3cloud_bind_parameter_count(sqlite3_stmt *pStmt) {
    return SQCloudVMBindParameterCount(pStmt->vm);
}

const char *sqlite3cloud_bind_parameter_name(sqlite3_stmt *pStmt, int i) {
    char command[512];
    snprintf(command, sizeof(command), "VM PARAMETER %d NAME %d", SQCloudVMIndex(pStmt->vm), i);
    
    const char *value = NULL;
    SQCloudResult *result = SQCloudExec(pStmt->db->connection, command);
    if (SQCloudResultType(result) == RESULT_STRING) {
        uint32_t len = SQCloudResultLen(result);
        if (len > 0) value = sqlite3cloud_strndup(SQCloudResultBuffer(result), len);
    }
    SQCloudResultFree(result);
    
    // TODO: what about value memory?
    return value;
}

int sqlite3cloud_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName) {
    char command[512];
    snprintf(command, sizeof(command), "VM PARAMETER %d INDEX ?", SQCloudVMIndex(pStmt->vm));
    
    const char *values[] = {zName};
    uint32_t len[] = {(uint32_t)strlen(zName)};
    SQCLOUD_VALUE_TYPE types[] = {VALUE_TEXT};
    
    int value = 0;
    SQCloudResult *result = SQCloudExecArray(pStmt->db->connection, command, values, len, types, 1);
    if (SQCloudResultType(result) == RESULT_INTEGER) {
        value = (int)SQCloudResultInt32(result);
    }
    
    SQCloudResultFree(result);
    return value;
}

int sqlite3cloud_column_count(sqlite3_stmt *pStmt) {
    return SQCloudVMColumnCount(pStmt->vm);
}

const char *sqlite3cloud_column_name(sqlite3_stmt *pStmt, int N) {
    SQCloudResult *result = SQCloudVMResult(pStmt->vm);
    if (SQCloudResultType(result) != RESULT_ROWSET) return NULL;
    
    uint32_t len = 0;
    return SQCloudRowsetColumnName(result, (uint32_t)N, &len);
}

const char *sqlite3cloud_column_database_name(sqlite3_stmt *pStmt, int N) {
    SQCloudResult *result = SQCloudVMResult(pStmt->vm);
    if (SQCloudResultType(result) != RESULT_ROWSET) return NULL;
    
    uint32_t len = 0;
    return SQCloudRowsetColumnDBName(result, (uint32_t)N, &len);
}

const char *sqlite3cloud_column_table_name(sqlite3_stmt *pStmt, int N) {
    SQCloudResult *result = SQCloudVMResult(pStmt->vm);
    if (SQCloudResultType(result) != RESULT_ROWSET) return NULL;
    
    uint32_t len = 0;
    return SQCloudRowsetColumnTblName(result, (uint32_t)N, &len);
}

const char *sqlite3cloud_column_origin_name(sqlite3_stmt *pStmt, int N) {
    SQCloudResult *result = SQCloudVMResult(pStmt->vm);
    if (SQCloudResultType(result) != RESULT_ROWSET) return NULL;
    
    uint32_t len = 0;
    return SQCloudRowsetColumnOrigName(result, (uint32_t)N, &len);
}

const char *sqlite3cloud_column_decltype(sqlite3_stmt *pStmt, int N) {
    SQCloudResult *result = SQCloudVMResult(pStmt->vm);
    if (SQCloudResultType(result) != RESULT_ROWSET) return NULL;
    
    uint32_t len = 0;
    return SQCloudRowsetColumnDeclType(result, (uint32_t)N, &len);
}

int sqlite3cloud_data_count(sqlite3_stmt *pStmt) {
    if (pStmt == NULL) return 0;
    
    SQCloudResult *result = SQCloudVMResult(pStmt->vm);
    if (SQCloudResultType(result) != RESULT_ROWSET) return 0;
    
    return sqlite3cloud_column_count(pStmt);
}

const void *sqlite3cloud_column_blob(sqlite3_stmt *pStmt, int i) {
    uint32_t len = 0;
    const void *value = (const void *) SQCloudVMColumnBlob(pStmt->vm, i, &len);
    return value;
}

double sqlite3cloud_column_double(sqlite3_stmt *pStmt, int i) {
    SQCLOUD_VALUE_TYPE type = SQCloudVMColumnType(pStmt->vm, i);
    if ((type == VALUE_TEXT) || (type == VALUE_BLOB)) {
        // https://www.sqlite.org/lang_expr.html#castexpr TO DOUBLE
    }
    return SQCloudVMColumnDouble(pStmt->vm, i);
}

int sqlite3cloud_column_int(sqlite3_stmt *pStmt, int i) {
    SQCLOUD_VALUE_TYPE type = SQCloudVMColumnType(pStmt->vm, i);
    if ((type == VALUE_TEXT) || (type == VALUE_BLOB)) {
        // https://www.sqlite.org/lang_expr.html#castexpr TO INT
    }
    return (int)SQCloudVMColumnInt32(pStmt->vm, i);
}

sqlite3_int64 sqlite3cloud_column_int64(sqlite3_stmt *pStmt, int i) {
    SQCLOUD_VALUE_TYPE type = SQCloudVMColumnType(pStmt->vm, i);
    if ((type == VALUE_TEXT) || (type == VALUE_BLOB)) {
        // https://www.sqlite.org/lang_expr.html#castexpr TO INT64
    }
    return (sqlite3_int64)SQCloudVMColumnInt64(pStmt->vm, i);
}

const unsigned char *sqlite3cloud_column_text(sqlite3_stmt *pStmt, int i) {
    // this function must return a zero-terminated string
    SQCLOUD_VALUE_TYPE type = SQCloudVMColumnType(pStmt->vm, i);
    if (type == VALUE_NULL) return NULL;
    
    uint32_t len = 0;
    char *value = (char *)SQCloudVMColumnText(pStmt->vm, i, &len);
    
    switch (type) {
        case VALUE_NULL:
            return NULL;
            
        case VALUE_TEXT:
            // I am sure to be in SQLITE mode so VALUE_TEXT is already zero-terminated
            return (const unsigned char *)value;
            
        case VALUE_INTEGER:
        case VALUE_FLOAT: {
            if (len > sizeof(pStmt->sbuffer)) return NULL;
            memcpy(pStmt->sbuffer, value, len);
            pStmt->sbuffer[len] = 0;
            return (const unsigned char *)pStmt->sbuffer;
        }
            
        case VALUE_BLOB: {
            // according to the conversion table reported in https://www.sqlite.org/c3ref/column_blob.html
            // BLOB -> TEXT: CAST to TEXT, ensure zero terminator
            char *buffer = vm_memory_check(pStmt, len + 1);
            if (!buffer) return NULL;
            
            memcpy(buffer, value, len);
            buffer[len] = 0;
            return (const unsigned char *)buffer;
        }
    }
    
    // SHOULD NEVER REACH THIS POINT
    return NULL;
}

sqlite3_value *sqlite3cloud_column_value(sqlite3_stmt *pStmt, int i) {
    sqlite3_value *value = (sqlite3_value *)sqlite3cloud_zeroalloc(sizeof(sqlite3_value));
    if (!value) return NULL;
    
    SQCLOUD_VALUE_TYPE type = SQCloudVMColumnType(pStmt->vm, i);
    value->tag = (int)type;
    value->len = (int)SQCloudVMColumnLen(pStmt->vm, i);
    
    switch(type) {
        case VALUE_INTEGER:
            value->ivalue = SQCloudVMColumnInt64(pStmt->vm, i);
            break;
            
        case VALUE_FLOAT:
            value->dvalue = SQCloudVMColumnDouble(pStmt->vm, i);
            break;
            
        case VALUE_TEXT:
        case VALUE_BLOB: {
            uint32_t len = 0;
            value->ptrvalue = SQCloudVMColumnText(pStmt->vm, i, &len);
        }
            break;
            
        case VALUE_NULL:
            break;
    }
    
    return value;
}

int sqlite3cloud_column_bytes(sqlite3_stmt *pStmt, int i) {
    return (int)SQCloudVMColumnLen(pStmt->vm, i);
}

int sqlite3cloud_column_type(sqlite3_stmt *pStmt, int i) {
    // SQCLOUD_VALUE_TYPE enum is equal to SQLITE_TYPE values
    return (int)SQCloudVMColumnType(pStmt->vm, i);
}

int sqlite3cloud_clear_bindings(sqlite3_stmt *pStmt) {
    char command[512];
    snprintf(command, sizeof(command), "VM CLEAR %d", SQCloudVMIndex(pStmt->vm));
    
    int rc = SQLITE_OK;
    SQCloudResult *result = SQCloudExec(pStmt->db->connection, command);
    if (SQCloudResultIsError(result)) rc = SQCloudErrorCode(pStmt->db->connection);
    
    // force a refresh for sqlite3_sql/sqlite3_expanded_sql/sqlite3_normalized_sql APIs
    SQCloudResultFree(pStmt->sql);
    pStmt->sql = NULL;
    
    SQCloudResultFree(result);
    return rc;
}

int sqlite3cloud_finalize(sqlite3_stmt *pStmt) {
    SQCloudVMClose(pStmt->vm);
    if (pStmt->sql) SQCloudResultFree(pStmt->sql);
    if (pStmt->buffer) sqlite3cloud_free(pStmt->buffer);
    sqlite3cloud_free(pStmt);
    return SQLITE_OK;
}

int sqlite3cloud_reset(sqlite3_stmt *pStmt) {
    char command[512];
    snprintf(command, sizeof(command), "VM RESET %d", SQCloudVMIndex(pStmt->vm));
    
    int rc = SQLITE_OK;
    SQCloudResult *result = SQCloudExec(pStmt->db->connection, command);
    if (SQCloudResultIsError(result)) rc = SQCloudErrorCode(pStmt->db->connection);
    
    // force a refresh for sqlite3_sql/sqlite3_expanded_sql/sqlite3_normalized_sql APIs
    SQCloudResultFree(pStmt->sql);
    pStmt->sql = NULL;
    
    SQCloudResultFree(result);
    return rc;
}

int sqlite3cloud_retrieve_sql(sqlite3_stmt *pStmt) {
    if (pStmt->sql) return SQLITE_OK;
    
    char command[512];
    snprintf(command, sizeof(command), "VM SQL %d", SQCloudVMIndex(pStmt->vm));
    
    int rc = SQLITE_OK;
    SQCloudResult *result = SQCloudExec(pStmt->db->connection, command);
    if (SQCloudResultIsError(result)) rc = SQCloudErrorCode(pStmt->db->connection);
    else if ((SQCloudResultType(result) == RESULT_ARRAY) && (SQCloudArrayInt32Value(result, 0) == ARRAY_TYPE_VM_SQL)) {
        pStmt->sql = result;
    }
    return rc;
}

sqlite3_stmt *sqlite3cloud_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt) {
    return NULL;
}

int sqlite3cloud_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag) {
    return 0;
}

int sqlite3cloud_stmt_scanstatus(
  sqlite3_stmt *pStmt,            /* Prepared statement being queried */
  int idx,                        /* Index of loop to report on */
  int iScanStatusOp,              /* Which metric to return */
  int flags,                      /* Mask of flags defined below */
  void *pOut                      /* OUT: Write the answer here */
) {
    return 0;
}

void sqlite3cloud_stmt_scanstatus_reset(sqlite3_stmt *pStmt) {
    return;
}

// MARK: - BLOB -

int sqlite3cloud_blob_open(
  sqlite3* db,            /* The database connection */
  const char *zDb,        /* The attached database containing the blob */
  const char *zTable,     /* The table containing the blob */
  const char *zColumn,    /* The column containing the blob */
  sqlite_int64 iRow,      /* The row containing the glob */
  int wrFlag,             /* True -> read/write access, false -> read-only */
  sqlite3_blob **ppBlob   /* Handle for accessing the blob returned here */
) {
    // perform command
    SQCloudBlob *blob = SQCloudBlobOpen(db->connection, zDb, zTable, zColumn, (int64_t)iRow, (bool)wrFlag);
    if (!blob) return SQLITE_ERROR;
    
    // allocate blob struct
    sqlite3_blob *pBlob = (sqlite3_blob *)sqlite3cloud_zeroalloc(sizeof(sqlite3_blob));
    if (!pBlob) return SQLITE_NOMEM;
    
    pBlob->db = db;
    pBlob->blob = blob;
    *ppBlob = pBlob;
    
    return SQLITE_OK;
}

int sqlite3cloud_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow) {
    bool result = SQCloudBlobReOpen(pBlob->blob, (int64_t)iRow);
    return (result) ? SQLITE_OK : SQLITE_ERROR;
}

int sqlite3cloud_blob_close(sqlite3_blob *pBlob) {
    bool result = SQCloudBlobClose(pBlob->blob);
    return (result) ? SQLITE_OK : SQLITE_ERROR;
}

int sqlite3cloud_blob_bytes(sqlite3_blob *pBlob) {
    return SQCloudBlobBytes(pBlob->blob);
}

int sqlite3cloud_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset) {
    int nread = SQCloudBlobRead(pBlob->blob, z, n, iOffset);
    return (nread == -1) ? SQCloudErrorCode(pBlob->db->connection) : SQLITE_OK;
}

int sqlite3cloud_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset) {
    int nwrote = SQCloudBlobWrite(pBlob->blob, z, n, iOffset);
    return (nwrote == -1) ? SQCloudErrorCode(pBlob->db->connection) : SQLITE_OK;
}

// MARK: - Backup -

sqlite3_backup *sqlite3cloud_backup_init(
  sqlite3* pDestDb,                     /* Database to write to */
  const char *zDestDb,                  /* Name of database within pDestDb */
  sqlite3* pSrcDb,                      /* Database connection to read from */
  const char *zSrcDb                    /* Name of database within pSrcDb */
) {
    // perform command
    SQCloudBackup *backup = SQCloudBackupInit(pSrcDb->connection, zDestDb, zSrcDb);
    if (!backup) return NULL;
    
    // allocate backup struct
    sqlite3_backup *pBackup = (sqlite3_backup *)sqlite3cloud_zeroalloc(sizeof(sqlite3_backup));
    if (!pBackup) {
        SQCloudBackupFinish(backup);
        return NULL;
    }
    
    pBackup->db = pSrcDb;
    pBackup->backup = backup;
    
    // create output file
    const char *output_path = (const char *)pDestDb;
    remove(output_path);
    FILE *dest = fopen(output_path, "wb");
    if (!dest) {
        SQCloudBackupFinish(backup);
        return NULL;
    }
    
    SQCloudBackupSetData(backup, (void *)dest);
    return pBackup;
}

int64_t sqlite3cloud_backup_ondata (SQCloudBackup *backup, const char *data, uint32_t len, int page_size, int page_counter) {
    // len is (backup->counter * sizeof(int64_t)) + (backup->counter * backup->page_size)
    FILE *dest = (FILE *)SQCloudBackupData(backup);
    if (!dest) {
        SQCloudErrorSetMsg(SQCloudBackupConnection(backup), "Unable to retrieve FILE destination ptr.");
        SQCloudErrorSetCode(SQCloudBackupConnection(backup), SQLITE_IOERR);
        return -1;
    }
    
    for (int i=0; i<page_counter; ++i) {
        int64_t offset;
        memcpy(&offset, data, sizeof(int64_t));
        offset = ntohll(offset);
        data += sizeof(int64_t);
        
        int rc = fseek(dest, (long)offset, SEEK_SET);
        if (rc != 0) {
            SQCloudErrorSetMsg(SQCloudBackupConnection(backup), "ERR: fseek in sqlite3cloud_backup_ondata (%s)\n", strerror(errno));
            SQCloudErrorSetCode(SQCloudBackupConnection(backup), SQLITE_IOERR);
            return -1;
        }
        
        size_t nwrote = fwrite(data, (size_t)page_size, 1, dest);
        if (nwrote != 1) {
            SQCloudErrorSetMsg(SQCloudBackupConnection(backup), "ERR: fwrite in sqlite3cloud_backup_ondata (%s)\n", strerror(errno));
            SQCloudErrorSetCode(SQCloudBackupConnection(backup), SQLITE_IOERR);
            return -1;
        }
        
        data += page_size;
    }
    
    return (page_counter * page_size);
}

int sqlite3cloud_backup_step(sqlite3_backup *p, int nPage) {
    int rc = SQCloudBackupStep (p->backup, nPage, sqlite3cloud_backup_ondata);
    if (rc >= 0) return rc;
    return SQCloudErrorCode(p->db->connection);
}

int sqlite3cloud_backup_finish(sqlite3_backup *p) {
    if (SQCloudBackupFinish(p->backup) == true) {
        FILE *dest = (FILE *)SQCloudBackupData(p->backup);
        if (dest) fclose(dest);
        return SQLITE_OK;
    }
    return SQCloudErrorCode(p->db->connection);
}

int sqlite3cloud_backup_remaining(sqlite3_backup *p) {
    return (int)SQCloudBackupPageRemaining(p->backup);
}

int sqlite3cloud_backup_pagecount(sqlite3_backup *p) {
    return (int)SQCloudBackupPageCount(p->backup);
}

// MARK: - Others -

static void sqlite3cloud_keyword_refresh(void) {
    // force the keywords refresh only at the execution of the sqlite3cloud_keyword_refresh API
    if (gkeywords == NULL) {
        if (gconnection == NULL) return;
        SQCloudResult *temp = SQCloudExec(gconnection, "LIST KEYWORDS");
        if (SQCloudResultType(temp) != RESULT_ROWSET) SQCloudResultFree(temp);
        else gkeywords = temp;
    }
}

static void sqlite3cloud_compileopts_get(void) {
    if (gcompileopts == NULL) {
        if (gconnection == NULL) return;
        SQCloudResult *temp = SQCloudExec(gconnection, "LIST COMPILE OPTIONS");
        if (SQCloudResultType(temp) != RESULT_ROWSET) SQCloudResultFree(temp);
        else gcompileopts = temp;
    }
}

void sqlite3cloud_log(int iErrCode, const char *format, va_list args) {
    vprintf(format, args);
}

int sqlite3cloud_compileoption_used(const char *zOptName) {
    sqlite3cloud_compileopts_get();
    if (!gcompileopts) return 0;
    
    int n = SQCloudRowsetRows(gcompileopts);
    for (int i=0; i<n; ++i) {
        uint32_t len = 0;
        char *value = SQCloudRowsetValue(gcompileopts, i, 0, &len);
        if (sqlite3_strnicmp(zOptName, value, len) == 0) return 1;
    }
    
    return 0;
}

const char *sqlite3cloud_compileoption_get(int N) {
    sqlite3cloud_compileopts_get();
    if (!gcompileopts) return NULL;
    
    uint32_t len = 0;
    return SQCloudRowsetValue(gcompileopts, N, 0, &len);
}

int sqlite3cloud_keyword_count(void) {
    sqlite3cloud_keyword_refresh();
    
    return (gkeywords) ? (int)SQCloudRowsetRows(gkeywords): 0;
}

int sqlite3cloud_keyword_name(int i,const char **pzName,int *pnName) {
    sqlite3cloud_keyword_refresh();
    if (!gkeywords) return SQLITE_ERROR;
    
    if (i < 0 || i>= SQCloudRowsetRows(gkeywords)) return SQLITE_ERROR;
    
    uint32_t len = 0;
    const char *value = SQCloudRowsetValue(gkeywords, i, 0, &len);
    
    if (pzName) *pzName = value;
    if (pnName) *pnName = (int)len;
    
    return SQLITE_OK;
}

int sqlite3cloud_keyword_check(const char *zName, int nName) {
    sqlite3cloud_keyword_refresh();
    if (!gkeywords) return SQLITE_ERROR;
    
    uint32_t nrows = SQCloudRowsetRows(gkeywords);
    for (uint32_t i=0; i<nrows; ++i) {
        uint32_t len = 0;
        const char *value = SQCloudRowsetValue(gkeywords, i, 0, &len);
        if ((nName == len) && (strncasecmp(value, zName, len) == 0)) return 1;
    }
    
    return 0;
}

int sqlite3cloud_status(int op, sqlite3_int64 *pCurrent, sqlite3_int64 *pHighwater, int resetFlag) {
    if (op < 0) return SQLITE_MISUSE;
    if (!gconnection) return SQLITE_OK;
    
    char buffer[512];
    snprintf(buffer, sizeof(buffer), "SQLITE STATUS %d RESET %d", op, resetFlag);
    
    SQCloudResult *result = SQCloudExec(gconnection, buffer);
    if (SQCloudResultType(result) != RESULT_ARRAY) return SQLITE_OK;
    
    if (pCurrent) *pCurrent = SQCloudArrayInt64Value(result, 0);
    if (pHighwater) *pHighwater = SQCloudArrayInt64Value(result, 0);
    
    return SQLITE_OK;
}

// MARK: - Memory -

sqlite3_value *sqlite3cloud_value_dup(const sqlite3_value *pOrig) {
    sqlite3_value *value = sqlite3cloud_zeroalloc(sizeof(sqlite3_value));
    if (!value) return NULL;
    
    value = (sqlite3_value *)pOrig;
    return value;
}

void *sqlite3cloud_malloc(sqlite3_uint64 n) {
    if (n == 0) return NULL;
    sqlite3_uint64 *p = malloc(n + sizeof(sqlite3_uint64));
    if (!p) return NULL;
    p[0] = n;
    ++p;
    
    memory_used += n;
    if (memory_used >= memory_highwater) memory_highwater = memory_used;
    return (void *)p;
}

void *sqlite3cloud_zeroalloc(sqlite3_uint64 n) {
    if (n == 0) return NULL;
    sqlite3_uint64 *p = calloc(1, n + sizeof(sqlite3_uint64));
    if (!p) return NULL;
    p[0] = n;
    ++p;
    
    memory_used += n;
    if (memory_used >= memory_highwater) memory_highwater = memory_used;
    return (void *)p;
}

void *sqlite3cloud_realloc(void *pPrior, sqlite3_uint64 n) {
    if (pPrior == NULL) return sqlite3cloud_malloc(n);
    if (n == 0) {sqlite3cloud_free(pPrior); return NULL;}
    if (n >= 0x7fffff00) return NULL; // sqlite3Realloc hard limit
    
    sqlite3_uint64 *p = (sqlite3_uint64 *)pPrior;
    --p;
    sqlite3_uint64 old_size = p[0];
    sqlite3_uint64 new_size = n;
    p = realloc(p, (size_t)n + sizeof(sqlite3_uint64));
    if (p) {
        p[0] = n;
        ++p;
    }
    memory_used = memory_used - old_size + new_size;
    if (memory_used >= memory_highwater) memory_highwater = memory_used;
    return p;
}

void sqlite3cloud_free(void *pPrior) {
    if (pPrior == NULL) return;
    
    sqlite3_uint64 *p = (sqlite3_uint64 *)pPrior;
    --p;
    memory_used -= p[0];
    free(p);
}

char *sqlite3cloud_strndup(const char *str1, size_t len) {
    char *buffer = sqlite3cloud_zeroalloc(len+1);
    if (!buffer) return NULL;
    
    memcpy(buffer, str1, len);
    return buffer;
}

char *sqlite3cloud_strdup(const char *str1) {
    return sqlite3cloud_strndup(str1, strlen(str1));
}

sqlite3_uint64 sqlite3cloud_msize(void *pPrior) {
    sqlite3_uint64 *p = (sqlite3_uint64 *)pPrior;
    p--;
    return (sqlite3_uint64)p[0];
}

sqlite3_uint64 sqlite3cloud_totmem(void) {
    return memory_used;
}

int sqlite3cloud_sleep(int ms) {
    #if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
    Sleep(ms);
    #else
    usleep((ms)*1000);
    #endif
    
    return SQLITE_OK;
}

sqlite3_int64 sqlite3cloud_memory_highwater(int resetFlag) {
    sqlite3_int64 result = memory_highwater;
    if (resetFlag) memory_highwater = memory_used;
    return result;
}

     
//
// END FILE: sqlite3cloud_api.c
// ----------------------------------------------------------------------------



